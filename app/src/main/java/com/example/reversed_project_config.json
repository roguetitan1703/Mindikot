{
    "project_name": "mindikot",
    "structure": {
        "core": {
            "engine": {
                "DeckGenerator.kt": "package com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\n\nobject DeckGenerator {\n    /**\n     * Generates a standard Mindikot deck. For 6 players, Twos are excluded.\n     * @param numPlayers The number of players (4 or 6).\n     * @return A shuffled list of cards for the game.\n     */\n    fun generateDeck(numPlayers: Int): MutableList<Card> {\n        require(numPlayers == 4 || numPlayers == 6 || numPlayers == 2) { \"Mindikot supports 2, 4 or 6 players only.\" }\n        val includeTwos = (numPlayers == 4)\n\n        val deck = mutableListOf<Card>()\n        val allSuits = Suit.values()\n        val allRanks = Rank.values()\n\n        for (suit in allSuits) {\n            for (rank in allRanks) {\n                // Skip Twos if playing with 6 players\n                if (!includeTwos && rank == Rank.TWO) {\n                    continue\n                }\n                deck.add(Card(suit, rank))\n            }\n        }\n        // Shuffle the generated deck thoroughly before returning\n        return deck.shuffled().toMutableList()\n    }\n}\n",
                "GameEngine.kt": "package com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\nimport com.example.mindikot.core.state.GameState\nimport com.example.mindikot.core.state.InputType\n\n/**\n * Manages the core game flow, including playing tricks and handling state transitions. NOTE: This\n * implementation outlines the logic flow. A real implementation would need mechanisms (like\n * callbacks, suspend functions, or StateFlow) to handle asynchronous player input from the\n * UI/ViewModel layer. The points requiring input are marked.\n */\nobject GameEngine {\n\n    /**\n     * Determines the set of cards a player can legally play on their turn.\n     *\n     * @param playerHand The list of cards currently in the player's hand.\n     * @param currentTrickPlays The list of (Player, Card) pairs already played in the current\n     * trick.\n     * @param trumpSuit The current trump suit (null if not set).\n     * @param trumpRevealed Whether trump has been revealed.\n     * @return A list of cards from the player's hand that are valid to play.\n     */\n    fun determineValidMoves(\n            playerHand: List<Card>,\n            currentTrickPlays: List<Pair<Player, Card>>,\n            trumpSuit: Suit?,\n            trumpRevealed: Boolean\n    ): List<Card> {\n\n        // If player is leading the trick (no cards played yet)\n        if (currentTrickPlays.isEmpty()) {\n            return playerHand // Can lead any card\n        }\n\n        val leadCard = currentTrickPlays.first().second\n        val leadSuit = leadCard.suit\n\n        // Check if player can follow the lead suit\n        val cardsInLeadSuit = playerHand.filter { it.suit == leadSuit }\n        if (cardsInLeadSuit.isNotEmpty()) {\n            return cardsInLeadSuit // Must follow suit\n        }\n\n        // --- Cannot follow suit ---\n\n        // Check if trump is revealed and active\n        if (trumpRevealed && trumpSuit != null) {\n            // Rule: If cannot follow suit and trump is set, play ANY card.\n            return playerHand\n        } else {\n            // Rule: If cannot follow suit and trump is NOT set, play ANY card.\n            // The decision to CHOOSE/REVEAL/PASS happens separately.\n            // Special case: Mode B Reveal requires trump play if possible AFTER reveal.\n            // This function determines playable cards BEFORE that decision point.\n            return playerHand\n        }\n    }\n\n    // --- Interaction State Management Functions ---\n\n    /**\n     * Prepares the game state to request input from the appropriate player. This should be called\n     * at the start of a trick or after a player has played.\n     *\n     * @param state The current GameState to modify.\n     * @param playerIndex The index of the player whose turn it is.\n     * @return The modified GameState with updated input requirements.\n     */\n    fun requestInput(state: GameState, playerIndex: Int): GameState {\n        val currentPlayer = state.players[playerIndex]\n\n        if (state.currentTrickPlays.isEmpty()) { // Leading the trick\n            state.requiredInputType = InputType.PLAY_CARD\n        } else {\n            val leadSuit = state.currentTrickPlays.first().second.suit\n            val canFollowSuit = currentPlayer.hand.any { it.suit == leadSuit }\n\n            if (canFollowSuit) {\n                state.requiredInputType = InputType.PLAY_CARD\n            } else { // Cannot follow suit\n                if (state.trumpRevealed) {\n                    state.requiredInputType = InputType.PLAY_CARD // Play any card\n                } else { // Trump not revealed - need trump decision\n                    when (state.gameMode) {\n                        GameMode.CHOOSE_WHEN_EMPTY ->\n                                state.requiredInputType =\n                                        InputType.CHOOSE_TRUMP_SUIT // Player must play card to set\n                        // trump\n                        GameMode.FIRST_CARD_HIDDEN ->\n                                state.requiredInputType =\n                                        InputType.REVEAL_OR_PASS // Player chooses Reveal or Pass\n                    }\n                }\n            }\n        }\n        state.awaitingInputFromPlayerIndex = playerIndex\n        println(\n                \"GameEngine: Requesting ${state.requiredInputType} from Player ${state.players[playerIndex].name}\"\n        ) // Logging\n        return state\n    }\n\n    /**\n     * Processes the input received from a player (card played or trump decision). Validates the\n     * input against the rules and current state. Advances the game state (plays card, sets trump,\n     * finishes trick/round).\n     *\n     * @param currentState The current state of the game.\n     * @param playerInput The input received from the player (e.g., Card object, Decision enum).\n     * @return An updated GameState. The state might indicate further input is needed from the next\n     * player, or that the round/game ended.\n     */\n    fun processPlayerInput(\n            currentState: GameState,\n            playerInput:\n                    Any // Could be Card, Decision (Reveal/Pass), Suit (for potential future Mode A\n            // choice)\n            ): GameState {\n\n        val playerIndex =\n                currentState.awaitingInputFromPlayerIndex\n                        ?: run {\n                            println(\"Error: processPlayerInput called when no input was expected.\")\n                            return currentState // Or throw error\n                        }\n        val currentPlayer = currentState.players[playerIndex]\n        val currentRequirement = currentState.requiredInputType\n\n        println(\n                \"GameEngine: Processing input from Player ${currentPlayer.name}, expected: $currentRequirement, received: $playerInput\"\n        ) // Logging\n\n        // --- Validate and Process Input ---\n        when (currentRequirement) {\n            InputType.CHOOSE_TRUMP_SUIT -> {\n                // Mode A: Expecting a Card to be played which sets the trump\n                val playedCard = playerInput as? Card\n                if (playedCard == null || !currentPlayer.hand.contains(playedCard)) {\n                    println(\"Error: Invalid card provided for CHOOSE_TRUMP_SUIT.\")\n                    return currentState // Re-request input\n                }\n                // Validate it's a valid play (must be unable to follow suit)\n                val leadSuit = currentState.currentTrickPlays.firstOrNull()?.second?.suit\n                if (leadSuit != null && currentPlayer.hand.any { it.suit == leadSuit }) {\n                    println(\"Error: Player could follow suit, should not be choosing trump.\")\n                    return currentState // State logic error or invalid input sequence\n                }\n\n                TrumpHandler.setTrumpFromPlayedCard(currentState, playedCard)\n                playCard(currentState, currentPlayer, playedCard) // Play the card\n            }\n            InputType.REVEAL_OR_PASS -> {\n                // Mode B: Expecting a Decision (Reveal or Pass)\n                when (playerInput as? Decision) {\n                    Decision.REVEAL -> {\n                        TrumpHandler.revealHiddenTrump(currentState)\n                        // Now need player to play (Must play trump if possible)\n                        currentState.requiredInputType = InputType.PLAY_CARD\n                        currentState.awaitingInputFromPlayerIndex =\n                                playerIndex // Still this player's turn\n                        println(\n                                \"GameEngine: Player revealed trump. Requesting card play (must play trump if possible).\"\n                        )\n                        return currentState // Request card input with reveal constraint\n                    }\n                    Decision.PASS -> {\n                        TrumpHandler.handleTrumpPass(currentState)\n                        // Player plays ANY card\n                        currentState.requiredInputType = InputType.PLAY_CARD\n                        currentState.awaitingInputFromPlayerIndex =\n                                playerIndex // Still this player's turn\n                        println(\"GameEngine: Player passed trump. Requesting any card play.\")\n                        return currentState // Request card input (any card valid)\n                    }\n                    else -> {\n                        println(\"Error: Invalid decision provided for REVEAL_OR_PASS.\")\n                        return currentState // Re-request input\n                    }\n                }\n            }\n            InputType.PLAY_CARD -> {\n                val playedCard = playerInput as? Card\n                if (playedCard == null || !currentPlayer.hand.contains(playedCard)) {\n                    println(\"Error: Invalid card provided for PLAY_CARD.\")\n                    return currentState // Re-request input\n                }\n\n                // --- Complex Validation for PLAY_CARD ---\n                val leadSuit = currentState.currentTrickPlays.firstOrNull()?.second?.suit\n                val canFollowSuit =\n                        if (leadSuit != null) currentPlayer.hand.any { it.suit == leadSuit }\n                        else false\n\n                // 1. Must follow suit if possible?\n                if (leadSuit != null && playedCard.suit != leadSuit && canFollowSuit) {\n                    println(\n                            \"Error: Player must follow suit $leadSuit but played ${playedCard.suit}.\"\n                    )\n                    return currentState // Re-request input\n                }\n\n                // 2. Mode B Post-Reveal Constraint: Must play trump if revealed and possible?\n                // Need a way to know if this PLAY_CARD followed a REVEAL action in the same turn\n                // cycle...\n                // This architecture makes tracking that tricky. A state machine or temporary flag\n                // might be needed.\n                // Assuming for now the UI/ViewModel layer handles this constraint check *before*\n                // sending.\n\n                // If validation passes:\n                playCard(currentState, currentPlayer, playedCard)\n            }\n            null -> {\n                println(\"Error: processPlayerInput called when requiredInputType is null.\")\n                return currentState\n            }\n        }\n\n        // --- Post-Play State Update ---\n        currentState.requiredInputType = null // Reset requirement after successful processing\n        currentState.awaitingInputFromPlayerIndex = null // Clear awaiting player\n\n        // Check if trick is complete\n        if (currentState.currentTrickPlays.size == currentState.players.size) {\n            finishTrick(\n                    currentState\n            ) // Determine winner, collect cards, update tricksWon, set next leader\n\n            // Check if round ended (hands are empty)\n            if (currentState.players.first().hand.isEmpty()) {\n                println(\"GameEngine: Round finished.\")\n                // --- End of Round ---\n                // Caller (ViewModel) should check hand size and call RoundEvaluator\n                // and handle scoring/next round setup.\n            } else {\n                // Start next trick by requesting input from the new leader\n                return requestInput(currentState, currentState.currentLeaderIndex)\n            }\n        } else {\n            // Trick continues, request input from the next player\n            val nextPlayerIndex = (playerIndex + 1) % currentState.players.size\n            return requestInput(currentState, nextPlayerIndex)\n        }\n\n        return currentState // Return the final state after processing\n    }\n\n    /** Helper to add card to trick plays and remove from hand */\n    private fun playCard(state: GameState, player: Player, card: Card) {\n        state.currentTrickPlays.add(player to card)\n        player.hand.remove(card)\n        println(\"GameEngine: Player ${player.name} played ${card}\") // Logging\n    }\n\n    /** Called when a trick is complete to determine winner and collect cards. */\n    private fun finishTrick(state: GameState) {\n        println(\"GameEngine: Trick finished. Plays: ${state.currentTrickPlays.map { it.second }}\")\n        val winnerPlayer =\n                TrickHandler.determineTrickWinner(state.currentTrickPlays, state.trumpSuit)\n        val winnerIndex = state.players.indexOf(winnerPlayer)\n        println(\"GameEngine: Trick winner: ${winnerPlayer.name}\") // Logging\n\n        // Collect cards for the winning team\n        val winningTeam =\n                state.teams.first {\n                    it.id == winnerPlayer.teamId\n                } // Assuming player.teamId is correct\n        winningTeam.collectedCards.addAll(state.currentTrickPlays.map { it.second })\n        // println(\"Team ${winningTeam.id} collected cards. Total tens: ${winningTeam.countTens()}\")\n        // // Logging\n\n        // --- Update trick count ---\n        val currentTrickCount = state.tricksWon.getOrDefault(winningTeam.id, 0)\n        state.tricksWon[winningTeam.id] = currentTrickCount + 1 // Increment trick count\n        println(\n                \"GameEngine: Team ${winningTeam.id} tricks won this round: ${state.tricksWon[winningTeam.id]}\"\n        ) // Logging trick count\n\n        // Clear trick plays and set next leader\n        state.currentTrickPlays.clear()\n        state.currentLeaderIndex = winnerIndex\n\n        // Reset input requirement for the start of the next trick\n        // The requestInput function will be called next, setting the specific input type.\n        state.requiredInputType = null\n        state.awaitingInputFromPlayerIndex = null\n    }\n\n    // Enum for Reveal/Pass decision\n    enum class Decision {\n        REVEAL,\n        PASS\n    }\n}\n",
                "RoundEvaluator.kt": "package com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\nimport com.example.mindikot.core.state.GameState\n\nobject RoundEvaluator {\n\n    /**\n     * Data class to hold the result of a round evaluation.\n     * @property winningTeam The team that won the round (can be null if draw).\n     * @property isKot True if the win was due to collecting all four Tens.\n     */\n    data class RoundResult(val winningTeam: Team?, val isKot: Boolean)\n\n    /**\n     * Evaluates the end of a round: checks for Kot, then majority of tens, then trick tie-breaker.\n     *\n     * @param state The final GameState at the end of the round.\n     * @return RoundResult indicating the winning team (or null for draw) and whether it was a Kot\n     * win.\n     */\n    fun evaluateRound(state: GameState): RoundResult {\n        val teams = state.teams\n        println(\"Evaluating round end...\") // Logging\n\n        // 1. Instant Kot Check\n        teams.find { it.hasKot() }?.let {\n            println(\"Team ${it.id} wins round by KOT!\") // Logging\n            return RoundResult(it, true)\n        }\n\n        // 2. Count Tens for each team\n        val teamTensCount = teams.associate { team -> team.id to team.countTens() }\n        println(\"Tens collected: $teamTensCount\") // Logging\n\n        // 3. Determine Team with Most Tens\n        val maxTens = teamTensCount.values.maxOrNull() ?: 0\n        val teamsWithMaxTensIds = teamTensCount.filterValues { it == maxTens }.keys\n\n        // 4. Handle Winner Determination\n        if (teamsWithMaxTensIds.size == 1) {\n            // One team has clear majority of tens\n            val winningTeamId = teamsWithMaxTensIds.first()\n            val winningTeam = teams.first { it.id == winningTeamId }\n            println(\n                    \"Team ${winningTeam.id} wins round with majority of tens ($maxTens).\"\n            ) // Logging\n            return RoundResult(winningTeam, false) // Not Kot\n        } else if (teamsWithMaxTensIds.size > 1) {\n            // Tie in tens - apply trick tie-breaker\n            println(\"Tie in tens ($maxTens each). Applying trick tie-breaker.\") // Logging\n            val teamTricksWon = state.tricksWon // Get tricks won map from GameState\n            val tiedTeamsTrickCounts = teamTricksWon.filterKeys { it in teamsWithMaxTensIds }\n            println(\"Tricks won by tied teams: $tiedTeamsTrickCounts\") // Logging\n\n            val maxTricks =\n                    tiedTeamsTrickCounts.values.maxOrNull()\n                            ?: -1 // Use -1 to detect no tricks won case\n            val teamsWithMaxTricks = tiedTeamsTrickCounts.filterValues { it == maxTricks }.keys\n\n            if (teamsWithMaxTricks.size == 1) {\n                // One team won more tricks among the tied teams\n                val winningTeamId = teamsWithMaxTricks.first()\n                val winningTeam = teams.first { it.id == winningTeamId }\n                println(\n                        \"Team ${winningTeam.id} wins round due to trick tie-breaker ($maxTricks tricks).\"\n                ) // Logging\n                return RoundResult(winningTeam, false) // Not Kot\n            } else {\n                // Still tied (same number of tens AND same number of tricks) -> Draw\n                println(\"Round is a DRAW (tied tens and tricks).\") // Logging\n                return RoundResult(null, false) // Indicate draw\n            }\n        } else {\n            // Should not happen if there are teams, means no tens collected by anyone? Treat as\n            // draw.\n            println(\n                    \"Round evaluation resulted in no winner (possibly no tens collected). Treating as Draw.\"\n            ) // Logging\n            return RoundResult(null, false)\n        }\n    }\n}\n",
                "TrickHandler.kt": "package com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\n\nobject TrickHandler {\n    /**\n     * Determines the winner of a completed trick based on Mindikot rules.\n     *\n     * @param playedCards A list of (Player, Card) pairs representing the cards played in the trick,\n     * in order.\n     * @param trumpSuit The active trump suit for the round (can be null if trump is not set).\n     * @return The Player who won the trick.\n     */\n    fun determineTrickWinner(playedCards: List<Pair<Player, Card>>, trumpSuit: Suit?): Player {\n        require(playedCards.isNotEmpty()) { \"Cannot determine winner of an empty trick.\" }\n\n        val leadSuit = playedCards.first().second.suit\n        // var winningPlay: Pair<Player, Card> = playedCards.first() // Assume leader wins initially\n        var winningPlay: Pair<Player, Card>\n\n        // Check for highest trump card first\n        val trumpPlays = playedCards.filter { it.second.suit == trumpSuit && trumpSuit != null }\n        if (trumpPlays.isNotEmpty()) {\n            winningPlay = trumpPlays.maxByOrNull { it.second.rank.value }!!\n        } else {\n            // No trump played, check for highest card of the lead suit\n            val leadSuitPlays = playedCards.filter { it.second.suit == leadSuit }\n            // We know leadSuitPlays is not empty because the leader played one.\n            winningPlay = leadSuitPlays.maxByOrNull { it.second.rank.value }!!\n        }\n\n        return winningPlay.first // Return the winning player\n    }\n}\n",
                "TrumpHandler.kt": "package com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.state.GameState\n\n/**\n * Contains simple helper functions to update the game state related to trump setting. These\n * functions are intended to be called by the GameEngine AFTER a player has made their trump-related\n * decision via external input (UI/ViewModel).\n */\nobject TrumpHandler {\n\n    /**\n     * Updates the game state when a player chooses a trump suit in CHOOSE_WHEN_EMPTY mode by\n     * playing a card that establishes the trump. Precondition: state.trumpRevealed should be false.\n     *\n     * @param state The current GameState to modify.\n     * @param cardPlayed The card whose suit sets the trump.\n     */\n    fun setTrumpFromPlayedCard(state: GameState, cardPlayed: com.example.mindikot.core.model.Card) {\n        if (!state.trumpRevealed) {\n            state.trumpSuit = cardPlayed.suit\n            state.trumpRevealed = true\n            println(\n                    \"TrumpHandler: Trump set to ${state.trumpSuit} by card ${cardPlayed}\"\n            ) // Logging\n        }\n    }\n\n    /**\n     * Updates the game state when a player chooses to reveal the hidden card in FIRST_CARD_HIDDEN\n     * mode. Precondition: state.trumpRevealed should be false and state.hiddenCard should not be\n     * null.\n     *\n     * @param state The current GameState to modify.\n     */\n    fun revealHiddenTrump(state: GameState) {\n        if (!state.trumpRevealed &&\n                        state.hiddenCard != null &&\n                        state.gameMode == com.example.mindikot.core.model.GameMode.FIRST_CARD_HIDDEN\n        ) {\n            state.trumpSuit = state.hiddenCard!!.suit // Set trump to hidden card's suit\n            state.trumpRevealed = true\n            println(\n                    \"TrumpHandler: Trump revealed as ${state.trumpSuit} from hidden card\"\n            ) // Logging\n            // Note: GameEngine must enforce the special play rule for this turn.\n        }\n    }\n\n    /**\n     * Placeholder function to acknowledge the \"Pass\" action in FIRST_CARD_HIDDEN mode. No state\n     * change is needed regarding trump itself.\n     *\n     * @param state The current GameState (not modified here).\n     */\n    fun handleTrumpPass(state: GameState) {\n        // No change to state.trumpSuit or state.trumpRevealed.\n        println(\"TrumpHandler: Player chose to Pass.\") // Logging\n        // GameEngine allows the player to play any card for this trick.\n    }\n}\n"
            },
            "model": {
                "Card.kt": "package com.example.mindikot.core.model\n\ndata class Card(val suit: Suit, val rank: Rank) {\n    override fun toString(): String = \"${rank.displayName} of ${suit}\"\n}\n",
                "GameMode.kt": "package com.example.mindikot.core.model\n\nenum class GameMode {\n    CHOOSE_WHEN_EMPTY,\n    FIRST_CARD_HIDDEN\n}\n",
                "Player.kt": "package com.example.mindikot.core.model\n\ndata class Player(\n    val id: Int,\n    val name: String,\n    val teamId: Int,\n    var hand: MutableList<Card> = mutableListOf()\n) {\n    override fun toString() = \"Player(id=$id, name=$name, team=$teamId)\"\n}\n",
                "Rank.kt": "package com.example.mindikot.core.model\n\nenum class Rank(val value: Int, val displayName: String) {\n    TWO(2, \"2\"),\n    THREE(3, \"3\"),\n    FOUR(4, \"4\"),\n    FIVE(5, \"5\"),\n    SIX(6, \"6\"),\n    SEVEN(7, \"7\"),\n    EIGHT(8, \"8\"),\n    NINE(9, \"9\"),\n    TEN(10, \"10\"),\n    JACK(11, \"J\"),\n    QUEEN(12, \"Q\"),\n    KING(13, \"K\"),\n    ACE(14, \"A\")\n}\n",
                "Suit.kt": "package com.example.mindikot.core.model\n\nenum class Suit {\n    HEARTS, DIAMONDS, CLUBS, SPADES\n}\n",
                "Team.kt": "package com.example.mindikot.core.model\n\ndata class Team(\n    val id: Int,\n    val players: List<Player>,\n    val collectedCards: MutableList<Card> = mutableListOf()\n) {\n    fun countTens(): Int = collectedCards.count { it.rank == Rank.TEN }\n    fun hasKot(): Boolean = countTens() == 4\n}\n"
            },
            "state": {
                "GameState.kt": "package com.example.mindikot.core.state\n\nimport com.example.mindikot.core.model.*\n\n/**\n * Represents the complete state of the Mindikot game at any point in time. This object should be\n * immutable or handled carefully to ensure state consistency, especially when shared across network\n * or threads. Consider using immutable data structures if concurrency becomes complex.\n *\n * @property players List of all players participating in the game.\n * @property teams List of the teams, typically containing references to their players and collected\n * cards.\n * @property gameMode The selected mode for trump determination (e.g., CHOOSE_WHEN_EMPTY,\n * FIRST_CARD_HIDDEN).\n * @property requiredPlayers The number of players required for the game 4 or 6.\n * @property currentLeaderIndex The index (in the `players` list) of the player who leads the\n * current or next trick.\n * @property trumpSuit The suit designated as trump for the current round. Null if trump has not\n * been set yet.\n * @property trumpRevealed Boolean flag indicating whether the trump suit has been determined and\n * revealed for the current round.\n * @property hiddenCard In FIRST_CARD_HIDDEN mode, this holds the card set aside *before dealing*.\n * Null otherwise.\n * @property currentTrickPlays The cards played so far in the trick-in-progress. List<Pair<Player,\n * Card>>.\n * @property awaitingInputFromPlayerIndex Index of the player from whom input is currently awaited.\n * Null if the engine is processing or trick/round ended.\n * @property requiredInputType The type of input needed from the awaiting player.\n * @property tricksWon A map storing the number of tricks won by each team (TeamId -> Trick Count)\n * in the current round. Used for tie-breaking.\n */\ndata class GameState(\n        val players: List<Player>,\n        val teams: List<Team>,\n        val gameMode: GameMode,\n//        val requiredPlayers: Int, // <-- ADD THIS FIELD\n        var currentLeaderIndex: Int = 0,\n        var trumpSuit: Suit? = null,\n        var trumpRevealed: Boolean = false,\n        var hiddenCard: Card? = null, // Card set aside BEFORE dealing in FIRST_CARD_HIDDEN mode\n        val currentTrickPlays: MutableList<Pair<Player, Card>> =\n                mutableListOf(), // State of the current trick\n        var awaitingInputFromPlayerIndex: Int? = null, // Which player needs to act\n        var requiredInputType: InputType? = null, // What kind of action is needed\n        val tricksWon: MutableMap<Int, Int> =\n                mutableMapOf() // TeamId -> Trick Count for current round\n)\n\n/** Enum to represent the type of input currently required from a player. */\nenum class InputType {\n    PLAY_CARD, // Player needs to select a card to play\n    CHOOSE_TRUMP_SUIT, // Player needs to choose a trump suit by playing a card (Mode A)\n    REVEAL_OR_PASS // Player needs to decide Reveal or Pass (Mode B)\n}\n"
            }
        },
        "MainActivity.kt": "package com.example.mindikot\n\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.Modifier // Ensure this import is added\nimport androidx.navigation.compose.rememberNavController\nimport com.example.mindikot.ui.navigation.MainNavHost\nimport com.example.mindikot.ui.components.GameFooter\nimport com.example.mindikot.ui.theme.MindikotTheme\n\nclass MainActivity : ComponentActivity() {\n\n    private external fun stringFromJNI(): String\n\n    companion object {\n        init {\n            System.loadLibrary(\"mindikot\")\n        }\n    }\n\n    @OptIn(ExperimentalMaterial3Api::class) // Opt-In annotation for Material3 APIs\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        setContent {\n            MindikotTheme {\n                val navController = rememberNavController()\n\n                // State to hold the native string\n                var nativeText by remember { mutableStateOf(\"\") }\n\n                // Use LaunchedEffect to call the native method and set the result\n                LaunchedEffect(Unit) {\n                    nativeText = stringFromJNI() // This will run once during composition\n                }\n\n                Scaffold(\n                    topBar = {\n                        TopAppBar(\n                            title = { Text(\"Mindikot Game\") },\n                            colors = TopAppBarDefaults.mediumTopAppBarColors()\n                        )\n                    }\n                    ,\n                    bottomBar = {\n                        GameFooter(version = \"v1.0.0\") // \u00f0\u0178\u2018\u02c6 Footer added here\n                    }\n                ) { paddingValues ->\n                    // Main content is handled by MainNavHost, passing the navigation controller\n                    MainNavHost(navController = navController, modifier = Modifier.padding(paddingValues))\n\n                }\n\n            }\n        }\n    }\n}\n",
        "ui": {
            "components": {
                "GameFooter.kt": "package com.example.mindikot.ui.components\n\nimport android.content.Intent\nimport android.net.Uri\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.text.style.TextDecoration\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun GameFooter(version: String = \"v1.0.0\") {\n    val context = LocalContext.current\n\n    Column(\n            modifier = Modifier.fillMaxWidth().padding(top = 24.dp, bottom = 8.dp),\n            horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Divider(modifier = Modifier.padding(vertical = 8.dp))\n\n        Text(\n                text = \"Made with <love> by delpat\",\n                style =\n                        MaterialTheme.typography.bodySmall.copy(\n                                textDecoration = TextDecoration.Underline\n                        ),\n                color = MaterialTheme.colorScheme.primary,\n                modifier =\n                        Modifier.clickable {\n                            val intent =\n                                    Intent(\n                                            Intent.ACTION_VIEW,\n                                            Uri.parse(\"https://delpat-llp.web.app/\")\n                                    )\n                            context.startActivity(intent)\n                        }\n        )\n\n        Text(\"Version $version\", style = MaterialTheme.typography.bodySmall)\n    }\n}\n",
                "GameStatus.kt": "package com.example.mindikot.ui.components\n\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport com.example.mindikot.core.state.GameState\n\n@Composable\nfun GameStatus(gameState: GameState) {\n    Column {\n        Text(\"Round: ${gameState.gameMode}\", style = MaterialTheme.typography.headlineLarge)\n        Text(\"Current Leader: ${gameState.players[gameState.currentLeaderIndex].name}\", style = MaterialTheme.typography.bodyMedium)\n        Text(\"Trump Suit: ${gameState.trumpSuit?.name ?: \"None\"}\", style = MaterialTheme.typography.bodyMedium)\n    }\n}\n",
                "OtherPlayersDisplay.kt": "package com.example.mindikot.ui.components\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.shape.CircleShape\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Person // Or style_outlined depending on preference\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport com.example.mindikot.core.model.Player\n\n@Composable\nfun OtherPlayerDisplay(player: Player, isCurrentTurn: Boolean, modifier: Modifier = Modifier) {\n    val teamColor =\n            if (player.teamId == 1) Color(0xFFADD8E6)\n            else Color(0xFFFAC898) // Example Light Blue/Peach\n    val turnIndicatorColor =\n            if (isCurrentTurn) MaterialTheme.colorScheme.primary else Color.Transparent\n    val nameColor =\n            if (isCurrentTurn) MaterialTheme.colorScheme.primary\n            else MaterialTheme.colorScheme.onSurface\n\n    Column(\n            modifier =\n                    modifier.padding(8.dp)\n                            .border(\n                                    2.dp,\n                                    turnIndicatorColor,\n                                    CircleShape\n                            ) // Highlight border if turn\n                            .padding(8.dp), // Inner padding\n            horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Icon(\n                imageVector = Icons.Default.Person,\n                contentDescription = player.name,\n                modifier =\n                        Modifier.size(40.dp)\n                                .clip(CircleShape)\n                                .background(teamColor.copy(alpha = 0.5f))\n                                .padding(4.dp)\n        )\n        Spacer(modifier = Modifier.height(4.dp))\n        Text(\n                text = player.name,\n                fontWeight = if (isCurrentTurn) FontWeight.Bold else FontWeight.Normal,\n                fontSize = 14.sp,\n                color = nameColor\n        )\n        Spacer(modifier = Modifier.height(2.dp))\n        Text(\n                text = \"Cards: ${player.hand.size}\", // Display card count\n                fontSize = 12.sp,\n                color = Color.Gray\n        )\n    }\n}\n",
                "PlayerCardView.kt": "package com.example.mindikot.ui.components\n\nimport androidx.compose.foundation.BorderStroke\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.material3.Card\nimport androidx.compose.material3.CardDefaults\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.alpha\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport com.example.mindikot.core.model.Card\n\n@Composable\nfun CardView(\n        card: Card,\n        isValidMove: Boolean, // Can this card be played now?\n        isPlayable: Boolean, // Is it generally the player's turn to play any card?\n        onCardSelected: (Card) -> Unit,\n        modifier: Modifier = Modifier\n) {\n    val elevation = if (isValidMove) 8.dp else 2.dp\n    val alpha = if (isPlayable && !isValidMove) 0.6f else 1.0f // Dim invalid cards when it's turn\n    val borderColor = if (isValidMove) MaterialTheme.colorScheme.primary else Color.Gray\n\n    Card(\n            modifier =\n                    modifier.size(width = 70.dp, height = 100.dp) // Example fixed size\n                            .padding(horizontal = 2.dp, vertical = 4.dp)\n                            .alpha(alpha)\n                            .clickable(\n                                    enabled =\n                                            isValidMove &&\n                                                    isPlayable, // Clickable only if it's a valid\n                                    // move AND it's our turn\n                                    onClick = { onCardSelected(card) }\n                            ),\n            elevation = CardDefaults.cardElevation(defaultElevation = elevation),\n            border = BorderStroke(if (isValidMove) 2.dp else 0.5.dp, borderColor),\n            shape = MaterialTheme.shapes.medium // Or RoundedCornerShape(8.dp)\n    ) {\n        // Basic card representation (improve this visually)\n        Box(modifier = Modifier.padding(4.dp), contentAlignment = Alignment.Center) {\n            Text(\n                    text = \"${card.rank.displayName}${getSuitSymbol(card.suit)}\",\n                    fontSize = 18.sp, // Adjust size\n                    fontWeight = FontWeight.Bold,\n                    color = getSuitColor(card.suit)\n            )\n            // You can add separate Texts for top-left/bottom-right if needed\n        }\n    }\n}\n\n// Helper functions for visual representation (customize as needed)\n@Composable\nfun getSuitColor(suit: com.example.mindikot.core.model.Suit): Color {\n    return when (suit) {\n        com.example.mindikot.core.model.Suit.HEARTS,\n        com.example.mindikot.core.model.Suit.DIAMONDS -> Color.Red\n        com.example.mindikot.core.model.Suit.CLUBS, com.example.mindikot.core.model.Suit.SPADES ->\n                Color.Black\n    }\n}\n\nfun getSuitSymbol(suit: com.example.mindikot.core.model.Suit): String {\n    return when (suit) {\n        com.example.mindikot.core.model.Suit.HEARTS -> \"\u00e2\u2122\u00a5\"\n        com.example.mindikot.core.model.Suit.DIAMONDS -> \"\u00e2\u2122\u00a6\"\n        com.example.mindikot.core.model.Suit.CLUBS -> \"\u00e2\u2122\u00a3\"\n        com.example.mindikot.core.model.Suit.SPADES -> \"\u00e2\u2122\u00a0\"\n    }\n}\n",
                "PlayerHand.kt": "package com.example.mindikot.ui.components\n\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.lazy.LazyRow\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\nimport com.example.mindikot.core.model.Card\nimport com.example.mindikot.core.state.InputType\nimport com.example.mindikot.ui.components.CardView\n@Composable\nfun PlayerHand(\n        cards: List<Card>,\n        validMoves: Set<Card>, // Set of valid cards to play\n        isMyTurn: Boolean, // Is it currently the local player's turn?\n        requiredInputType: InputType?, // What kind of input is expected from the player\n        onCardSelected: (Card) -> Unit // Callback when a card is selected\n) {\n    LazyRow(\n            modifier = Modifier.padding(8.dp), // Optional padding around the hand\n            horizontalArrangement =\n                    androidx.compose.foundation.layout.Arrangement.spacedBy(\n                            4.dp\n                    ) // Spacing between cards\n    ) {\n        items(\n                items = cards,\n                key = { card ->\n                    \"${card.suit}-${card.rank}\"\n                } // Stable item keys for better performance\n        ) { card ->\n            CardView( // Use PlayerCardView now (or renamed CardView)\n                    card = card,\n                    isValidMove =\n                            card in validMoves, // Check if this card is in the valid moves set\n                    isPlayable =\n                            isMyTurn &&\n                                    (requiredInputType == InputType.PLAY_CARD ||\n                                            requiredInputType ==\n                                                    InputType\n                                                            .CHOOSE_TRUMP_SUIT), // Playable if it's\n                    // my turn AND\n                    // Play_Card input\n                    // expected\n                    onCardSelected = onCardSelected\n            )\n        }\n    }\n}\n"
            },
            "navigation": {
                "MainNavHost.kt": "package com.example.mindikot.ui.navigation // Keep or adjust package as needed\n\nimport android.content.Context // Import Context\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext // Import LocalContext\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.navigation.NavHostController\nimport androidx.navigation.compose.NavHost\nimport androidx.navigation.compose.composable\n// Import your screens correctly\nimport com.example.mindikot.ui.screens.*\n// **** FIX: Import ViewModel and Factory from new location ****\nimport com.example.mindikot.ui.viewmodel.GameViewModel\nimport com.example.mindikot.ui.viewmodel.factory.GameViewModelFactory\n\n\n@Composable\nfun MainNavHost(navController: NavHostController, modifier: Modifier = Modifier) {\n    // Get Application Context once for the factory\n    val applicationContext = LocalContext.current.applicationContext\n    // Use the factory from the correct location\n    val factory = GameViewModelFactory(applicationContext) // Create factory instance\n    val gameViewModel: GameViewModel = viewModel(factory = factory)\n    NavHost(navController = navController, startDestination = \"lobby\", modifier = modifier) {\n        composable(\"lobby\") {\n            // Create or get ViewModel scoped to this destination using the factory\n\n            // Pass the specific instance to the screen\n            LobbyScreen(navController = navController, viewModel = gameViewModel)\n        }\n        composable(\"game_host\") { // Screen where host waits\n\n            GameHostScreen(navController = navController, viewModel = gameViewModel)\n        }\n        composable(\"waiting_for_players\") { // Screen where joiner waits\n\n            WaitingForPlayersScreen(navController = navController, viewModel = gameViewModel)\n        }\n        composable(\"game\") { // The actual game screen\n\n            GameScreen(navController = navController, viewModel = gameViewModel)\n        }\n        composable(\"result\") {\n\n            ResultScreen(navController = navController, viewModel = gameViewModel)\n        }\n    }\n}"
            },
            "screens": {
                "GameHostScreen.kt": "package com.example.mindikot.ui.screens\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.unit.dp\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.navigation.NavController\n// Corrected ViewModel and Factory imports\nimport com.example.mindikot.ui.viewmodel.GameViewModel\nimport com.example.mindikot.ui.viewmodel.factory.GameViewModelFactory\nimport com.example.mindikot.ui.viewmodel.stopServerAndDiscovery // From GameViewModelHost.kt\n\nimport com.example.mindikot.ui.viewmodel.utils.log // Optional: Import log utility if needed here\n\n@Composable\nfun GameHostScreen(\n    navController: NavController,\n    // Use the factory to get the ViewModel instance\n    viewModel: GameViewModel = viewModel(\n        factory = GameViewModelFactory(LocalContext.current.applicationContext)\n    )\n) {\n    val gameState by viewModel.state.collectAsState()\n    // Use the dedicated count StateFlow from ViewModel\n    println(viewModel.isHost)\n    val connectedCount by viewModel.connectedPlayersCount.collectAsState()\n    // Get the definitive required count from ViewModel\n    val requiredPlayerCount = viewModel.requiredPlayerCount // Access directly\n    val gameStarted by viewModel.gameStarted.collectAsState()\n    val hostIp by viewModel.hostIpAddress.collectAsState() // Get host IP for display\n\n    // Log state changes for debugging UI\n    // LaunchedEffect(connectedCount, gameState.players) {\n    //     println(\"[UI - GameHostScreen] connectedCount = $connectedCount, required = $requiredPlayerCount\")\n    //     println(\"[UI - GameHostScreen] Player List State: ${gameState.players.map { p -> Pair(p.id, p.name) }}\")\n    // }\n\n\n    // Navigate to game screen once the game starts\n    LaunchedEffect(gameStarted) {\n        if (gameStarted) {\n             println(\"[UI - GameHostScreen] Game started state = true, navigating to game\") // Log nav\n            // Ensure navigation happens only once\n            if (navController.currentDestination?.route != \"game\") {\n                navController.navigate(\"game\") {\n                    // Pop up to lobby to clear hosting/waiting screens from backstack\n                    popUpTo(\"lobby\") { inclusive = false }\n                }\n            }\n        }\n    }\n\n    // Server start is handled when navigating here from Lobby's GameConfigCard\n    // Cleanup is handled by ViewModel's onCleared or explicitly calling stop\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(24.dp),\n        verticalArrangement = Arrangement.spacedBy(16.dp),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\"Game Host Lobby\", style = MaterialTheme.typography.headlineMedium)\n\n        // Display config only if state is initialized\n        if (requiredPlayerCount > 0 && gameState.players.isNotEmpty()) { // Check players list too\n            Text(\"Mode: ${gameState.gameMode.name}\")\n            Text(\"Players Required: $requiredPlayerCount\")\n            if(hostIp != null) {\n                Text(\"Your IP: $hostIp\", style = MaterialTheme.typography.bodySmall, color = Color.Gray)\n            } else {\n                 Text(\"Advertising game...\", style = MaterialTheme.typography.bodySmall, color = Color.Gray)\n            }\n        } else {\n            Text(\"Initializing host settings...\")\n        }\n        Divider(modifier = Modifier.padding(vertical = 8.dp))\n\n        // Use connectedCount and requiredPlayerCount correctly\n        Text(\"Waiting for players... ($connectedCount/$requiredPlayerCount)\")\n\n        // Display players from the GameState\n        LazyColumn(\n            modifier = Modifier\n                .fillMaxWidth()\n                .weight(1f) // Takes remaining space\n                .padding(vertical = 8.dp),\n            verticalArrangement = Arrangement.spacedBy(8.dp)\n        ) {\n            // Ensure players list is not empty before showing items\n            if (gameState.players.isNotEmpty()) {\n                items(gameState.players, key = { \"player_${it.id}\" }) { player -> // Use player ID for key\n                    val isMe = player.id == viewModel.localPlayerId // Host is ID 0\n                    val isConnected = player.name != \"Waiting...\" && player.name != \"[Disconnected]\" && !player.name.contains(\"[LEFT]\")\n                    val cardColor = when {\n                         isMe -> MaterialTheme.colorScheme.primaryContainer\n                         isConnected -> MaterialTheme.colorScheme.surfaceVariant\n                         else -> MaterialTheme.colorScheme.surface.copy(alpha = 0.6f) // Dim disconnected/waiting\n                    }\n                    val textColor = when {\n                         isMe -> MaterialTheme.colorScheme.onPrimaryContainer\n                         isConnected -> MaterialTheme.colorScheme.onSurfaceVariant\n                         else -> LocalContentColor.current.copy(alpha = 0.6f)\n                    }\n\n\n                    Card(\n                        modifier = Modifier.fillMaxWidth(),\n                        colors = CardDefaults.cardColors(containerColor = cardColor),\n                        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)\n                    ) {\n                        Text(\n                            // Display player name and status\n                            text = player.name + if (isMe) \" (Host - You)\" else \"\",\n                            modifier = Modifier.padding(16.dp),\n                            style = MaterialTheme.typography.bodyLarge,\n                            color = textColor\n                        )\n                    }\n                }\n            } else {\n                item { Text(\"Waiting for player data...\")} // Placeholder if list is empty\n            }\n        }\n\n        Button(\n            onClick = {\n                // Call the ViewModel function to stop hosting\n                viewModel.stopServerAndDiscovery() // Use host extension method\n                navController.navigate(\"lobby\") {\n                    popUpTo(\"lobby\") { inclusive = true } // Go back to lobby, clear this screen\n                }\n            },\n            colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)\n        ) {\n            Text(\"Cancel Game\")\n        }\n\n        if (connectedCount < requiredPlayerCount) {\n            Text(\n                text = \"Game will start automatically when all players join.\",\n                style = MaterialTheme.typography.bodySmall,\n                color = Color.Gray\n            )\n        }\n    }\n}",
                "GameScreen.kt": "package com.example.mindikot.ui.screens\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyRow\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.text.font.FontWeight\n//import border stroke\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.foundation.BorderStroke // Import this\nimport androidx.compose.ui.text.style.TextAlign // Ensure this is imported\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.navigation.NavController\nimport com.example.mindikot.core.engine.GameEngine // Needed for Decision and determineValidMoves\nimport com.example.mindikot.core.model.Card // Keep Card model import\nimport com.example.mindikot.core.state.InputType // Keep InputType import\n// Corrected ViewModel and Factory imports\nimport com.example.mindikot.ui.viewmodel.GameViewModel\nimport com.example.mindikot.ui.viewmodel.factory.GameViewModelFactory\n// Import UI components used\nimport com.example.mindikot.ui.components.OtherPlayerDisplay\nimport com.example.mindikot.ui.components.CardView\nimport com.example.mindikot.ui.components.getSuitSymbol\nimport com.example.mindikot.ui.components.getSuitColor\nimport kotlinx.coroutines.flow.collectLatest\n\n\n\n@Composable\nfun GameScreen(\n    navController: NavController,\n    viewModel: GameViewModel = viewModel(\n        factory = GameViewModelFactory(LocalContext.current.applicationContext)\n    )\n) {\n    val gameState by viewModel.state.collectAsState()\n    val localPlayerId = viewModel.localPlayerId // Access directly\n    val snackbarHostState = remember { SnackbarHostState() }\n\n    // Find the local player object (handle null briefly during init)\n    val localPlayer = remember(gameState.players, localPlayerId) {\n        gameState.players.find { it.id == localPlayerId }\n    }\n\n    // Determine if it's the local player's turn\n    val isMyTurn = remember(gameState.awaitingInputFromPlayerIndex, localPlayerId) {\n        gameState.awaitingInputFromPlayerIndex == localPlayerId\n    }\n\n    // Calculate valid moves when it's our turn and player data is available\n    val validMoves: Set<Card> = remember(gameState, localPlayerId, isMyTurn, localPlayer?.hand) {\n        if (isMyTurn && localPlayer != null) {\n            GameEngine.determineValidMoves(\n                playerHand = localPlayer.hand,\n                currentTrickPlays = gameState.currentTrickPlays,\n                trumpSuit = gameState.trumpSuit,\n                trumpRevealed = gameState.trumpRevealed\n            ).toSet() // Use Set for faster lookups (O(1) contains check)\n        } else {\n            emptySet() // Not our turn or player data not ready, no valid moves to calculate/show\n        }\n    }\n\n    // Listen for errors and show snackbar\n    LaunchedEffect(viewModel.showError, snackbarHostState) {\n        viewModel.showError.collectLatest { message ->\n            snackbarHostState.showSnackbar(\n                message = message,\n                duration = SnackbarDuration.Short\n            )\n        }\n    }\n\n    // Listen for navigation to results screen event\n    LaunchedEffect(viewModel.navigateToResultScreen, navController) {\n        viewModel.navigateToResultScreen.collectLatest { result ->\n            // Optional: Pass result data to ResultScreen if needed via navigation arguments\n            println(\"[UI - GameScreen] Navigating to Result screen.\")\n            // Ensure navigation happens only once per event\n            if (navController.currentDestination?.route != \"result\") {\n                navController.navigate(\"result\") {\n                    // Clear back stack up to lobby\n                    popUpTo(\"lobby\") { inclusive = false }\n                }\n            }\n        }\n    }\n\n    // Handle back press - maybe ask for confirmation or disconnect?\n    // BackHandler { ... }\n\n    Scaffold(snackbarHost = { SnackbarHost(hostState = snackbarHostState) }) { paddingValues ->\n        Column(\n            modifier = Modifier\n                .fillMaxSize()\n                .padding(paddingValues) // Apply padding from Scaffold\n                .padding(8.dp) // Add overall padding inside Scaffold\n        ) {\n\n            // --- Top Area: Game Status Header ---\n            GameStatusHeader(gameState = gameState)\n\n            Spacer(modifier = Modifier.height(8.dp))\n\n            // --- Middle Area: Board (Other Players + Trick) ---\n            PlayerBoard(\n                modifier = Modifier.weight(1f), // Takes up available vertical space\n                gameState = gameState,\n                localPlayerId = localPlayerId\n            )\n\n            Spacer(modifier = Modifier.height(8.dp))\n\n            // --- Center Bottom: Action Prompt / Info ---\n            ActionPrompt(\n                gameState = gameState,\n                localPlayerId = localPlayerId\n            )\n\n            Spacer(modifier = Modifier.height(8.dp))\n\n            // --- Bottom Area: Local Player Hand & Actions ---\n            if (localPlayer != null) {\n                LocalPlayerArea(\n                    localPlayerHand = localPlayer.hand,\n                    isMyTurn = isMyTurn,\n                    validMoves = validMoves, // Pass the calculated valid moves\n                    requiredInputType = gameState.requiredInputType,\n                    onCardSelected = { card -> viewModel.onCardPlayed(card) }, // Call VM method\n                    onReveal = { viewModel.onRevealOrPass(GameEngine.Decision.REVEAL) }, // Call VM method\n                    onPass = { viewModel.onRevealOrPass(GameEngine.Decision.PASS) } // Call VM method\n                )\n            } else {\n                // Placeholder if local player data isn't ready yet (e.g., client just connected)\n                Box(modifier = Modifier.fillMaxWidth().height(120.dp), contentAlignment = Alignment.Center) {\n                     CircularProgressIndicator()\n                     Text(\" Loading your hand...\", modifier = Modifier.padding(top = 60.dp))\n                }\n            }\n        }\n    }\n}\n\n// --- Helper Composables for GameScreen ---\n\n@Composable\nfun GameStatusHeader(gameState: com.example.mindikot.core.state.GameState) {\n    Row(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(horizontal = 8.dp, vertical = 4.dp),\n        horizontalArrangement = Arrangement.SpaceBetween,\n        verticalAlignment = Alignment.CenterVertically\n    ) {\n        // Display Trump Suit\n        val trumpText = gameState.trumpSuit?.let { getSuitSymbol(it) } ?: \"None\"\n        val trumpColor = if (gameState.trumpRevealed) MaterialTheme.colorScheme.primary else Color.Gray\n        Text(\n            text = \"Trump: $trumpText\",\n            fontWeight = FontWeight.Bold,\n            color = trumpColor\n        )\n\n        // Display Tricks Won per Team\n        Text(text = \"Tricks Won:\", fontWeight = FontWeight.Bold)\n        Row {\n            gameState.teams.forEach { team ->\n                val teamScore = gameState.tricksWon[team.id] ?: 0\n                 // Optionally color code team scores based on teamId\n                 // val teamColor = if(team.id == 1) Color.Blue else Color.Red\n                Text(\n                    text = \" T${team.id}: $teamScore\",\n                    modifier = Modifier.padding(start = 4.dp)\n                    // color = teamColor\n                )\n            }\n        }\n    }\n    Divider() // Add a visual separator below the status header\n}\n\n@Composable\nfun PlayerBoard(\n    modifier: Modifier = Modifier,\n    gameState: com.example.mindikot.core.state.GameState,\n    localPlayerId: Int\n) {\n    // Using BoxWithConstraints allows placing elements relative to the container size, good for different screen sizes\n    BoxWithConstraints(modifier = modifier.fillMaxWidth()) {\n        val density = androidx.compose.ui.platform.LocalDensity.current\n        val widthDp = with(density) { constraints.maxWidth.toDp() }\n        val heightDp = with(density) { constraints.maxHeight.toDp() }\n\n        // --- Trick Area (Center) ---\n        Box(\n            modifier = Modifier\n                .align(Alignment.Center)\n                .sizeIn( // Allow flexibility but constrain size\n                    maxWidth = widthDp * 0.7f,\n                    maxHeight = heightDp * 0.5f\n                )\n                .padding(vertical = 20.dp), // Add vertical padding to avoid overlap with players\n            contentAlignment = Alignment.Center\n        ) {\n            // Display cards played in the current trick\n            LazyRow(\n                 horizontalArrangement = Arrangement.spacedBy(2.dp, Alignment.CenterHorizontally),\n                 verticalAlignment = Alignment.CenterVertically\n             ) {\n                items(gameState.currentTrickPlays, key = { \"trick_${it.first.id}\" }) { (player, card) ->\n                    // Use a smaller card view for the trick\n                    Card(\n                        modifier = Modifier\n                           .size(width = 50.dp, height = 75.dp) // Fixed size for trick cards\n                           .padding(1.dp),\n                        elevation = CardDefaults.cardElevation(1.dp),\n                        border = BorderStroke(0.5.dp, Color.Gray)\n                    ) {\n                        Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {\n                            Text(\n                                text = \"${card.rank.displayName}${getSuitSymbol(card.suit)}\",\n                                color = getSuitColor(card.suit), // Use helper from components\n                                fontSize = 14.sp,\n                                fontWeight = FontWeight.Bold\n                            )\n                        }\n                    }\n                }\n            }\n            if (gameState.currentTrickPlays.isEmpty()) {\n                Text(\"Play Area\", color = Color.Gray, style = MaterialTheme.typography.bodySmall)\n            }\n        }\n\n        // --- Other Players ---\n        // Filter out the local player and any potentially invalid entries\n        val otherPlayers = gameState.players.filter { it.id != localPlayerId && it.id >= 0 }\n\n        // Dynamic positioning based on player count (Simplified example for 4 players)\n        // TODO: Enhance layout for 6 players\n        val numOtherPlayers = otherPlayers.size\n        val alignmentMap4 = mapOf(\n            0 to Alignment.CenterStart, // Left\n            1 to Alignment.TopCenter,   // Top\n            2 to Alignment.CenterEnd    // Right\n        )\n        val alignmentMap6 = mapOf( // Example for 6 players\n             0 to Alignment.CenterStart,\n             1 to Alignment.TopStart,\n             2 to Alignment.TopCenter,\n             3 to Alignment.TopEnd,\n             4 to Alignment.CenterEnd\n        )\n        // Choose map based on total players (assume 4 or 6 for now)\n        val alignmentMap = if(gameState.players.size == 6) alignmentMap6 else alignmentMap4\n\n        // Find relative position index for each player (simple cyclic assignment)\n        val localPlayerIndex = gameState.players.indexOfFirst { it.id == localPlayerId }\n        if (localPlayerIndex != -1) {\n             otherPlayers.forEach { player ->\n                 val playerIndex = gameState.players.indexOfFirst { it.id == player.id }\n                 // Calculate relative index based on local player's position\n                 val relativeIndex = (playerIndex - localPlayerIndex -1 + gameState.players.size) % gameState.players.size\n                 val alignment = alignmentMap[relativeIndex] ?: Alignment.TopCenter // Default if map doesn't cover\n\n                 OtherPlayerDisplay(\n                     player = player,\n                     isCurrentTurn = gameState.awaitingInputFromPlayerIndex == player.id,\n                     modifier = Modifier.align(alignment) // Align based on calculated position\n                 )\n             }\n        } else {\n             // Fallback if local player not found yet - just list them at top?\n              Row(Modifier.align(Alignment.TopCenter)) {\n                   otherPlayers.forEach { player ->\n                        OtherPlayerDisplay(\n                           player = player,\n                           isCurrentTurn = gameState.awaitingInputFromPlayerIndex == player.id,\n                           modifier = Modifier.padding(horizontal = 4.dp)\n                       )\n                   }\n              }\n        }\n    }\n}\n\n@Composable\nfun ActionPrompt(gameState: com.example.mindikot.core.state.GameState, localPlayerId: Int) {\n    val currentTurnPlayerId = gameState.awaitingInputFromPlayerIndex\n    val isMyTurn = currentTurnPlayerId == localPlayerId\n\n    val promptText = when {\n        isMyTurn -> { // It's our turn\n            when (gameState.requiredInputType) {\n                InputType.PLAY_CARD -> \"Your Turn: Play a card\"\n                InputType.CHOOSE_TRUMP_SUIT -> \"Your Turn: Play card to set Trump\"\n                InputType.REVEAL_OR_PASS -> \"Your Turn: Reveal Trump or Pass?\"\n                null -> \"Your Turn...\" // Should ideally not happen if state logic is correct\n            }\n        }\n        currentTurnPlayerId != null -> { // Someone else's turn\n            val waitingPlayerName = gameState.players.find { it.id == currentTurnPlayerId }?.name ?: \"Opponent\"\n            // Add \"(Partner)\" if they are on the same team?\n            \"Waiting for $waitingPlayerName...\"\n        }\n        else -> { // No one's turn (e.g., between tricks, before game start, round end)\n            if (gameState.players.isNotEmpty() && gameState.players.all { it.hand.isEmpty()} && gameState.currentTrickPlays.isEmpty()) {\n                 \"Round Over\" // Indicate round end state\n            } else if (gameState.currentTrickPlays.isNotEmpty() && gameState.currentTrickPlays.size == gameState.players.size) {\n                \"Trick Finished...\" // Briefly show between tricks\n            } else {\n                 \"\" // Default empty if no specific state applies\n            }\n        }\n    }\n\n    Text(\n        text = promptText,\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(vertical = 8.dp)\n            .heightIn(min = 24.dp), // Ensure minimum height for the prompt area\n        textAlign = TextAlign.Center, // Use TextAlign enum\n        style = MaterialTheme.typography.titleMedium, // Slightly larger prompt text\n        fontWeight = if (isMyTurn) FontWeight.Bold else FontWeight.Normal,\n        color = if (isMyTurn) MaterialTheme.colorScheme.primary else LocalContentColor.current\n    )\n}\n\n@Composable\nfun LocalPlayerArea(\n    localPlayerHand: List<Card>,\n    isMyTurn: Boolean,\n    validMoves: Set<Card>, // Use the Set passed down\n    requiredInputType: InputType?,\n    onCardSelected: (Card) -> Unit,\n    onReveal: () -> Unit,\n    onPass: () -> Unit\n) {\n    Column(\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = Modifier.fillMaxWidth()\n    ) {\n        // --- Player Hand ---\n        // Sort hand for consistent display (e.g., by suit then rank)\n         val sortedHand = remember(localPlayerHand) {\n             localPlayerHand.sortedWith(compareBy({ it.suit }, { it.rank.value }))\n         }\n\n        LazyRow(\n            modifier = Modifier.fillMaxWidth().padding(vertical = 4.dp),\n            horizontalArrangement = Arrangement.spacedBy( (-10).dp, Alignment.CenterHorizontally), // Overlap cards slightly\n            verticalAlignment = Alignment.CenterVertically\n        ) {\n            items(sortedHand, key = { \"${it.suit}-${it.rank}\" }) { card ->\n                // Determine if the card is playable based on turn and required input\n                 val isPlayableNow = isMyTurn &&\n                         (requiredInputType == InputType.PLAY_CARD || requiredInputType == InputType.CHOOSE_TRUMP_SUIT)\n                 val isValid = card in validMoves // Check against the valid moves set\n\n                CardView( // Use the dedicated CardView component\n                    card = card,\n                    isValidMove = isValid, // Highlight if it's a valid move\n                    isPlayable = isPlayableNow, // Enable/disable click based on turn and input type\n                    onCardSelected = onCardSelected,\n                    modifier = Modifier.padding(horizontal = 2.dp) // Add slight horizontal padding if needed\n                )\n            }\n        }\n        // Show hand size\n        Text(\"Cards: ${localPlayerHand.size}\", style = MaterialTheme.typography.bodySmall)\n\n\n        Spacer(modifier = Modifier.height(8.dp))\n\n        // --- Action Buttons (Conditional) ---\n        // Show Reveal/Pass buttons only when it's the player's turn AND that specific input is required\n        if (isMyTurn && requiredInputType == InputType.REVEAL_OR_PASS) {\n            Row(\n                horizontalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterHorizontally),\n                modifier = Modifier.fillMaxWidth().padding(bottom = 8.dp) // Ensure centered\n            ) {\n                Button(onClick = onReveal) { Text(\"Reveal Trump\") }\n                Button(onClick = onPass) { Text(\"Pass\") }\n            }\n        } else {\n             // Reserve space for buttons even when not visible to prevent layout jumps\n             Spacer(modifier = Modifier.height(48.dp)) // Approx height of buttons row\n        }\n    }\n}",
                "LobbyScreen.kt": "package com.example.mindikot.ui.screens\n\n// Required Android & Compose Imports\nimport android.Manifest\nimport android.app.Activity // Needed for shouldShowRequestPermissionRationale\nimport android.content.Context\nimport android.content.Intent\nimport android.content.pm.PackageManager\nimport android.net.Uri\nimport android.os.Build\nimport android.provider.Settings\nimport android.widget.Toast\nimport androidx.activity.compose.rememberLauncherForActivityResult\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.compose.foundation.BorderStroke\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.foundation.verticalScroll\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.unit.dp\nimport androidx.core.app.ActivityCompat // Needed for rationale check\nimport androidx.core.content.ContextCompat\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.ViewModelProvider\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.navigation.NavController\nimport com.example.mindikot.core.model.GameMode\n// Corrected ViewModel and Factory imports\nimport com.example.mindikot.ui.viewmodel.GameViewModel\nimport com.example.mindikot.ui.viewmodel.factory.GameViewModelFactory\nimport com.example.mindikot.ui.viewmodel.utils.log // Optional import for logging\nimport android.net.nsd.NsdServiceInfo // Keep NSD import\nimport com.example.mindikot.ui.viewmodel.utils.logError // Import logError\nimport com.example.mindikot.ui.viewmodel.stopServerAndDiscovery // From GameViewModelHost.kt\nimport com.example.mindikot.ui.viewmodel.stopNsdDiscovery     // From GameViewModelNsd.kt\nimport com.example.mindikot.ui.viewmodel.disconnectFromServer // From GameViewModelClient.kt\nimport com.example.mindikot.ui.viewmodel.connectToDiscoveredHost // From GameViewModelClient.kt\nimport com.example.mindikot.ui.viewmodel.startServerAndDiscovery // From GameViewModelHost.kt\nimport com.example.mindikot.ui.viewmodel.startNsdDiscovery // From GameViewModelNsd.kt\nimport com.example.mindikot.ui.viewmodel.registerNsdService // From GameViewModelNsd.kt\nimport com.example.mindikot.ui.viewmodel.unregisterNsdService // From GameViewModelNsd.kt\n\n@Composable\nfun LobbyScreen(\n    navController: NavController,\n    // Use the factory to get the ViewModel instance\n    viewModel: GameViewModel = viewModel(\n        factory = GameViewModelFactory(LocalContext.current.applicationContext)\n    )\n) {\n    var playerName by remember { mutableStateOf(\"\") }\n    var selectedRole by remember { mutableStateOf<String?>(null) } // \"Host\" or \"Joiner\"\n    val context = LocalContext.current\n    val activity = context as? Activity // Needed for permission rationale check\n\n    // State for permission dialogs\n    var showRationaleDialog by remember { mutableStateOf(false) }\n    var showSettingsGuidance by remember { mutableStateOf(false) }\n\n    // --- Permission Handling ---\n    // Define required permission based on Android version for NSD\n    val requiredPermission = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {\n        // Android 12+ requires FINE_LOCATION for NSD discovery/advertising involving IP addresses\n        Manifest.permission.ACCESS_FINE_LOCATION\n    } else {\n        // Older versions might implicitly allow NSD with just INTERNET,\n        // but CHANGE_WIFI_MULTICAST_STATE is often needed too.\n        // For simplicity, we can check INTERNET or just assume granted on older APIs if needed.\n        // Let's stick with FINE_LOCATION check for S+ as it's the stricter requirement.\n        // On older versions, we might assume it works or handle potential failures.\n        // For this example, let's enforce the check mainly for S+ where it's mandatory.\n        // If targeting older APIs heavily, add more specific checks.\n        // If we don't need location on older APIs, maybe return null or a basic permission like INTERNET.\n         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\n              // Basic network permissions likely suffice here, but FINE_LOCATION check below handles S+\n              null // Let the hasPermission check handle this\n         } else {\n              null // Very old API, assume OK or handle error\n         }\n    }\n\n    // Track current permission status\n    var hasPermission by remember {\n        mutableStateOf(\n            requiredPermission == null || // Assume granted if no specific permission needed for this OS version\n            ContextCompat.checkSelfPermission(context, requiredPermission) == PackageManager.PERMISSION_GRANTED\n        )\n    }\n\n    // Permission Request Launcher\n    val permissionLauncher = rememberLauncherForActivityResult(\n        ActivityResultContracts.RequestPermission()\n    ) { isGranted: Boolean ->\n        hasPermission = isGranted\n        if (!isGranted) {\n            // Check if user permanently denied (don't show rationale again)\n            if (activity != null && requiredPermission != null && !ActivityCompat.shouldShowRequestPermissionRationale(activity, requiredPermission)) {\n                // User selected \"Don't ask again\" or permission is disabled by policy\n                showSettingsGuidance = true // Guide user to settings\n            } else {\n                // Permission denied, but can ask again (or first denial)\n                Toast.makeText(context, \"Permission denied. Cannot host or join.\", Toast.LENGTH_LONG).show()\n            }\n            selectedRole = null // Reset role choice if permission denied\n        } else {\n            // Permission granted! User can proceed with the selected role.\n            Toast.makeText(context, \"Permission granted!\", Toast.LENGTH_SHORT).show()\n             // Re-trigger the action associated with the selected role if needed\n             // (Usually handled by the button's onClick re-evaluation)\n        }\n    }\n    // --- End Permission Handling ---\n\n    // Reset role if player name becomes blank\n    LaunchedEffect(playerName) {\n        if (playerName.isBlank()) {\n             selectedRole = null\n         }\n    }\n\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(24.dp)\n            // Use verticalScroll for potentially long content (Joiner list)\n            .verticalScroll(rememberScrollState()),\n        verticalArrangement = Arrangement.spacedBy(20.dp),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\"Mindikot Lobby\", style = MaterialTheme.typography.headlineMedium)\n\n        OutlinedTextField(\n            value = playerName,\n            onValueChange = { playerName = it.filter { c -> c.isLetterOrDigit() || c == ' ' }.take(16) }, // Limit name length/chars\n            label = { Text(\"Enter your name (max 16)\") },\n            modifier = Modifier.fillMaxWidth(),\n            singleLine = true\n        )\n\n        Text(\"Select your role:\", style = MaterialTheme.typography.titleMedium)\n\n        // --- Role Selection Logic ---\n        Row(\n            horizontalArrangement = Arrangement.spacedBy(12.dp, Alignment.CenterHorizontally),\n            verticalAlignment = Alignment.CenterVertically,\n            modifier = Modifier.fillMaxWidth() // Center the row content\n        ) {\n            listOf(\"Host\", \"Joiner\").forEach { role ->\n                Button(\n                    onClick = {\n                        if (playerName.isBlank()) {\n                            Toast.makeText(context, \"Please enter your name first.\", Toast.LENGTH_SHORT).show()\n                            return@Button\n                        }\n\n                        // Check current permission status *before* selecting role\n                        val currentPermissionStatus = if (requiredPermission != null) {\n                             ContextCompat.checkSelfPermission(context, requiredPermission)\n                        } else {\n                             PackageManager.PERMISSION_GRANTED // Assume granted if no specific permission needed\n                        }\n                        hasPermission = (currentPermissionStatus == PackageManager.PERMISSION_GRANTED)\n\n                        if (hasPermission) { // Permission OK\n                            // Only change role if different, or first selection\n                            if (selectedRole != role) {\n                                 selectedRole = role\n                                 // Clean up previous network state when switching roles\n                                 if (role == \"Host\") {\n                                     viewModel.isHost = true\n                                     viewModel.stopNsdDiscovery()\n                                     viewModel.disconnectFromServer()\n                                     // Initialize settings for host (will be done again in HostSection, but good practice)\n                                     // viewModel.initializeGameSettings(playerName, GameMode.CHOOSE_WHEN_EMPTY, true, 4) // Default init?\n                                 } else { // Switching to Joiner\n                                     viewModel.stopServerAndDiscovery()\n                                     // No need to init settings for joiner here\n                                     viewModel.isHost = false\n\n                                 }\n                            }\n                        } else if (requiredPermission != null) { // Permission NOT granted and is required\n                            // Need to request or show rationale\n                            if (activity != null && ActivityCompat.shouldShowRequestPermissionRationale(activity, requiredPermission)) {\n                                showRationaleDialog = true // Show explanation dialog\n                            } else {\n                                // Request permission directly (first time or rationale not needed)\n                                permissionLauncher.launch(requiredPermission)\n                            }\n                        } else {\n                             // Should not happen if requiredPermission is null and hasPermission is true\n                            viewModel.logError(\"LobbyScreen: Inconsistent permission state.\")\n                        }\n                    },\n                    enabled = playerName.isNotBlank(), // Enable only if name entered\n                    colors = ButtonDefaults.buttonColors(\n                        // Highlight selected role, otherwise use default secondary\n                        containerColor = if (selectedRole == role) MaterialTheme.colorScheme.primary\n                                         else MaterialTheme.colorScheme.secondaryContainer\n                    )\n                ) { Text(if(role == \"Joiner\") \"Randi\" else \"Host\") } // Using \"Randi\" for Joiner button\n            }\n        }\n\n        // Rationale Dialog (Explain why permission is needed)\n        if (showRationaleDialog && requiredPermission != null) {\n            AlertDialog(\n                onDismissRequest = { showRationaleDialog = false },\n                title = { Text(\"Permission Needed\") },\n                text = { Text(\"Finding and hosting games on the local network requires the Location permission on this version of Android to access network information.\") },\n                confirmButton = {\n                    Button(onClick = {\n                        permissionLauncher.launch(requiredPermission) // Request after showing rationale\n                        showRationaleDialog = false\n                    }) { Text(\"Grant Permission\") }\n                },\n                dismissButton = { Button(onClick = { showRationaleDialog = false }) { Text(\"Cancel\") } }\n            )\n        }\n        // Settings Guidance Dialog (If permission permanently denied)\n        if (showSettingsGuidance) {\n            AlertDialog(\n                onDismissRequest = { showSettingsGuidance = false },\n                title = { Text(\"Permission Required\") },\n                text = { Text(\"Network permission was denied. Please grant Location permission manually in App Settings to host or join games.\") },\n                confirmButton = {\n                    Button(onClick = {\n                        // Intent to open app-specific settings screen\n                        val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)\n                        val uri = Uri.fromParts(\"package\", context.packageName, null)\n                        intent.data = uri\n                        context.startActivity(intent)\n                        showSettingsGuidance = false\n                    }) { Text(\"Open Settings\") }\n                },\n                dismissButton = { Button(onClick = { showSettingsGuidance = false }) { Text(\"Cancel\") } }            )\n        }\n\n        // --- Conditional UI based on Selected Role and Permissions ---\n        // Only show Host/Joiner section if role selected AND permission granted\n        if (selectedRole != null && hasPermission) {\n            when (selectedRole) {\n                \"Host\" -> HostSection(navController, viewModel, playerName)\n                \"Joiner\" -> JoinerSection(navController, viewModel, playerName)\n            }\n        } else if (selectedRole != null && !hasPermission) {\n            // Show message if role selected but permission denied/pending\n            Text(\n                \"Please grant the required Location permission to continue as $selectedRole.\",\n                color = MaterialTheme.colorScheme.error,\n                style = MaterialTheme.typography.bodySmall,\n                textAlign = TextAlign.Center,\n                modifier = Modifier.padding(top = 16.dp)\n            )\n        }\n\n    } // End Main Column\n}\n\n\n// --- HostSection Composable ---\n@Composable\nfun HostSection(navController: NavController, viewModel: GameViewModel, hostPlayerName: String) {\n    // This section appears when \"Host\" is selected and permissions are granted.\n    // It allows configuring the game.\n\n    // Game Config state (remembered within this section's scope)\n    var numberOfPlayers by remember { mutableStateOf(4) }\n    var gameMode by remember { mutableStateOf(GameMode.CHOOSE_WHEN_EMPTY) } // Default game mode\n\n    Card(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(top = 16.dp),\n        shape = RoundedCornerShape(16.dp),\n        border = BorderStroke(1.dp, MaterialTheme.colorScheme.outline),\n        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)\n    ) {\n        Column(\n            modifier = Modifier\n                .fillMaxWidth()\n                .padding(20.dp),\n            horizontalAlignment = Alignment.CenterHorizontally,\n            verticalArrangement = Arrangement.spacedBy(16.dp)\n        ) {\n            Text(text = \"Host Game Configuration\", style = MaterialTheme.typography.titleLarge)\n            Divider()\n\n            // Player Count Selection\n            ConfigOptionRow(label = \"Number of Players:\") {\n                listOf(2,4, 6).forEach { count ->\n                    ConfigButton(\n                        text = \"$count Players\",\n                        isSelected = numberOfPlayers == count,\n                        onClick = { numberOfPlayers = count }\n                    )\n                }\n            }\n\n            // Game Mode Selection\n            ConfigOptionRow(label = \"Game Mode:\") {\n                GameMode.values().forEach { mode ->\n                    ConfigButton(\n                        text = mode.displayName(), // Use helper for display name\n                        isSelected = gameMode == mode,\n                        onClick = { gameMode = mode }\n                    )\n                }\n            }\n\n            Divider()\n\n            // Button to Create Game\n            Button(\n                onClick = {\n                    // 1. Initialize ViewModel state with chosen settings\n                    viewModel.initializeGameSettings(\n                        playerName = hostPlayerName,\n                        mode = gameMode,\n                        host = true, // Explicitly set as host\n                        playersNeeded = numberOfPlayers\n                    )\n                    // 2. Start the server and NSD advertising (ViewModel handles this)\n                    viewModel.startServerAndDiscovery() // Use host extension method\n                    // 3. Navigate to the host waiting screen\n                    navController.navigate(\"game_host\")\n                },\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .padding(top = 8.dp)\n            ) { Text(\"Create Game & Wait for Players\") }\n        }\n    }\n}\n\n// --- JoinerSection Composable ---\n@Composable\nfun JoinerSection(\n    navController: NavController,\n    viewModel: GameViewModel,\n    joinerPlayerName: String\n) {\n    // This section appears when \"Joiner\" is selected and permissions are granted.\n    // It handles discovering and joining games.\n    val discoveredGames by viewModel.discoveredHosts.collectAsState()\n    val context = LocalContext.current\n    var isConnecting by remember { mutableStateOf(false) } // Track connection attempt\n\n    // Start NSD discovery when this section becomes visible\n    // Stop discovery when it leaves composition\n    DisposableEffect(Unit) {\n         println(\"[UI - JoinerSection] Starting NSD discovery.\")\n        viewModel.startNsdDiscovery() // Use NSD extension method\n        onDispose {\n             println(\"[UI - JoinerSection] Stopping NSD discovery.\")\n            viewModel.stopNsdDiscovery() // Use NSD extension method\n             isConnecting = false // Reset connecting state on dispose\n        }\n    }\n\n    // Navigate to waiting screen on successful connection attempt initiation\n    // Note: Actual connection success is handled by ViewModel state changes\n    LaunchedEffect(viewModel.isConnectedToServer) {\n        if (viewModel.isConnectedToServer) {\n             println(\"[UI - JoinerSection] isConnectedToServer = true, navigating to waiting_for_players\")\n             if (navController.currentDestination?.route != \"waiting_for_players\") {\n                  navController.navigate(\"waiting_for_players\")\n             }\n             isConnecting = false // Reset connecting flag\n        } else {\n             // If connection failed after attempting, reset flag\n             if (isConnecting) { // Only reset if we were the ones trying\n                  isConnecting = false\n             }\n        }\n    }\n    // Handle errors shown by ViewModel (e.g., connection failed)\n    LaunchedEffect(viewModel.showError) {\n         viewModel.showError.collect {\n              // If an error occurs during connection attempt, reset the flag\n              isConnecting = false\n         }\n    }\n\n\n    Column(\n        verticalArrangement = Arrangement.spacedBy(16.dp),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = Modifier.fillMaxWidth()\n    ) {\n        Text(\"Join a Game\", style = MaterialTheme.typography.titleMedium)\n\n        Button(\n            onClick = {\n                viewModel.startNsdDiscovery() // Restart discovery (stops previous first)\n                Toast.makeText(context, \"Refreshing game list...\", Toast.LENGTH_SHORT).show()\n            },\n            enabled = !isConnecting // Disable refresh while connecting\n        ) { Text(\"Refresh Game List\") }\n\n        Spacer(modifier = Modifier.height(8.dp))\n\n        // Game List Area\n        Box(modifier = Modifier.heightIn(min = 100.dp, max = 250.dp)) {\n            if (discoveredGames.isEmpty() && !isConnecting) { // Show loading only if not empty and not connecting\n                Column(\n                    modifier = Modifier.fillMaxSize(), // Fill the box\n                    horizontalAlignment = Alignment.CenterHorizontally,\n                    verticalArrangement = Arrangement.Center\n                ) {\n                    CircularProgressIndicator(modifier = Modifier.size(30.dp))\n                    Text(\n                        \"Searching for games on network...\",\n                        style = MaterialTheme.typography.bodyMedium,\n                        modifier = Modifier.padding(top = 8.dp),\n                        textAlign = TextAlign.Center\n                    )\n                }\n            } else if (isConnecting) {\n                 Column(\n                    modifier = Modifier.fillMaxSize(), // Fill the box\n                    horizontalAlignment = Alignment.CenterHorizontally,\n                    verticalArrangement = Arrangement.Center\n                 ) {\n                    CircularProgressIndicator(modifier = Modifier.size(30.dp))\n                    Text(\n                        \"Connecting...\",\n                        style = MaterialTheme.typography.bodyMedium,\n                        modifier = Modifier.padding(top = 8.dp),\n                        textAlign = TextAlign.Center\n                    )\n                 }\n            } else { // Show discovered games\n                LazyColumn(modifier = Modifier.fillMaxWidth()) {\n                    item { // Header item\n                        Text(\n                            \"Available Games:\",\n                            style = MaterialTheme.typography.titleSmall,\n                            modifier = Modifier.padding(bottom = 8.dp)\n                        )\n                    }\n                    items(discoveredGames, key = { it.serviceName }) { serviceInfo ->\n                        // Use Button for each game, disable if connection in progress\n                        Button(\n                            onClick = {\n                                @Suppress(\"DEPRECATION\") // Suppress for serviceInfo.host if needed\n                                if (serviceInfo.host == null || serviceInfo.port <= 0) {\n                                    Toast.makeText(context, \"Game details not ready yet. Refreshing...\", Toast.LENGTH_SHORT).show()\n                                     viewModel.startNsdDiscovery() // Trigger refresh automatically\n                                } else {\n                                    isConnecting = true // Set connecting flag\n                                    Toast.makeText(context, \"Connecting to ${serviceInfo.serviceName}...\", Toast.LENGTH_SHORT).show()\n                                    // Call VM connect method using client extension\n                                    viewModel.connectToDiscoveredHost(serviceInfo, joinerPlayerName)\n                                    // Navigation handled by LaunchedEffect on isConnectedToServer\n                                }\n                            },\n                            enabled = !isConnecting, // Disable button while connecting\n                            modifier = Modifier\n                                .fillMaxWidth()\n                                .padding(vertical = 4.dp)\n                        ) {\n                            @Suppress(\"DEPRECATION\") // Suppress for serviceInfo.host if needed\n                            val hostIpDisplay = serviceInfo.host?.hostAddress ?: \"resolving...\"\n                            Text(\"${serviceInfo.serviceName} ($hostIpDisplay)\")\n                        }\n                    }\n                }\n            }\n        } // End Box for game list / loading indicator\n    } // End Column for Joiner section\n}\n\n\n// --- Helper Composables ---\n\n// Helper for configuration rows (Label + Buttons)\n@Composable\nprivate fun ConfigOptionRow(label: String, content: @Composable RowScope.() -> Unit) {\n    Column(\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.spacedBy(8.dp),\n        modifier = Modifier.fillMaxWidth() // Allow row to take width\n    ) {\n        Text(label, style = MaterialTheme.typography.titleMedium)\n        Row(\n            horizontalArrangement = Arrangement.spacedBy(12.dp, Alignment.CenterHorizontally), // Center buttons\n            verticalAlignment = Alignment.CenterVertically,\n            modifier = Modifier\n                .padding(top = 4.dp)\n                .fillMaxWidth() // Ensure row takes width for centering\n        ) { content() } // Place the provided buttons here\n    }\n}\n\n// Helper for configuration buttons (Selected/Unselected state)\n@Composable\nprivate fun ConfigButton(text: String, isSelected: Boolean, onClick: () -> Unit) {\n    Button(\n        onClick = onClick,\n        colors = ButtonDefaults.buttonColors(\n            containerColor = if (isSelected) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.secondaryContainer,\n            contentColor = if (isSelected) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSecondaryContainer\n        ),\n        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp) // Adjust padding\n    ) {\n        Text(text, textAlign = TextAlign.Center)\n    }\n}\n\n// Helper to get display name for GameMode enum\nprivate fun GameMode.displayName(): String = when (this) {\n    GameMode.CHOOSE_WHEN_EMPTY -> \"Choose When Empty\"\n    GameMode.FIRST_CARD_HIDDEN -> \"First Card Hidden\"\n}",
                "ResultScreen.kt": "package com.example.mindikot.ui.screens\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.unit.dp\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.navigation.NavHostController\nimport com.example.mindikot.core.engine.RoundEvaluator\n// Corrected ViewModel and Factory imports\nimport com.example.mindikot.ui.viewmodel.GameViewModel\nimport com.example.mindikot.ui.viewmodel.factory.GameViewModelFactory\n\n@Composable\nfun ResultScreen(\n    navController: NavHostController,\n    // Use the factory to get the ViewModel instance\n    viewModel: GameViewModel = viewModel(\n        factory = GameViewModelFactory(LocalContext.current.applicationContext)\n    )\n) {\n    // Observe the last known game state from the ViewModel\n    val gameState by viewModel.state.collectAsState()\n\n    // Calculate the round result based on the observed state\n    // This recalculates if gameState changes, which shouldn't happen much on this screen\n    // but ensures it uses the final state provided by the VM before navigation.\n    val roundResult = remember(gameState) {\n        // Ensure we have valid player/team data before evaluating\n        if (gameState.players.isNotEmpty() && gameState.teams.isNotEmpty()) {\n            RoundEvaluator.evaluateRound(gameState)\n        } else {\n            // Return a default/error result if state is invalid\n            RoundEvaluator.RoundResult(null, false) // Default to Draw if state is bad\n        }\n    }\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(24.dp),\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        // Display Winner or Draw message\n        Text(\n            text = roundResult.winningTeam?.let { \"Team ${it.id} Wins!\" } ?: \"Round is a Draw!\",\n            style = MaterialTheme.typography.headlineLarge\n        )\n        Spacer(modifier = Modifier.height(16.dp))\n\n        // Display Kot status or score info\n        if (roundResult.winningTeam != null) {\n            Text(\n                text = if (roundResult.isKot) \"KOT! All four 10s collected!\" else \"Regular Win\",\n                style = MaterialTheme.typography.bodyLarge\n            )\n            // TODO: Display actual scores if tracked in ViewModel/GameState\n            // Text(\"Team ${roundResult.winningTeam.id} score: X\")\n        } else {\n            Text(text = \"Scores remain unchanged.\", style = MaterialTheme.typography.bodyLarge)\n        }\n\n        Spacer(modifier = Modifier.height(32.dp))\n\n        // Button to go back to the Lobby\n        Button(\n            onClick = {\n                // No need to explicitly stop server/client here.\n                // LobbyScreen's DisposableEffect should handle cleanup when navigating back.\n                 println(\"[UI - ResultScreen] Navigating back to lobby.\")\n                navController.navigate(\"lobby\") {\n                    // Pop everything back to the lobby start destination, clearing game/result screens\n                    popUpTo(\"lobby\") { inclusive = true }\n                }\n            }\n        ) { Text(\"Back to Lobby\") }\n\n        // TODO: Add \"Play Again\" Button (Host Only)\n        // if (viewModel.isHost) {\n        //     Button(onClick = { /* Host triggers state reset & deal */ }) { Text(\"Play Again\") }\n        // }\n    }\n}",
                "WaitingForPlayersScreen.kt": "package com.example.mindikot.ui.screens\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport android.widget.Toast\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.unit.dp\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.navigation.NavController\n// Corrected ViewModel and Factory imports\nimport com.example.mindikot.ui.viewmodel.GameViewModel\nimport com.example.mindikot.ui.viewmodel.factory.GameViewModelFactory\nimport kotlinx.coroutines.flow.collectLatest\nimport com.example.mindikot.ui.viewmodel.disconnectFromServer // From GameViewModelClient.kt\n\n\n@Composable\nfun WaitingForPlayersScreen(\n    navController: NavController,\n    // Use the factory to get the ViewModel instance\n    viewModel: GameViewModel = viewModel(\n        factory = GameViewModelFactory(LocalContext.current.applicationContext)\n    )\n) {\n    val gameState by viewModel.state.collectAsState()\n    // Use the dedicated count StateFlow\n    val connectedCount by viewModel.connectedPlayersCount.collectAsState()\n    val isHost = viewModel.isHost // Should be false for this screen (Joiner uses this)\n    // Get the definitive required count (might come from initial GameState update)\n    val requiredPlayers = viewModel.requiredPlayerCount // Relies on host having set this correctly\n    val gameStarted by viewModel.gameStarted.collectAsState()\n    val localPlayerId = viewModel.localPlayerId // Access directly\n\n    val context = LocalContext.current\n\n    // Log state changes for debugging UI\n    // LaunchedEffect(connectedCount, gameState.players, localPlayerId, requiredPlayers) {\n    //     println(\"[UI - WaitingScreen] connectedCount = $connectedCount, required = $requiredPlayers\")\n    //     println(\"[UI - WaitingScreen] Player List State: ${gameState.players.map { p -> Pair(p.id, p.name) }}\")\n    //     println(\"[UI - WaitingScreen] Local Player ID = $localPlayerId\")\n    // }\n\n    // Joiner: Navigate to game screen when game starts\n    LaunchedEffect(gameStarted, isHost) {\n        // Ensure this is a client and the game has started\n        if (!isHost && gameStarted) {\n             println(\"[UI - WaitingScreen] Game started signal received. Navigating to game screen.\") // Log nav\n             // Ensure navigation happens only once\n             if (navController.currentDestination?.route != \"game\") {\n                  navController.navigate(\"game\") {\n                      // Pop this waiting screen off the back stack\n                      popUpTo(\"waiting_for_players\") { inclusive = true }\n                  }\n             }\n        }\n    }\n\n    // Joiner: Monitor connection status and navigate back if disconnected\n    LaunchedEffect(viewModel.isConnectedToServer) {\n        // If the connection state becomes false *after* being on this screen\n        if (!viewModel.isConnectedToServer && navController.currentDestination?.route == \"waiting_for_players\") {\n             println(\"[UI - WaitingScreen] isConnectedToServer became false. Navigating to lobby.\") // Log nav\n             Toast.makeText(context, \"Disconnected from host.\", Toast.LENGTH_LONG).show()\n             // No need to call disconnectFromServer here, it should have been called by the listener ending\n             navController.navigate(\"lobby\") {\n                 popUpTo(\"lobby\") { inclusive = true } // Go back to start\n             }\n        }\n    }\n     // Also listen for specific errors that indicate disconnection\n     LaunchedEffect(viewModel.showError) {\n         viewModel.showError.collectLatest { errorMsg ->\n             if (errorMsg.contains(\"Kicked\", ignoreCase = true) || errorMsg.contains(\"Disconnected\", ignoreCase = true)) {\n                  if (navController.currentDestination?.route == \"waiting_for_players\") {\n                       navController.navigate(\"lobby\") {\n                            popUpTo(\"lobby\") { inclusive = true }\n                       }\n                  }\n             }\n         }\n     }\n\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(24.dp),\n        verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\"Waiting for Players...\", style = MaterialTheme.typography.headlineMedium)\n        CircularProgressIndicator()\n\n        // Use connectedCount and potentially requiredPlayers from GameState if available\n        val displayRequired = gameState.players.size.takeIf { it > 0 } ?: requiredPlayers\n        if (displayRequired > 0) { // Display only if requiredPlayers is initialized or derived\n            Text(\"Connected Players: $connectedCount / $displayRequired\")\n        }\n\n        Spacer(modifier = Modifier.height(16.dp))\n\n        Text(\"Players in Lobby:\", style = MaterialTheme.typography.titleMedium)\n        // Display players from the received gameState\n        Column(\n             modifier = Modifier.padding(start = 16.dp).fillMaxWidth(), // Allow text to wrap\n             horizontalAlignment = Alignment.CenterHorizontally, // Center text lines\n             verticalArrangement = Arrangement.spacedBy(4.dp)\n         ) {\n            if (gameState.players.isNotEmpty()) {\n                gameState.players.forEach { player ->\n                    // Determine player status/role for display\n                    val suffix = when {\n                        player.id == localPlayerId -> \" (You)\"\n                        player.id == 0 -> \" (Host)\" // Client sees player 0 as Host\n                        else -> \"\"\n                    }\n                     val playerDisplayName = player.name.takeIf { it != \"Waiting...\" } ?: \"Connecting...\"\n                     val displayColor = if (player.name == \"[Disconnected]\" || player.name.contains(\"[LEFT]\")) Color.Gray else LocalContentColor.current\n\n                    Text(\n                        text = \"- $playerDisplayName$suffix\",\n                        style = MaterialTheme.typography.bodyLarge,\n                        color = displayColor\n                    )\n                }\n            } else {\n                Text(\"Waiting for lobby details...\")\n            }\n        }\n\n        Spacer(modifier = Modifier.height(32.dp))\n\n        // Client only has Leave button here\n        if (!isHost) {\n             Text(\"Waiting for the host to start the game...\")\n             Button(\n                 onClick = {\n                     // Call ViewModel's disconnect function using client extension\n                     viewModel.disconnectFromServer()\n                     // Navigate back to lobby\n                     navController.navigate(\"lobby\") {\n                         popUpTo(\"lobby\") { inclusive = true } // Go back to start, clear stack\n                     }\n                 },\n                 colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.secondary)\n             ) {\n                 Text(\"Leave Lobby\")\n             }\n        }\n    }\n}"
            },
            "theme": {
                "Color.kt": "package com.example.mindikot.ui.theme\n\nimport androidx.compose.ui.graphics.Color\n\nval Purple80 = Color(0xFFD0BCFF)\nval PurpleGrey80 = Color(0xFFCCC2DC)\nval Pink80 = Color(0xFFEFB8C8)\n\nval Purple40 = Color(0xFF6650a4)\nval PurpleGrey40 = Color(0xFF625b71)\nval Pink40 = Color(0xFF7D5260)\n",
                "Theme.kt": "package com.example.mindikot.ui.theme\n\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.platform.LocalContext\n\nprivate val LightColors = lightColorScheme(\n    primary = Purple40,\n    secondary = PurpleGrey40,\n    tertiary = Pink40\n)\n\n@Composable\nfun MindikotTheme(\n    useDarkTheme: Boolean = isSystemInDarkTheme(),\n    content: @Composable () -> Unit\n) {\n    MaterialTheme(\n        colorScheme = LightColors,\n        typography = Typography(),\n        content = content\n    )\n}\n"
            },
            "viewmodel": {
                "factory": {
                    "GameViewModelFactory.kt": "package com.example.mindikot.ui.viewmodel.factory\n\nimport android.content.Context\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.ViewModelProvider\nimport com.example.mindikot.ui.viewmodel.GameViewModel // Ensure this points to the correct ViewModel location\n\nclass GameViewModelFactory(private val context: Context) : ViewModelProvider.Factory {\n    override fun <T : ViewModel> create(modelClass: Class<T>): T {\n        if (modelClass.isAssignableFrom(GameViewModel::class.java)) {\n            @Suppress(\"UNCHECKED_CAST\")\n            return GameViewModel(context.applicationContext) as T\n        }\n        throw IllegalArgumentException(\"Unknown ViewModel class: ${modelClass.name}\")\n    }\n}"
                },
                "GameViewModel.kt": "package com.example.mindikot.ui.viewmodel\n\nimport android.content.Context\nimport android.net.nsd.NsdManager\nimport android.net.nsd.NsdServiceInfo\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.mindikot.core.engine.GameEngine\nimport com.example.mindikot.core.engine.RoundEvaluator\nimport com.example.mindikot.core.model.*\nimport com.example.mindikot.core.state.GameState\nimport com.example.mindikot.core.state.InputType\nimport com.example.mindikot.ui.viewmodel.network.NetworkMessage // Correct import\nimport com.example.mindikot.ui.viewmodel.network.MessageType // Correct import\nimport com.example.mindikot.ui.viewmodel.utils.log // Import utils\nimport com.example.mindikot.ui.viewmodel.utils.logError\nimport com.google.gson.Gson\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport java.io.BufferedReader\nimport java.io.PrintWriter\nimport java.net.ServerSocket\nimport java.net.Socket\nimport java.util.concurrent.ConcurrentHashMap\n\n// Add required permissions to AndroidManifest.xml (Keep comments here for visibility)\n// <uses-permission android:name=\"android.permission.INTERNET\" />\n// <uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n// <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n// <uses-permission android:name=\"android.permission.CHANGE_WIFI_MULTICAST_STATE\" />\n// For Android 12+ (API 31+) NSD requires location permission:\n// <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n// Or for just discovery:\n// <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\"/>\n\n\n// Main ViewModel class - Holds state and delegates network operations\nclass GameViewModel(\n    // Make internal for access by extensions within the same module\n    internal val applicationContext: Context\n) : ViewModel() {\n\n    // --- Game State ---\n    // Use internal setter for modification by extensions if needed, but prefer methods\n    val _state = MutableStateFlow(createInitialEmptyGameState())\n    val state: StateFlow<GameState> = _state.asStateFlow()\n\n    // --- Navigation/Events ---\n    // Use internal SharedFlow for emitting events from extensions/methods\n    internal val _navigateToResultScreen = MutableSharedFlow<RoundEvaluator.RoundResult>(replay = 0, extraBufferCapacity = 1)\n    val navigateToResultScreen: SharedFlow<RoundEvaluator.RoundResult> = _navigateToResultScreen.asSharedFlow()\n\n    internal val _showError = MutableSharedFlow<String>(replay = 0, extraBufferCapacity = 5) // Buffer for multiple errors\n    val showError: SharedFlow<String> = _showError.asSharedFlow()\n\n    // --- Game/Network Setup ---\n    var isHost: Boolean = false\n         // Only ViewModel internals can set this\n    var requiredPlayerCount: Int = 4\n        private set\n    var localPlayerId: Int = -1 // -1 indicates not assigned yet\n        private set // Make private, use internal setter method\n\n    // Internal setter for localPlayerId\n    internal fun setLocalPlayerIdInternal(id: Int) {\n        localPlayerId = id\n    }\n\n    // Use internal StateFlow for modification by extensions/methods\n    internal val _connectedPlayersCount = MutableStateFlow(1) // Includes host if hosting\n    val connectedPlayersCount: StateFlow<Int> = _connectedPlayersCount.asStateFlow()\n\n    internal val _gameStarted = MutableStateFlow(false)\n    val gameStarted: StateFlow<Boolean> = _gameStarted.asStateFlow()\n\n    // Internal setter for gameStarted\n    internal fun setGameStartedInternal(started: Boolean) {\n        _gameStarted.value = started\n    }\n\n\n    // --- Networking (Host - Properties managed here, logic in extensions) ---\n    internal var serverSocket: ServerSocket? = null\n    internal var servicePort: Int = 0\n        private set\n    // Internal setter for servicePort used by Host extension\n    internal fun setServicePortInternal(port: Int) {\n        servicePort = port\n    }\n\n    @Volatile // Ensure visibility across threads\n    internal var isServerRunning: Boolean = false // Tracks if server *should* be running\n    internal val clientSockets = ConcurrentHashMap<Int, Socket>() // PlayerId -> Socket\n    internal val clientWriters = ConcurrentHashMap<Int, PrintWriter>() // PlayerId -> Writer\n    internal val clientReaders = ConcurrentHashMap<Int, BufferedReader>() // PlayerId -> Reader\n    internal val clientJobs = ConcurrentHashMap<Int, Job>() // PlayerId -> Listener Job\n\n    // --- Networking (Client - Properties managed here, logic in extensions) ---\n    internal var clientSocket: Socket? = null\n    internal var clientWriter: PrintWriter? = null\n    internal var clientReader: BufferedReader? = null\n    internal var clientReaderJob: Job? = null\n    @Volatile // Ensure visibility across threads\n    internal var isConnectedToServer: Boolean = false\n        // Allow extensions to set via internal setter\n        internal set\n\n\n    // --- NSD (Properties managed here, logic in extensions) ---\n    internal var nsdManager: NsdManager? = null\n    internal var registrationListener: NsdManager.RegistrationListener? = null // Host only\n    internal var discoveryListener: NsdManager.DiscoveryListener? = null // Client only\n    internal var nsdServiceNameRegistered: String? = null // Host only\n        private set\n    // Internal setter for NSD service name\n    internal fun setNsdServiceNameRegisteredInternal(name: String?) {\n        nsdServiceNameRegistered = name\n    }\n\n\n    // Use internal StateFlow for modification by extensions/methods\n    internal val _discoveredHosts = MutableStateFlow<List<NsdServiceInfo>>(emptyList()) // Client only\n    val discoveredHosts: StateFlow<List<NsdServiceInfo>> = _discoveredHosts.asStateFlow()\n    internal val _hostIpAddress = MutableStateFlow<String?>(null) // Host display / Client connection info\n    val hostIpAddress: StateFlow<String?> = _hostIpAddress.asStateFlow()\n    internal val resolvingServices = ConcurrentHashMap<String, Boolean>() // Client: Track services being resolved\n\n    // --- Serialization ---\n    internal val gson = Gson() // Internal for use by extensions\n\n    // ========================================================================    // INITIALIZATION & SETUP\n    // ========================================================================\n    /** Initializes game settings (player slots, mode) - Called by UI before starting host/client */\n    fun initializeGameSettings(\n        playerName: String,\n        mode: GameMode,\n        host: Boolean = true,\n        playersNeeded: Int = 4\n    ) {\n        log(\"Initializing game settings. Host: $host, Name: $playerName, Mode: $mode, Players: $playersNeeded\")\n        isHost = host\n        requiredPlayerCount = playersNeeded\n        localPlayerId = if (host) 0 else -1 // Host is always 0, client waits for assignment\n\n        // Create initial player list (placeholders for others)\n        val players = (0 until playersNeeded).map { i ->\n            Player(\n                id = i,\n                name = if (i == localPlayerId) playerName else \"Waiting...\", // Set local player name\n                teamId = (i % 2) + 1, // Simple team assignment (1, 2, 1, 2...)\n                hand = mutableListOf()\n            )\n        }\n        val teams = listOf(\n            Team(id = 1, players = players.filter { it.teamId == 1 }),\n            Team(id = 2, players = players.filter { it.teamId == 2 })\n        )\n\n        // Reset relevant state fields\n        _state.value = GameState(\n            players = players,\n            teams = teams,\n            gameMode = mode,\n            tricksWon = mutableMapOf(1 to 0, 2 to 0), // Initialize trick counts\n            currentLeaderIndex = 0,\n            trumpSuit = null,\n            trumpRevealed = false,\n            hiddenCard = null,\n            currentTrickPlays = mutableListOf(),\n            awaitingInputFromPlayerIndex = null,\n            requiredInputType = null\n        )\n        _connectedPlayersCount.value = if (host) 1 else 0 // Host counts as 1 initially\n        _gameStarted.value = false // Reset game started flag\n        log(\"Initial GameState created for setup. isHost=$isHost, localPlayerId=$localPlayerId\")\n\n         // If hosting, broadcast the initial lobby state immediately\n         // Although no clients are connected yet, this sets the host's view\n         // Moved this logic inside startServerAndDiscovery to send state upon client connection\n         // if (isHost) { broadcastGameState(_state.value) }\n\n         if (!isHost) {\n            // If joining, clear any previously discovered hosts\n            _discoveredHosts.value = emptyList()\n         }\n    }\n\n    /** HOST: Updates player name in the authoritative state and broadcasts the change (Runs on Main Thread) */\n    internal fun updatePlayerName(playerId: Int, name: String) {\n        if (!isHost) return // Only host updates names authoritatively\n         if (name.isBlank()) {\n             logError(\"Attempted to update Player $playerId name to blank. Ignoring.\")\n             return\n         }\n\n        log(\"Host: Updating Player $playerId name to '$name'\")\n        var nameChanged = false\n        _state.update { currentState ->\n            val playerIndex = currentState.players.indexOfFirst { it.id == playerId }\n            if (playerIndex != -1) {\n                 val currentName = currentState.players[playerIndex].name\n                // Update only if different and not placeholder/disconnect messages\n                if (currentName != name && currentName != \"[Disconnected]\" && !currentName.contains(\"[LEFT]\")) {\n                    nameChanged = true\n                    val updatedPlayers = currentState.players.toMutableList()\n                    updatedPlayers[playerIndex] = updatedPlayers[playerIndex].copy(name = name)\n                    currentState.copy(players = updatedPlayers)\n                } else {\n                    currentState // No change needed\n                }\n            } else {\n                 logError(\"Host: Cannot update name, Player $playerId not found in current state.\")\n                 currentState // Player not found\n            }\n\n        }\n        if (nameChanged) {\n            // Broadcast the updated state to all clients\n            broadcastGameState(_state.value) // Use host extension method\n        }\n    }\n\n\n    // ========================================================================    // GAME LOGIC PROCESSING (HOST ONLY)\n    // ========================================================================\n    /** HOST ONLY: Processes validated player input using the GameEngine and broadcasts the result */\n    internal fun processGameInput(actingPlayerId: Int, playerInput: Any) {\n        if (!isHost) {\n            logError(\"processGameInput called on client device. Ignoring.\")\n            return\n        }\n\n        // Ensure processing happens on the main thread for state safety\n        viewModelScope.launch(Dispatchers.Main.immediate) {\n            val currentState = _state.value // Get current state\n\n            // --- Pre-condition Checks ---\n            if (currentState.awaitingInputFromPlayerIndex != actingPlayerId) {\n                logError(\"Input received from Player $actingPlayerId, but expected input from ${currentState.awaitingInputFromPlayerIndex}. Ignoring.\")\n                sendMessageToClient(actingPlayerId, NetworkMessage(MessageType.ERROR, \"Not your turn\"))\n                return@launch\n            }\n            if (currentState.requiredInputType == null) {\n                logError(\"Input received from Player $actingPlayerId, but no input type was required. Ignoring.\")\n                return@launch\n            }\n\n            log(\"Host: Processing input from Player $actingPlayerId ($playerInput), required: ${currentState.requiredInputType}\")\n\n            // --- Process with GameEngine ---\n            var errorOccurred = false\n            try {\n                // Core game logic update - MUTATES currentState directly\n                GameEngine.processPlayerInput(currentState, playerInput)\n                // If GameEngine throws an exception (e.g., invalid move), catch it below.\n\n            } catch (e: IllegalStateException) {\n                logError(\"Host: Invalid move or state error processing input for Player $actingPlayerId: ${e.message}\", e)\n                sendMessageToClient(actingPlayerId, NetworkMessage(MessageType.ERROR, \"Invalid Move: ${e.message}\"))\n                // State might be partially modified, try to reset the input request for the same player\n                // Ensure requestInput also results in a new state object if it mutates, or returns one.\n                // Assuming requestInput returns a new state or doesn't mutate negatively here.\n                _state.value = GameEngine.requestInput(currentState, actingPlayerId) // Assign potentially new state from requestInput\n                errorOccurred = true\n                // Broadcast the state requiring re-input\n                broadcastGameState(_state.value)\n                return@launch // Stop further processing after error\n            } catch (e: Exception) {\n                logError(\"Host: Unexpected error processing game input for Player $actingPlayerId\", e)\n                sendMessageToClient(actingPlayerId, NetworkMessage(MessageType.ERROR, \"Internal server error during your turn.\"))\n                // Attempt to re-request input\n                _state.value = GameEngine.requestInput(currentState, actingPlayerId)\n                errorOccurred = true\n                // Broadcast the state requiring re-input\n                broadcastGameState(_state.value)\n                return@launch // Stop further processing after error\n            }\n\n            // --- Post-Processing State Update ---\n            // **** FIX: Create a NEW GameState object using copy() ****\n            // This ensures StateFlow detects a change even if GameEngine only mutated internal lists.\n            val newState = currentState.copy()\n            _state.value = newState // Assign the *new* copied instance to the StateFlow\n\n            // --- Check for Round End ---\n            // Use the newState for checks and broadcasting\n            val roundEnded = newState.players.firstOrNull()?.hand?.isEmpty() == true && newState.currentTrickPlays.isEmpty()\n\n            if (roundEnded) {\n                log(\"Host: Round Ended. Evaluating...\")\n                val result = RoundEvaluator.evaluateRound(newState) // Evaluate the final state\n                log(\"Host: Round Result: Winner=${result.winningTeam?.id ?: \"Draw\"}, Kot=${result.isKot}\")\n\n                // Broadcast the final state of the round *after* local state update\n                broadcastGameState(newState) // Broadcast the newState\n\n                delay(300) // Short delay\n\n                val emitted = _navigateToResultScreen.tryEmit(result)\n                log(\"Host: Emitting navigation to result screen. Success: $emitted\")\n                if (!emitted) {\n                    logError(\"Host: Failed to emit navigation event to result screen.\")\n                }\n\n            } else {\n                // Round not ended, broadcast the updated state\n                broadcastGameState(newState) // Broadcast the newState\n            }\n        }\n    }\n\n    // ========================================================================    // UI ACTION HANDLERS (Called by the UI on the specific device)\n    // ========================================================================\n    /** Called when the local player chooses a card to play */\n    fun onCardPlayed(card: Card) {\n         val localId = localPlayerId\n         if (localId == -1) {\n              viewModelScope.launch { _showError.emit(\"Cannot play: Player ID not assigned.\") }\n              return\n         }\n        log(\"UI Action: Card played: $card by Local Player $localId\")\n        val currentState = _state.value\n        val myTurn = currentState.awaitingInputFromPlayerIndex == localId\n        val expectedInput = currentState.requiredInputType\n\n        // --- Basic Input Validation ---\n        if (!myTurn) {\n            logError(\"UI Action: Card played, but not player $localId's turn.\")\n            viewModelScope.launch { _showError.emit(\"Not your turn!\") }\n            return\n        }\n        if (expectedInput != InputType.PLAY_CARD && expectedInput != InputType.CHOOSE_TRUMP_SUIT) {\n            logError(\"UI Action: Card played, but expected input was $expectedInput.\")\n            viewModelScope.launch { _showError.emit(\"Cannot play card now (Expected: $expectedInput).\") }\n            return\n        }\n        val localPlayer = currentState.players.find { it.id == localId }\n        if (localPlayer == null || !localPlayer.hand.contains(card)) {\n             logError(\"UI Action: Card $card not found in local player's hand: ${localPlayer?.hand}\")\n            viewModelScope.launch { _showError.emit(\"Card not in hand!\") }\n            return\n        }\n\n        // --- Client-side Valid Move Check (recommended for better UX) ---\n        // This check is done *before* sending to the server (if client) or processing (if host).\n        // The server (host) *must* re-validate regardless.\n        val validMoves = GameEngine.determineValidMoves(\n            playerHand = localPlayer.hand,\n            currentTrickPlays = currentState.currentTrickPlays,\n            trumpSuit = currentState.trumpSuit,\n            trumpRevealed = currentState.trumpRevealed\n        )\n        if (!validMoves.contains(card)) {\n            logError(\"UI Action: Invalid card $card played based on client-side check. Valid: $validMoves\")\n            viewModelScope.launch { _showError.emit(\"Invalid move (Rule violation).\") }\n            return\n        }\n\n        // --- Process or Send ---\n        if (isHost) {\n            // Host processes the input directly\n            processGameInput(localId, card)\n        } else {\n            // Client sends the action to the host using client extension method\n            sendMessageToServer(NetworkMessage(MessageType.PLAYER_ACTION, card))\n            // Client UI might optimistically show the card moving, but waits for server state update\n        }\n    }\n\n    /** Called when the local player chooses Reveal or Pass (Mode B) */\n    fun onRevealOrPass(decision: GameEngine.Decision) {\n         val localId = localPlayerId\n         if (localId == -1) {\n              viewModelScope.launch { _showError.emit(\"Cannot act: Player ID not assigned.\") }\n              return\n         }\n        log(\"UI Action: Reveal/Pass decision: $decision by Local Player $localId\")\n        val currentState = _state.value\n\n        // --- Basic Input Validation ---\n        if (currentState.awaitingInputFromPlayerIndex != localId) {\n            logError(\"UI Action: Reveal/Pass action, but not player $localId's turn.\")\n            viewModelScope.launch { _showError.emit(\"Not your turn!\") }\n            return\n        }\n        if (currentState.requiredInputType != InputType.REVEAL_OR_PASS) {\n            logError(\"UI Action: Reveal/Pass action, but expected input was ${currentState.requiredInputType}.\")\n            viewModelScope.launch { _showError.emit(\"Cannot Reveal or Pass now (Expected: ${currentState.requiredInputType}).\") }\n            return\n        }\n         if (currentState.gameMode != GameMode.FIRST_CARD_HIDDEN) {\n              logError(\"UI Action: Reveal/Pass action, but game mode is ${currentState.gameMode}.\")\n             viewModelScope.launch { _showError.emit(\"Reveal/Pass is only available in FIRST_CARD_HIDDEN mode.\") }\n             return\n         }\n\n\n        // --- Process or Send ---\n        if (isHost) {\n            // Host processes the input directly\n            processGameInput(localId, decision)\n        } else {\n            // Client sends the action to the host using client extension method\n            sendMessageToServer(NetworkMessage(MessageType.PLAYER_ACTION, decision))\n            // Client waits for server state update (which will then require PLAY_CARD)\n        }\n    }\n\n    // ========================================================================    // UTILITY & LIFECYCLE\n    // ========================================================================\n    /** Creates an empty initial game state */\n    internal fun createInitialEmptyGameState(): GameState {\n        return GameState(\n            players = emptyList(),\n            teams = emptyList(),\n            gameMode = GameMode.CHOOSE_WHEN_EMPTY, // Default mode\n            currentLeaderIndex = 0,\n            trumpSuit = null,\n            trumpRevealed = false,\n            hiddenCard = null,\n            currentTrickPlays = mutableListOf(),\n            awaitingInputFromPlayerIndex = null,\n            requiredInputType = null,\n            tricksWon = mutableMapOf()\n        )\n    }\n\n    /** Called when ViewModel is cleared - ensures network cleanup */\n    override fun onCleared() {\n        log(\"GameViewModel Cleared. Cleaning up resources...\")\n        if (isHost) {\n            // Stop hosting operations (server, NSD registration, client connections)\n            stopServerAndDiscovery() // Use host extension method\n        } else {\n            // Stop client operations (discovery, connection to server)\n            stopNsdDiscovery() // Use NSD extension method\n            disconnectFromServer() // Use client extension method\n        }\n        // Cancel any other ongoing coroutines within the viewModelScope\n        // viewModelScope.cancel() // This happens automatically when ViewModel is cleared\n        super.onCleared()\n        log(\"GameViewModel Cleanup Complete.\")\n    }\n}",
                "GameViewModelClient.kt": "package com.example.mindikot.ui.viewmodel\n\nimport android.net.nsd.NsdServiceInfo\nimport androidx.lifecycle.viewModelScope // Needed for viewModelScope.launch\nimport com.example.mindikot.core.state.GameState\nimport com.example.mindikot.ui.viewmodel.network.NetworkMessage\nimport com.example.mindikot.ui.viewmodel.network.MessageType\nimport com.example.mindikot.ui.viewmodel.utils.log\nimport com.example.mindikot.ui.viewmodel.utils.logError\nimport com.google.gson.JsonSyntaxException\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.collectLatest\nimport kotlinx.coroutines.flow.update\nimport java.io.BufferedReader\nimport java.io.InputStreamReader\nimport java.io.PrintWriter\nimport java.net.Socket\nimport java.net.SocketException\n\n// ========================================================================// CLIENT FUNCTIONS (Implemented as Extension Functions on GameViewModel)\n// ========================================================================\n/** CLIENT: Connects to a selected discovered host */\nfun GameViewModel.connectToDiscoveredHost(serviceInfo: NsdServiceInfo, playerName: String) {\n    @Suppress(\"DEPRECATION\") // Suppress warning for serviceInfo.host (needed for older APIs)\n    val hostAddress = serviceInfo.host?.hostAddress\n    val port = serviceInfo.port\n\n    if (hostAddress != null && port > 0) {\n        log(\"Client: Attempting connection to selected host: ${serviceInfo.serviceName} ($hostAddress:$port)\")\n        // Call the core connect function\n        connectToServer(hostAddress, port, playerName)\n    } else {\n        logError(\"Client: Cannot connect, resolved service info is invalid (missing host/port): $serviceInfo\")\n        // Use viewModelScope from the receiver (GameViewModel)\n        viewModelScope.launch { _showError.emit(\"Failed to get connection details for '${serviceInfo.serviceName}'. Please refresh.\") }\n    }\n}\n\n\n/** CLIENT: Connects to the game host using IP/Port */\nfun GameViewModel.connectToServer(hostAddress: String, port: Int, playerName: String) {\n    if (isConnectedToServer || isHost) {\n        log(\"Client: Already connected or is host. Aborting connect.\")\n        return\n    }\n    log(\"Client: Attempting connection to $hostAddress:$port...\")\n    // Ensure previous connection is fully cleaned up before starting new one\n    disconnectFromServer() // Call disconnect first\n\n    viewModelScope.launch(Dispatchers.IO) {\n        try {\n             // Small delay after disconnect before attempting new connection\n             delay(200)\n\n            clientSocket = Socket(hostAddress, port)\n            // Set socket options if needed (e.g., keepAlive, timeout)\n            clientSocket?.keepAlive = true\n            // clientSocket?.soTimeout = 15000 // 15 second read timeout - careful with this, might cause disconnects\n\n            clientWriter = PrintWriter(clientSocket!!.getOutputStream(), true)\n            clientReader = BufferedReader(InputStreamReader(clientSocket!!.getInputStream()))\n            isConnectedToServer = true // Set flag only after successful connection and streams setup\n            log(\"Client: Connected successfully to $hostAddress:$port.\")\n\n            // Start listener coroutine *after* streams are set up\n            listenToServer()\n\n            // Send player name immediately after connecting\n            sendMessageToServer(NetworkMessage(MessageType.PLAYER_NAME, playerName))\n\n        } catch (e: Exception) {\n            logError(\"Client: Connection to $hostAddress:$port failed\", e)\n            isConnectedToServer = false // Ensure flag is false on failure\n            withContext(Dispatchers.Main) {\n                _showError.emit(\"Connection failed: ${e.message}\")\n            }\n            // Ensure cleanup happens even if initial connection fails\n             withContext(Dispatchers.Main.immediate) {\n                disconnectFromServer() // Cleanup resources\n             }\n        }\n    }\n}\n\n\n/** CLIENT: Listens for messages from the server */\nprivate fun GameViewModel.listenToServer() {\n    clientReaderJob?.cancel() // Cancel any existing listener job\n\n    clientReaderJob = viewModelScope.launch(Dispatchers.IO) {\n        log(\"Client: Listener started.\")\n        try {\n            while (isActive) { // Loop while the coroutine is active\n                val messageJson = clientReader?.readLine()\n                if (messageJson == null) {\n                    log(\"Client: Disconnected from server (readLine returned null).\")\n                    break // Exit loop if server closes connection\n                }\n\n                log(\"Client: Received from Server: $messageJson\") // Can be verbose\n                 try {\n                     // Basic validation\n                     if (!messageJson.startsWith(\"{\") || !messageJson.endsWith(\"}\")) {\n                         logError(\"Client: Invalid JSON format received from Server: $messageJson\")\n                         continue // Skip this message\n                     }\n                    val message = gson.fromJson(messageJson, NetworkMessage::class.java)\n                    // Process on Main thread for UI/State safety\n                    withContext(Dispatchers.Main.immediate) {\n                        handleServerMessage(message)\n                    }\n                 } catch (e: JsonSyntaxException) {\n                     logError(\"Client: JSON Parse Error from Server: ${e.message} for JSON: $messageJson\")\n                 } catch (e: Exception) {\n                    logError(\"Client: Error handling server message\", e)\n                }\n            }\n        } catch (e: SocketException) {\n            // Handle common socket errors gracefully (e.g., connection reset, closed)\n            if (isActive) { // Don't log error if we intentionally disconnected\n                 logError(\"Client: SocketException in listener (likely disconnection): ${e.message}\")\n            }\n        } catch (e: Exception) {\n            // Catch other potential exceptions during readLine\n            if (isActive) { // Avoid logging errors during cancellation\n                logError(\"Client: Error reading from server socket\", e)\n            }\n        } finally {\n            log(\"Client: Listener stopped.\")\n            // Ensure disconnect cleanup happens on the Main thread when listener ends\n            withContext(Dispatchers.Main) {\n                // Check if still connected flag is set, prevents multiple disconnect calls if already handled\n                if (isConnectedToServer) {\n                    log(\"Client: Listener ended, triggering disconnect cleanup.\")\n                    _showError.emit(\"Disconnected from host.\") // Inform user\n                    disconnectFromServer()\n                } else {\n                    log(\"Client: Listener ended, but already marked as disconnected.\")\n                }\n            }\n        }\n    }\n\n    // Optional: Log job completion\n     clientReaderJob?.invokeOnCompletion { throwable ->\n         if (throwable != null && throwable !is CancellationException) {\n             logError(\"Client: Listener job completed with error\", throwable)\n         } else {\n             log(\"Client: Listener job completed.\")\n         }\n     }\n}\n\n/** CLIENT: Handles messages received from the server (Runs on Main Thread) */\nprivate fun GameViewModel.handleServerMessage(message: NetworkMessage) {\n    log(\"Client: Handling message: ${message.type}\") // Can be verbose\n    when (message.type) {\n        MessageType.ASSIGN_ID -> {\n            // Server sends assigned ID. Gson might parse numbers as Double.\n            val id = (message.data as? Double)?.toInt() ?: -1 // Safely convert Double to Int\n            if (id != -1) {\n                if (localPlayerId == -1) { // Assign only if not already assigned\n                    setLocalPlayerIdInternal(id) // Use internal setter\n                    log(\"Client: Assigned Player ID: $localPlayerId\")\n                } else if (localPlayerId != id) {\n                    // This shouldn't happen if logic is correct, but handle defensively\n                    logError(\"Client: Received conflicting Player ID assignment! Current: $localPlayerId, Received: $id. Disconnecting.\")\n                    viewModelScope.launch { _showError.emit(\"Network error: ID conflict.\") }\n                    disconnectFromServer()\n                }\n                // else: Received same ID again, ignore.\n            } else {\n                logError(\"Client: Received invalid ASSIGN_ID data: ${message.data}\")\n                 // Consider disconnecting if ID assignment fails\n                 viewModelScope.launch { _showError.emit(\"Network error: Invalid ID from host.\") }\n                 disconnectFromServer()\n            }\n        }\n        MessageType.GAME_STATE_UPDATE -> {\n            try {\n                // Deserialize the GameState embedded in the message data\n                val gameStateJson = gson.toJson(message.data) // Convert Any? back to JSON\n                val updatedState = gson.fromJson(gameStateJson, GameState::class.java) // Deserialize\n\n                // Basic validation of the received state\n                if (updatedState == null) {\n                     logError(\"Client: Failed to deserialize GameState update.\")\n                     return\n                }\n                if (updatedState.players.isEmpty() && _state.value.players.isNotEmpty()) {\n                    // Allow empty state if we are also in empty state (initial connect before host setup?)\n                    // But ignore if we previously had players and now get an empty list mid-game.\n                    logError(\"Client: Received empty player list in GameState update mid-game. Ignoring.\")\n                    return // Ignore potential invalid empty state received mid-game\n                }\n\n                 // Check if our player ID exists in the new state if we expect it\n                 if (localPlayerId != -1 && updatedState.players.none { it.id == localPlayerId } && updatedState.players.isNotEmpty()) {\n                     logError(\"Client: Received GameState update, but local player ID $localPlayerId is missing! Players: ${updatedState.players.map{it.id}}\")\n                     // Don't disconnect immediately, maybe host removed player intentionally? Wait for KICKED msg?\n                     // Or handle based on KICKED message below. If no KICKED, this might mean error.\n                     // Let's emit an error for now.\n                     viewModelScope.launch { _showError.emit(\"Removed from game lobby?\") }\n                     // disconnectFromServer() // Might be too aggressive\n                     return\n                 }\n\n\n                // Update the main state flow\n                _state.value = updatedState\n\n                // Update connected players count based on the received state\n                 val validPlayerCount = updatedState.players.count {\n                     it.name != \"Waiting...\" && it.name != \"[Disconnected]\" && !it.name.contains(\"[LEFT]\")\n                 }\n                _connectedPlayersCount.value = validPlayerCount\n                log(\"Client: GameState updated. Players: $validPlayerCount/${updatedState.players.size}. Awaiting: ${updatedState.awaitingInputFromPlayerIndex}. MyID: $localPlayerId\") // Verbose\n\n                // Determine if the game has started based on receiving a hand\n                val myHand = updatedState.players.find { it.id == localPlayerId }?.hand\n                if (!_gameStarted.value && myHand?.isNotEmpty() == true) {\n                    setGameStartedInternal(true) // Use internal setter\n                    log(\"Client: Game Started (detected non-empty hand).\")\n                }\n\n\n            } catch (e: Exception) {\n                logError(\"Client: Error deserializing GAME_STATE_UPDATE\", e)\n                // Potentially disconnect if state updates become corrupted\n            }\n        }\n         MessageType.DISCONNECTED -> {\n             // Informational message that *another* player left\n             val disconnectedPlayerId = (message.data as? Double)?.toInt() ?: -1\n             if (disconnectedPlayerId != -1 && disconnectedPlayerId != localPlayerId) {\n                 val playerName = _state.value.players.find { it.id == disconnectedPlayerId }?.name ?: \"Player $disconnectedPlayerId\"\n                 log(\"Client: Received notice that $playerName disconnected.\")\n                 // The GAME_STATE_UPDATE should reflect the change in the player list eventually.\n                 viewModelScope.launch { _showError.emit(\"$playerName has left the game.\") }\n             }\n         }\n         MessageType.LOBBY_FULL -> {\n             val msg = message.data as? String ?: \"Lobby is full.\"\n             log(\"Client: Received LOBBY_FULL message.\")\n             viewModelScope.launch { _showError.emit(msg) }\n             disconnectFromServer() // Disconnect as we can't join\n         }\n         MessageType.KICKED -> {\n             val reason = message.data as? String ?: \"Removed from game by host.\"\n             logError(\"Client: Received KICKED message. Reason: $reason\")\n             viewModelScope.launch { _showError.emit(reason) }\n             disconnectFromServer() // Disconnect as we were kicked\n         }\n        MessageType.ERROR -> {\n            val errorMsg = message.data as? String ?: \"Unknown server error\"\n            logError(\"Client: Received error from server: $errorMsg\")\n            viewModelScope.launch { _showError.emit(\"Server Error: $errorMsg\") }\n            // Decide if the error is critical enough to warrant disconnection\n            // if (errorMsg.contains(\"critical error\")) { disconnectFromServer() }\n        }\n        else -> log(\"Client: Received unhandled message type: ${message.type}\")\n    }\n}\n\n\n/** CLIENT: Sends a message to the host server */\nfun GameViewModel.sendMessageToServer(message: NetworkMessage) {\n    // Capture writer locally to prevent race condition with nullification during disconnect\n    val writer = clientWriter\n\n    if (!isConnectedToServer || isHost || writer == null) { // Check captured writer\n        log(\"Client: Cannot send message. Not connected, is host, or writer is null.\")\n        return\n    }\n\n    viewModelScope.launch(Dispatchers.IO) { // Network I/O on background thread\n        try {\n            val messageJson = gson.toJson(message)\n            // Synchronize on the writer to prevent potential race conditions if called rapidly\n            synchronized(writer) { // Synchronize on the captured writer\n                writer.println(messageJson) // Use captured writer\n                if (writer.checkError() == true) {\n                    throw Exception(\"PrintWriter error after sending ${message.type}\")\n                }\n            }\n            log(\"Client: Sent message type: ${message.type}\") // Optional success log\n        } catch (e: Exception) {\n            logError(\"Client: Error sending message (${message.type})\", e)\n            // If sending fails, assume connection issue and disconnect\n            withContext(Dispatchers.Main) {\n                if (isConnectedToServer) { // Avoid showing error if already disconnecting\n                    _showError.emit(\"Connection error sending message. Disconnecting.\")\n                    disconnectFromServer()\n                }\n            }\n        }\n    }\n}\n\n/** CLIENT: Disconnects from the server and cleans up resources */\nfun GameViewModel.disconnectFromServer() {\n    // Prevent disconnect if already disconnected or if this device is the host\n    if (isHost || (!isConnectedToServer && clientSocket == null)) {\n        log(\"Client: Already disconnected or is host. Aborting disconnect.\")\n        return\n    }\n\n    log(\"Client: Disconnecting from server...\")\n    isConnectedToServer = false // Set flag immediately\n\n    // Cancel the listener job first\n    clientReaderJob?.cancel(\"Client disconnecting\")\n    clientReaderJob = null\n\n    // Close network resources in a background thread\n    // Make copies of the variables before launching the IO scope\n    val writerToClose = clientWriter\n    val readerToClose = clientReader\n    val socketToClose = clientSocket\n    clientWriter = null // Nullify main references immediately\n    clientReader = null\n    clientSocket = null\n\n    viewModelScope.launch(Dispatchers.IO) {\n        runCatching { writerToClose?.close() }.onFailure { /* Log quietly */ }\n        runCatching { readerToClose?.close() }.onFailure { /* Log quietly */ }\n        runCatching { socketToClose?.close() }.onFailure { /* Log quietly */ }\n        log(\"Client: Network resources closed attempt.\") // Verbose\n    }\n\n\n    // Reset client-specific state on the Main thread\n     viewModelScope.launch(Dispatchers.Main.immediate) { // Use immediate if possible\n        setGameStartedInternal(false) // Use internal setter\n        // Reset GameState to initial empty state upon disconnection\n        _state.value = createInitialEmptyGameState()\n        setLocalPlayerIdInternal(-1) // Use internal setter\n        _connectedPlayersCount.value = 0 // Reset connection count\n         stopNsdDiscovery() // Ensure NSD discovery stops if it was running\n        _discoveredHosts.value = emptyList() // Clear discovered hosts list\n        log(\"Client: Disconnected and state reset.\")\n     }\n}",
                "GameViewModelHost.kt": "package com.example.mindikot.ui.viewmodel\n\nimport androidx.lifecycle.viewModelScope // Needed for viewModelScope.launch\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport com.example.mindikot.core.engine.DeckGenerator\nimport com.example.mindikot.core.engine.GameEngine\nimport com.example.mindikot.core.model.GameMode\nimport com.example.mindikot.core.state.InputType\nimport com.example.mindikot.ui.viewmodel.network.NetworkMessage\nimport com.example.mindikot.ui.viewmodel.network.MessageType\nimport com.example.mindikot.ui.viewmodel.utils.getLocalIpAddress // Import utility\nimport com.example.mindikot.ui.viewmodel.utils.log\nimport com.example.mindikot.ui.viewmodel.utils.logError\nimport com.google.gson.JsonSyntaxException\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.update\nimport java.io.BufferedReader\nimport java.io.InputStreamReader\nimport java.io.PrintWriter\nimport java.net.ServerSocket\nimport java.net.SocketException\n\n// ========================================================================// HOST FUNCTIONS (Implemented as Extension Functions on GameViewModel)\n// ========================================================================\n/** HOST: Starts ServerSocket and initiates NSD Registration */\nfun GameViewModel.startServerAndDiscovery(port: Int = 0) { // Port 0 lets OS pick free port\n    if (isServerRunning || !isHost) {\n        log(\"Server already running or not host. Aborting start.\")\n        return\n    }\n    log(\"Attempting to start server and NSD registration...\")\n    isServerRunning = true // Set flag immediately\n\n    viewModelScope.launch(Dispatchers.IO) {\n        var serverStarted = false\n        var nsdRegistered = false // Flag to track if registration was successful\n        try {\n            // 1. Start Server Socket\n            serverSocket = ServerSocket(port)\n            val actualPort = serverSocket!!.localPort\n            // servicePort = actualPort // Access internal property directly\n            // Use reflection or make servicePort internal/public in GameViewModel if needed outside Host extensions\n            // For now, assume GameViewModel manages its own servicePort property access if needed.\n            // Let's update GameViewModel to have internal servicePort setter\n            setServicePortInternal(actualPort) // Use internal setter\n\n            log(\"Server socket started successfully on port $actualPort.\")\n            serverStarted = true\n\n            // 2. Get Host IP for display (use utility extension)\n            val localIp = getLocalIpAddress()\n            withContext(Dispatchers.Main) { _hostIpAddress.value = localIp?.hostAddress }\n            val hostAddress = localIp?.hostAddress ?: \"Not Found\"\n            log(\"Host IP for display: ${hostAddress}\")\n\n            // 3. Register NSD Service (call NSD extension function)\n            if (registerNsdService(actualPort)) { // Call NSD extension\n                nsdRegistered = true // Assume registration initiated\n                log(\"NSD registration initiated.\")\n            } else {\n                throw Exception(\"NSD Registration Failed to initiate\") // Failed early\n            }\n\n            log(\"Server and NSD active. Waiting for ${requiredPlayerCount - 1} players...\")\n\n            // 4. Accept Client Connections Loop\n            while (clientSockets.size < requiredPlayerCount - 1 && isServerRunning && isActive) {\n                val socket = serverSocket?.accept() ?: break // Exit if serverSocket is null or closed\n                if (!isServerRunning) { // Double-check after accept\n                    runCatching { socket.close() }\n                    break\n                }\n\n                val currentClientCount = clientSockets.size\n                if (currentClientCount >= requiredPlayerCount - 1) {\n                     log(\"Lobby is full. Rejecting connection from ${socket.remoteSocketAddress}\")\n                     // Send Lobby Full message before closing\n                     try {\n                         val tempWriter = PrintWriter(socket.getOutputStream(), true)\n                         val fullMessage = gson.toJson(NetworkMessage(MessageType.LOBBY_FULL, \"Game lobby is full.\"))\n                         tempWriter.println(fullMessage)\n                         tempWriter.flush() // Ensure message is sent\n                         delay(100) // Small delay before closing\n                         tempWriter.close()\n                     } catch (e: Exception) {\n                        logError(\"Error sending LOBBY_FULL message\", e)\n                     } finally {\n                        runCatching { socket.close() }\n                     }\n                     continue // Skip adding this client\n                }\n\n\n                val assignedPlayerId = findNextAvailablePlayerId() // Assign next available ID\n\n                log(\"Client connected from ${socket.remoteSocketAddress}, assigning Player ID $assignedPlayerId\")\n\n                try {\n                    val writer = PrintWriter(socket.getOutputStream(), true)\n                    val reader = BufferedReader(InputStreamReader(socket.getInputStream()))\n\n                    // Store client details BEFORE sending messages\n                    clientSockets[assignedPlayerId] = socket\n                    clientWriters[assignedPlayerId] = writer\n                    clientReaders[assignedPlayerId] = reader\n\n                    // Send Assign ID message first\n                    sendMessageToClient(assignedPlayerId, NetworkMessage(MessageType.ASSIGN_ID, assignedPlayerId))\n                    // Wait briefly? May not be necessary.\n                    // delay(50)\n\n                    // Send current lobby state (Game State Update) - Make sure player name is updated first if available\n                     // Player name usually sent by client *after* getting ID, so update state later\n                    sendMessageToClient(assignedPlayerId, NetworkMessage(MessageType.GAME_STATE_UPDATE, _state.value))\n\n                    // Start listening coroutine for this client\n                    listenToClient(assignedPlayerId, reader)\n\n                    // Update connected count on the main thread\n                    withContext(Dispatchers.Main.immediate) {\n                        _connectedPlayersCount.value = clientSockets.size + 1 // Host + clients\n                        log(\"Player ID $assignedPlayerId added. Connected: ${_connectedPlayersCount.value}/${requiredPlayerCount}\")\n\n                        // **** REMOVE THIS BLOCK ****\n                        // Check if lobby is now full after adding this player\n                        // if (_connectedPlayersCount.value == requiredPlayerCount) {\n                        //     log(\"All players connected! Preparing initial game state...\")\n                        //     // DO NOT CALL THIS HERE - Wait for Player Name message\n                        //     // prepareAndBroadcastInitialState()\n                        // }\n                        // ***************************\n\n                        // Instead, just broadcast the updated lobby state so the new\n                        // client sees the current list (including themselves as Waiting...)\n                        // Ensure player name update happens *before* this if possible, but\n                        // usually name comes *after* client gets ID. So broadcast current state.\n                        broadcastGameState(_state.value) // Broadcast updated lobby list\n                    }\n                } catch (e: Exception) {\n                    logError(\"Error during client setup (Player $assignedPlayerId)\", e)\n                    // Clean up resources for this specific failed client connection\n                    clientSockets.remove(assignedPlayerId)\n                    clientWriters.remove(assignedPlayerId)\n                    clientReaders.remove(assignedPlayerId)\n                    runCatching { socket.close() }\n                    // Update count if we failed to add the player\n                    withContext(Dispatchers.Main.immediate) {\n                         _connectedPlayersCount.value = clientSockets.size + 1\n                    }\n                }\n            } // End of accept loop\n\n            log(\"Stopped accepting new connections (lobby full or server stopped). isServerRunning=$isServerRunning\")\n\n        } catch (e: SocketException) {\n             if (isServerRunning) { // Log error only if we expected to be running\n                 logError(\"ServerSocket Exception (maybe address in use or closed unexpectedly?)\", e)\n                 withContext(Dispatchers.Main) {\n                     _showError.emit(\"Host Error: ${e.message}\")\n                 }\n             }\n        } catch (e: Exception) {\n            if (isServerRunning) { // Only log error if we intended to be running\n                 logError(\"Server/NSD start failed or accept loop error\", e)\n                 withContext(Dispatchers.Main) {\n                     _showError.emit(\"Error starting host: ${e.message}\")\n                 }\n            }\n        } finally {\n            log(\"Server listener coroutine finishing. Cleaning up...\")\n            // Ensure server and NSD are stopped if the loop exits unexpectedly\n            // Call stopServerAndDiscovery on the Main thread to ensure proper cleanup\n//            withContext(Dispatchers.Main) {\n//                if (isServerRunning) { // Only stop if it was meant to be running\n//                   stopServerAndDiscovery() // Cleanup NSD, server socket, clients\n//                }\n//            }\n        }\n    }\n}\n\n// Helper to find the next available player ID (Host is 0)\nprivate fun GameViewModel.findNextAvailablePlayerId(): Int {\n    // Player IDs are 0 (host), 1, 2, ... requiredPlayerCount - 1\n    val existingIds = clientSockets.keys + 0 // Include host ID 0\n    for (id in 1 until requiredPlayerCount) {\n        if (id !in existingIds) {\n            return id\n        }\n    }\n    // Should not happen if logic is correct, but return an indicator of error\n    logError(\"Could not find an available Player ID slot!\")\n    return -1 // Indicate error\n}\n\n\n/** HOST: Stops the ServerSocket and unregisters NSD service. */\nfun GameViewModel.stopServerAndDiscovery() {\n    if (!isHost) return\n    // Check if already stopped to prevent redundant calls\n    if (!isServerRunning && serverSocket == null && registrationListener == null && clientSockets.isEmpty()) {\n        log(\"stopServerAndDiscovery called but server/NSD likely already stopped.\")\n        return\n    }\n    log(\"Stopping server and NSD...\")\n    isServerRunning = false // Signal loops and checks to stop\n\n    // 1. Unregister NSD (call NSD extension)\n    unregisterNsdService() // Handles null checks internally\n\n    // 2. Close Server Socket (use runCatching for safety)\n    viewModelScope.launch(Dispatchers.IO) { // Close socket off main thread\n        runCatching {\n            serverSocket?.close() // Close the server socket first\n        }.onSuccess {\n            log(\"Server socket closed.\")\n        }.onFailure { e ->\n            // Ignore errors if already closed\n            if (e !is SocketException || e.message?.contains(\"Socket closed\", ignoreCase = true) == false) {\n                 logError(\"Error closing server socket\", e)\n            }\n        }\n        serverSocket = null // Nullify after attempting close\n    }\n    setServicePortInternal(0) // Reset port\n\n    // 3. Cancel client jobs & close connections\n    // Use a copy of keys to avoid ConcurrentModificationException while iterating\n    val clientIds = clientSockets.keys.toList()\n    log(\"Closing connections for clients: $clientIds\")\n    clientIds.forEach { removeClient(it) } // Use removeClient for thorough cleanup\n\n    // 4. Reset host-specific state (on Main thread)\n    viewModelScope.launch(Dispatchers.Main) {\n        _connectedPlayersCount.value = 0 // Reset count\n        _gameStarted.value = false\n        _hostIpAddress.value = null\n        // Optionally reset GameState if desired, or keep it for review\n        // _state.value = createInitialEmptyGameState()\n        log(\"Server stopped, NSD unregistered, connections closed.\")\n    }\n}\n\n/** HOST: Starts a listener coroutine for a specific client. */\nprivate fun GameViewModel.listenToClient(playerId: Int, reader: BufferedReader) {\n    clientJobs[playerId]?.cancel() // Cancel any previous job for this ID\n\n    clientJobs[playerId] = viewModelScope.launch(Dispatchers.IO) {\n        log(\"Listener started for Player $playerId.\")\n        try {\n            while (isActive) { // Loop while coroutine is active\n                val messageJson = reader.readLine()\n                if (messageJson == null) {\n                    log(\"Player $playerId disconnected (readLine returned null).\")\n                    break // Exit loop if connection is closed\n                }\n\n                log(\"Received from Player $playerId: $messageJson\") // Can be verbose\n                try {\n                    // Basic validation: Check if it looks like JSON\n                    if (!messageJson.startsWith(\"{\") || !messageJson.endsWith(\"}\")) {\n                         logError(\"Invalid JSON format received from Player $playerId: $messageJson\")\n                         continue // Skip this message\n                    }\n\n                    val message = gson.fromJson(messageJson, NetworkMessage::class.java)\n\n                    // Process message on Main thread for state safety\n                    withContext(Dispatchers.Main.immediate) { // Use immediate for faster processing if safe\n                        handleClientMessage(playerId, message)\n                    }\n                } catch (e: JsonSyntaxException) {\n                    logError(\"JSON Parse Error from Player $playerId: ${e.message} for JSON: $messageJson\")\n                    // Optionally send an error back to the client if possible/needed\n                } catch (e: Exception) {\n                    logError(\"Error handling message from Player $playerId\", e)\n                }\n            }\n        } catch (e: SocketException) {\n             // Ignore \"Socket closed\" exceptions if not active or server stopped\n             if (isActive && isServerRunning && e.message?.contains(\"Socket closed\", ignoreCase = true) == false) {\n                  logError(\"SocketException for Player $playerId\", e)\n             } else {\n                  log(\"Listener for Player $playerId stopped (Socket closed or intentional).\")\n             }\n        } catch (e: Exception) {\n            // Avoid logging errors during intentional cancellation or socket closure\n            if (isActive && isServerRunning) {\n                logError(\"Error reading from Player $playerId socket\", e)\n            } else {\n                 log(\"Listener for Player $playerId stopped (likely intentional close or cancellation).\")\n            }\n        } finally {\n            log(\"Listener coroutine finishing for Player $playerId.\")\n            // Ensure cleanup (removing client) happens on the Main thread safely\n            // regardless of how the loop exited.\n            withContext(Dispatchers.Main) {\n                removeClient(playerId)\n            }\n        }\n    }\n\n    // Optional: Add invokeOnCompletion for finer-grained logging/cleanup if needed\n     clientJobs[playerId]?.invokeOnCompletion { throwable ->\n         if (throwable != null && throwable !is CancellationException) {\n             logError(\"Listener job for Player $playerId completed with error\", throwable)\n         } else {\n             log(\"Listener job for Player $playerId completed normally or cancelled.\")\n         }\n         // Cleanup should be handled in the finally block primarily\n     }\n}\n\n/** HOST: Handles messages received from a specific client. (Runs on Main Thread) */\nprivate fun GameViewModel.handleClientMessage(playerId: Int, message: NetworkMessage) {\n    log(\"Handling message: ${message.type} from Player $playerId\")\n    when (message.type) {\n        MessageType.PLAYER_ACTION -> {\n            if (_state.value.awaitingInputFromPlayerIndex == playerId) {\n                val expectedType = _state.value.requiredInputType\n                try {\n                    // Deserialize based on expected type - Robust handling needed\n                    val actionData: Any? = when (expectedType) {\n                        InputType.PLAY_CARD, InputType.CHOOSE_TRUMP_SUIT -> {\n                            // Attempt to deserialize directly to Card\n                            tryDeserializeJson(message.data, com.example.mindikot.core.model.Card::class.java)\n                        }\n                        InputType.REVEAL_OR_PASS -> {\n                            // Attempt to deserialize directly to Decision enum\n                             tryDeserializeJson(message.data, GameEngine.Decision::class.java)\n                        }\n                        null -> {\n                            logError(\"Received PLAYER_ACTION from Player $playerId but no input type was expected.\")\n                            null // Error case\n                        }\n                    }\n\n                    if (actionData != null) {\n                        // Input successfully deserialized, process it\n                        processGameInput(playerId, actionData) // Pass Player ID for context\n                    } else {\n                        logError(\"Failed to parse PLAYER_ACTION data for expected type $expectedType from Player $playerId. Data: ${message.data}\")\n                        sendMessageToClient(playerId, NetworkMessage(MessageType.ERROR, \"Invalid action data format.\"))\n                        // Consider re-requesting input or handling the error more gracefully\n                    }\n                } catch (e: Exception) {\n                    logError(\"Error deserializing/processing PLAYER_ACTION data from Player $playerId\", e)\n                    sendMessageToClient(playerId, NetworkMessage(MessageType.ERROR, \"Error processing your action.\"))\n                }\n            } else {\n                log(\"Received action from Player $playerId but it's not their turn (expected ${_state.value.awaitingInputFromPlayerIndex}). Ignoring.\")\n                // Optionally send \"Not your turn\" error, but be careful not to spam\n                // sendMessageToClient(playerId, NetworkMessage(MessageType.ERROR, \"Not your turn\"))\n            }\n        }\n        MessageType.PLAYER_NAME -> {\n            val name = message.data as? String\n            if (!name.isNullOrBlank()) {\n                val previousName = _state.value.players.find { it.id == playerId }?.name\n                updatePlayerName(playerId, name) // Update name and broadcast state\n\n                // **** ADD THIS CHECK ****\n                // Check if this was the last player joining and if we can now start\n                val currentState = _state.value // Get the state *after* name update\n                val allPlayersNamed = currentState.players.none {\n                    it.name == \"Waiting...\" || it.name == \"[Disconnected]\" || it.name.contains(\"[LEFT]\")\n                }\n                if (previousName == \"Waiting...\" && // Only trigger if they were previously Waiting\n                    _connectedPlayersCount.value == requiredPlayerCount &&\n                    allPlayersNamed) {\n                    log(\"Last player ($name - ID $playerId) joined and named. Starting game.\")\n                    prepareAndBroadcastInitialState() // NOW it's safe to start\n                }\n                // ***********************\n\n            } else {\n                logError(\"Received invalid or blank PLAYER_NAME data from Player $playerId: ${message.data}\")\n            }\n        }\n        // Handle other message types if needed (e.g., PING, REQUEST_STATE etc.)\n        else -> log(\"Received unhandled message type: ${message.type} from Player $playerId\")\n    }\n}\n\n/** HOST: Deals cards, sets hidden card (Mode B), updates state, and broadcasts. (Runs on Main Thread) */\nfun GameViewModel.prepareAndBroadcastInitialState() {\n    // Ensure this runs on the main thread if called from background\n    viewModelScope.launch(Dispatchers.Main.immediate) {\n        log(\"Preparing initial game state for ${requiredPlayerCount} players...\")\n        val currentPlayers = _state.value.players\n        // Validate player count and readiness\n        if (currentPlayers.size != requiredPlayerCount ||\n            currentPlayers.any { it.name == \"Waiting...\" || it.name == \"[Disconnected]\" } ||\n            _connectedPlayersCount.value != requiredPlayerCount) {\n            logError(\"Cannot prepare initial state: Incorrect number (${connectedPlayersCount.value}/${requiredPlayerCount}) or incomplete players. Players: ${currentPlayers.map { it.name }}\")\n            // Maybe send error to clients or host UI\n            _showError.emit(\"Cannot start game. Waiting for all players.\")\n            return@launch\n        }\n\n        // Deck generation now relies on requiredPlayerCount from ViewModel\n        val deck = DeckGenerator.generateDeck(requiredPlayerCount)\n        var hiddenCard: com.example.mindikot.core.model.Card? = null\n\n        // Set hidden card for Mode B\n        if (_state.value.gameMode == GameMode.FIRST_CARD_HIDDEN) {\n            if (deck.isNotEmpty()) {\n                hiddenCard = deck.removeAt(0) // Take the first card after shuffle\n                log(\"Hidden card set (Mode B): ${hiddenCard.suit}\")\n            } else {\n                logError(\"Cannot set hidden card: Deck is empty!\")\n                _showError.emit(\"Error: Deck empty during setup.\")\n                return@launch\n            }\n        }\n\n        // Deal cards\n        val updatedPlayers = currentPlayers.toMutableList()\n        val cardsPerPlayer = deck.size / requiredPlayerCount\n        if (deck.size % requiredPlayerCount != 0) {\n            logError(\"Deck size (${deck.size}) not evenly divisible by $requiredPlayerCount players after potential hidden card!\")\n            // Decide how to handle extra cards if necessary (e.g., discard, error out)\n        }\n\n        var currentCardIndex = 0\n        for (i in 0 until requiredPlayerCount) {\n            // Ensure player index exists before dealing\n             val playerIndex = updatedPlayers.indexOfFirst { it.id == i }\n             if (playerIndex == -1) {\n                 logError(\"Player ID $i not found in list for dealing!\")\n                 continue\n             }\n\n            val handEndIndex = currentCardIndex + cardsPerPlayer\n            // Make sure we don't go past the end of the deck\n            val actualEndIndex = minOf(handEndIndex, deck.size)\n            if (currentCardIndex >= actualEndIndex) {\n                 logError(\"Not enough cards left in deck to deal to player $i (index $currentCardIndex)\")\n                 break // Stop dealing if deck runs out unexpectedly\n            }\n            val handCards = deck.subList(currentCardIndex, actualEndIndex).toMutableList()\n\n            updatedPlayers[playerIndex] = updatedPlayers[playerIndex].copy(hand = handCards)\n            currentCardIndex = actualEndIndex // Move to the next chunk of cards\n        }\n         log(\"Cards dealt. ${updatedPlayers.sumOf { it.hand.size }} cards assigned. Remaining deck: ${deck.size - currentCardIndex}\")\n\n\n        // Create the initial game state for the round\n        var initialState = _state.value.copy(\n            players = updatedPlayers,\n            hiddenCard = hiddenCard, // Assign the hidden card (null if not Mode B)\n            tricksWon = mutableMapOf(1 to 0, 2 to 0), // Reset tricks won\n            currentTrickPlays = mutableListOf(), // Clear current trick\n            trumpSuit = null, // Reset trump\n            trumpRevealed = false, // Reset trump revealed status\n            currentLeaderIndex = 0, // Host leads first trick (or decide based on rules)\n            awaitingInputFromPlayerIndex = null, // Will be set by requestInput\n            requiredInputType = null // Will be set by requestInput\n        )\n\n        // Determine the first action required\n        initialState = GameEngine.requestInput(initialState, initialState.currentLeaderIndex)\n\n        // Update the central StateFlow\n        _state.value = initialState\n        _gameStarted.value = true // Mark game as officially started\n\n        // Broadcast the finalized initial state to all clients\n        broadcastGameState(initialState)\n        log(\"Initial GameState prepared and broadcast. Game started.\")\n    }\n}\n\n\n/** HOST: Broadcasts the GameState to all connected clients. */\nfun GameViewModel.broadcastGameState(gameState: com.example.mindikot.core.state.GameState) {\n    if (!isHost) return\n    val message = NetworkMessage(MessageType.GAME_STATE_UPDATE, gameState)\n    val clientIds = clientWriters.keys.toList() // Get a stable list of IDs\n     log(\"Broadcasting GameState to ${clientIds.size} clients (IDs: $clientIds)...\") // Verbose\n\n    clientIds.forEach { id ->\n        sendMessageToClient(id, message) // Use the dedicated send function\n    }\n     log(\"Broadcast attempt complete.\") // Verbose\n}\n\n\n/** HOST: Sends a specific message to a single client. Handles potential errors. */\nfun GameViewModel.sendMessageToClient(playerId: Int, message: NetworkMessage) {\n    if (!isHost) return\n    val writer = clientWriters[playerId]\n    if (writer == null) {\n        log(\"Cannot send message, writer not found for Player $playerId (already removed?).\") // Can be noisy\n        return\n    }\n\n    viewModelScope.launch(Dispatchers.IO) { // Perform network I/O off the main thread\n        try {\n            val messageJson = gson.toJson(message)\n            // Synchronize access to the writer to prevent garbled messages if multiple sends occur rapidly\n            // Although each send is in its own coroutine, multiple coroutines might try to write concurrently.\n            synchronized(writer) {\n                writer.println(messageJson)\n                // Check for errors immediately after writing\n                if (writer.checkError()) {\n                    // checkError() flushes and returns true if an error occurred previously or during flush.\n                    throw Exception(\"PrintWriter error occurred for Player $playerId after sending.\")\n                }\n            }\n             log(\"Sent to Player $playerId: ${message.type}\") // Optional: Log successful send\n        } catch (e: Exception) {\n            logError(\"Error sending message to Player $playerId (${message.type})\", e)\n            // If sending fails, assume the client is disconnected and remove them.\n            // Ensure removal happens on the main thread.\n            withContext(Dispatchers.Main) {\n                removeClient(playerId)\n            }\n        }\n    }\n}\n\n/** HOST: Cleans up resources associated with a disconnected or removed client. (Runs on Main Thread) */\nfun GameViewModel.removeClient(playerId: Int) {\n     // Ensure this runs on the Main thread\n     viewModelScope.launch(Dispatchers.Main.immediate) {\n        if (!clientSockets.containsKey(playerId)) {\n            log(\"Attempted to remove Player $playerId, but they were not found (already removed?).\")\n            return@launch // Already removed or never existed\n        }\n\n        log(\"Removing client Player $playerId...\")\n\n        // 1. Cancel the listening job\n        clientJobs[playerId]?.cancel(\"Client removed or disconnected\")\n        clientJobs.remove(playerId)\n\n        // 2. Close network resources (use runCatching for safety) in IO context\n        val writer = clientWriters.remove(playerId)\n        val reader = clientReaders.remove(playerId)\n        val socket = clientSockets.remove(playerId)\n\n        launch(Dispatchers.IO) {\n            runCatching { writer?.close() }.onFailure { /* Log quietly */ }\n            runCatching { reader?.close() }.onFailure { /* Log quietly */ }\n            runCatching { socket?.close() }.onFailure { /* Log quietly */ }\n            log(\"Network resources closed attempt for Player $playerId\") // Verbose\n        }\n\n\n        // 3. Update connected player count\n        _connectedPlayersCount.value = clientSockets.size + 1 // +1 for host\n        log(\"Player $playerId removed. Connected: ${_connectedPlayersCount.value}/${requiredPlayerCount}\")\n\n        // 4. Update Game State and potentially notify others\n        val playerName = _state.value.players.find { it.id == playerId }?.name ?: \"Player $playerId\"\n\n        if (_gameStarted.value) {\n            // If game was in progress, mark player as left and notify UI/other players\n            log(\"Game in progress. Marking Player $playerId ($playerName) as disconnected.\")\n            _showError.emit(\"$playerName disconnected. Game interrupted.\") // Show error on host UI\n\n            // Update the player's state in the GameState\n            val updatedPlayers = _state.value.players.map {\n                if (it.id == playerId) it.copy(name = \"$playerName [LEFT]\", hand = mutableListOf()) // Mark as left, clear hand\n                else it\n            }\n            // Check if game can continue (e.g., less than required players left)\n            val activePlayers = updatedPlayers.count { !it.name.contains(\"[LEFT]\") }\n             var finalState = _state.value.copy(\n                 players = updatedPlayers,\n                 // Reset input if the disconnected player was supposed to play\n                 awaitingInputFromPlayerIndex = if (_state.value.awaitingInputFromPlayerIndex == playerId) null else _state.value.awaitingInputFromPlayerIndex,\n                 requiredInputType = if (_state.value.awaitingInputFromPlayerIndex == playerId) null else _state.value.requiredInputType\n             )\n\n            if (activePlayers < requiredPlayerCount) { // Or specific minimum like 2?\n                 logError(\"Game cannot continue with only $activePlayers active players.\")\n                 _showError.emit(\"Game cannot continue. Not enough players.\")\n                 // TODO: Decide how to end the game gracefully. Maybe navigate to results with an error state?\n                 // For now, just update the state and broadcast. Consider stopping the server.\n                 // stopServerAndDiscovery() // Option: Stop server\n            }\n            // Reset input request if disconnected player was the one to play\n            if(finalState.awaitingInputFromPlayerIndex == null && activePlayers >= requiredPlayerCount) {\n                 // If input was cleared and game should continue, figure out who's next\n                 // This might need more complex logic depending on game rules (skip turn? next player?)\n                 // For simplicity, maybe just set to null and let UI show stalled state?\n                 log(\"Input cleared due to player disconnect.\")\n            }\n\n\n            _state.value = finalState // Update host state\n\n            // Broadcast the updated state showing the player left\n            broadcastGameState(finalState)\n\n\n        } else {\n            // If in lobby, just update the player name to indicate disconnected\n            log(\"Player $playerId ($playerName) disconnected from lobby.\")\n            val updatedLobbyPlayers = _state.value.players.map {\n                if (it.id == playerId) it.copy(name = \"[Disconnected]\", hand = mutableListOf())\n                else it\n            }\n             val updatedLobbyState = _state.value.copy(players = updatedLobbyPlayers)\n            _state.value = updatedLobbyState\n            // Broadcast the updated lobby state\n            broadcastGameState(updatedLobbyState)\n        }\n     }\n}\n\n/** Helper to safely deserialize JSON, returning null on error */\nprivate fun <T> GameViewModel.tryDeserializeJson(data: Any?, targetClass: Class<T>): T? {\n    return try {\n        // Check if data is already the target type (possible with some Gson setups)\n        if (targetClass.isInstance(data)) {\n             @Suppress(\"UNCHECKED_CAST\")\n             return data as T\n        }\n        // Otherwise, assume it's likely a Map from initial deserialization, convert back to JSON then to target class\n        val json = gson.toJson(data) // Convert Any? (likely Map) to JSON string\n        gson.fromJson(json, targetClass)\n    } catch (e: Exception) { // Catch broader exceptions during conversion/parsing\n        logError(\"GSON Deserialization failed for ${targetClass.simpleName}\", e)\n        null\n    }\n}",
                "GameViewModelNsd.kt": "package com.example.mindikot.ui.viewmodel\n\nimport android.content.Context\nimport android.net.nsd.NsdManager\nimport android.net.nsd.NsdServiceInfo\nimport android.os.Build\nimport androidx.lifecycle.viewModelScope // Needed for viewModelScope.launch\nimport com.example.mindikot.ui.viewmodel.utils.log\nimport com.example.mindikot.ui.viewmodel.utils.logError\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.flow.update\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\n\n// ========================================================================// NSD FUNCTIONS (Implemented as Extension Functions on GameViewModel)\n// ========================================================================\nprivate const val SERVICE_TYPE = \"_mindikot._tcp\" // Define service type constant\n\n/**\n * HOST: Registers the game service using NSD.\n * Returns true if registration request was successfully initiated, false otherwise.\n */\nfun GameViewModel.registerNsdService(portToRegister: Int): Boolean {\n    if (!isHost) return false // Only host registers\n\n    // Unregister previous listener if exists\n    if (registrationListener != null) {\n        log(\"NSD registration already in progress or completed. Unregistering previous listener first.\")\n        unregisterNsdService() // Call the cleanup function\n    }\n\n    // Use applicationContext from the receiver ViewModel\n    nsdManager = applicationContext.getSystemService(Context.NSD_SERVICE) as NsdManager?\n    if (nsdManager == null) {\n        logError(\"NSD Manager not available on this device.\")\n        viewModelScope.launch { _showError.emit(\"Network Service Discovery is not available.\") }\n        return false\n    }\n\n    // Create the listener *inside* this function scope\n    val listener = object : NsdManager.RegistrationListener {\n        override fun onServiceRegistered(nsdServiceInfo: NsdServiceInfo) {\n            // Store the successfully registered name\n            // Use internal setter or make property internal/public\n             setNsdServiceNameRegisteredInternal(nsdServiceInfo.serviceName)\n\n            log(\"NSD Service registered: ${nsdServiceInfo.serviceName} on port ${nsdServiceInfo.port}\")\n             // Update host IP state just in case it wasn't ready before\n             // This should likely be handled where the server starts, not here\n             // viewModelScope.launch(Dispatchers.Main) {\n             //     _hostIpAddress.value = getLocalIpAddress()?.hostAddress\n             // }\n        }\n\n        override fun onRegistrationFailed(serviceInfo: NsdServiceInfo, errorCode: Int) {\n            logError(\"NSD registration failed for ${serviceInfo.serviceName}: Error $errorCode\")\n            setNsdServiceNameRegisteredInternal(null) // Clear name on failure\n             // Notify UI about the failure\n             viewModelScope.launch { _showError.emit(\"Failed to advertise game (NSD Error $errorCode)\") }\n            // Consider stopping the server if NSD fails critically? Or allow manual IP connect?\n            // stopServerAndDiscovery()\n        }\n\n        override fun onServiceUnregistered(arg0: NsdServiceInfo) {\n            log(\"NSD Service unregistered: ${arg0.serviceName}\")\n            // Clear the stored name if it matches the one being unregistered\n            if (arg0.serviceName == nsdServiceNameRegistered) {\n                setNsdServiceNameRegisteredInternal(null)\n            }\n             // Clear host IP display when unregistered? Maybe not, server might still be running.\n             // viewModelScope.launch(Dispatchers.Main) { _hostIpAddress.value = null }\n        }\n\n        override fun onUnregistrationFailed(serviceInfo: NsdServiceInfo, errorCode: Int) {\n            // This means the service might still be lingering on the network\n            logError(\"NSD unregistration failed for ${serviceInfo.serviceName}: Error $errorCode\")\n            // Consider retrying unregistration later?\n        }\n    }\n    registrationListener = listener // Store the listener instance\n\n    // Create unique service name\n    val baseName = \"Mindikot\"\n    // Attempt to use host player name if available and not default\n    val hostNamePart = _state.value.players.find { it.id == 0 }?.name?.let {\n         if (it != \"Waiting...\" && it.isNotBlank()) \"_(${it.take(8)})\" else \"\"\n     } ?: \"\"\n    val uniqueName = \"${baseName}${hostNamePart}_${(1000..9999).random()}\" // Simple uniqueness factor\n\n    val serviceInfo = NsdServiceInfo().apply {\n        serviceName = uniqueName\n        serviceType = SERVICE_TYPE\n        port = portToRegister\n        // Add attributes if needed (e.g., player count, game mode)\n        // setAttribute(\"players\", requiredPlayerCount.toString())\n        // setAttribute(\"mode\", _state.value.gameMode.name)\n    }\n\n    log(\"Attempting to register NSD service: $uniqueName on port $portToRegister\")\n    try {\n        // Use the stored listener\n        nsdManager?.registerService(serviceInfo, NsdManager.PROTOCOL_DNS_SD, registrationListener!!)\n        return true // Registration initiated\n    } catch (e: Exception) {\n        logError(\"Exception during NSD service registration\", e)\n        registrationListener = null // Clear listener on exception\n         viewModelScope.launch { _showError.emit(\"Error starting game advertisement.\") }\n        return false // Registration failed to initiate\n    }\n}\n\n/** HOST: Unregisters the NSD service if it's currently registered. */\nfun GameViewModel.unregisterNsdService() {\n    if (nsdManager != null && registrationListener != null) {\n        val listenerToUnregister = registrationListener // Capture current listener\n        registrationListener = null // Nullify immediately to prevent race conditions if called again quickly\n\n        log(\"Unregistering NSD service: $nsdServiceNameRegistered\")\n        try {\n            nsdManager?.unregisterService(listenerToUnregister)\n            // Name cleared in the listener's onServiceUnregistered callback\n        } catch (e: IllegalArgumentException) {\n             log(\"Error unregistering NSD service (already unregistered?): ${e.message}\")\n        } catch (e: Exception) {\n            logError(\"Exception during NSD service unregistration\", e)\n            // If unregistration fails, the listener might still be technically active\n            // but we've nulled our reference. Might lead to leaks if NSD manager holds reference.\n        }\n    } else {\n         log(\"NSD Service not registered or listener is null, skipping unregistration.\")\n    }\n}\n\n\n/** CLIENT: Starts NSD discovery */\nfun GameViewModel.startNsdDiscovery() {\n    if (isHost) return // Host doesn't discover\n    if (discoveryListener != null) {\n         log(\"Client: NSD Discovery already active. Restarting.\")\n         stopNsdDiscovery() // Stop existing discovery first\n         // Add a small delay before restarting to allow resources to release\n         viewModelScope.launch {\n             delay(200)\n             internalStartNsdDiscovery() // Call internal function after delay\n         }\n         return\n    }\n    internalStartNsdDiscovery() // Start immediately if not already active\n}\n\n// Internal function to perform the actual start logic\nprivate fun GameViewModel.internalStartNsdDiscovery() {\n     if (isHost || discoveryListener != null) return // Re-check conditions\n\n    // Permission check should happen in the UI before calling this\n\n    // Use applicationContext from receiver\n    nsdManager = applicationContext.getSystemService(Context.NSD_SERVICE) as NsdManager?\n    if (nsdManager == null) {\n        logError(\"Client: NSD Manager not available.\")\n         viewModelScope.launch { _showError.emit(\"Network Service Discovery is not available.\") }\n        return\n    }\n\n    // Clear previous results and resolving tracker\n     viewModelScope.launch(Dispatchers.Main) {\n         _discoveredHosts.value = emptyList()\n     }\n    resolvingServices.clear()\n\n     // Create the listener\n    val listener = object : NsdManager.DiscoveryListener {\n        override fun onDiscoveryStarted(regType: String) { log(\"NSD discovery started for type: $regType\") }\n\n        override fun onServiceFound(service: NsdServiceInfo) {\n             log(\"NSD service found raw: Name=${service.serviceName}, Type=${service.serviceType}, Host=${service.host}, Port=${service.port}\") // Verbose\n            // Filter for correct type, avoid self-discovery (if host name known), and check if already resolving\n            if (\n//                service.serviceName != nsdServiceNameRegistered && // Avoid self if name is known (mainly for testing)\n                !resolvingServices.containsKey(service.serviceName) && // Check if already resolving\n                 !_discoveredHosts.value.any { it.serviceName == service.serviceName } // Check if already discovered and resolved\n            ) {\n                log(\"Attempting to resolve service: ${service.serviceName}\")\n                resolvingServices[service.serviceName] = true // Mark as resolving\n                resolveNsdService(service) // Trigger resolution\n            } else {\n                 log(\"Ignoring found service: Type mismatch (${service.serviceType}), self-discovery, already resolving, or already resolved.\")\n            }\n        }\n\n        override fun onServiceLost(service: NsdServiceInfo) {\n            log(\"NSD service lost: ${service.serviceName}\")\n            // Update UI on Main thread\n            viewModelScope.launch(Dispatchers.Main) {\n                _discoveredHosts.update { list ->\n                    list.filterNot { it.serviceName == service.serviceName }\n                }\n            }\n            resolvingServices.remove(service.serviceName) // Remove from resolving tracker\n        }\n\n        override fun onDiscoveryStopped(serviceType: String) { log(\"NSD discovery stopped for type: $serviceType\") }\n\n        override fun onStartDiscoveryFailed(serviceType: String, errorCode: Int) {\n            logError(\"NSD discovery start failed: Error code $errorCode\")\n            viewModelScope.launch { _showError.emit(\"Failed to search for games (NSD Error $errorCode)\") }\n            discoveryListener = null // Clear listener if start fails\n        }\n\n        override fun onStopDiscoveryFailed(serviceType: String, errorCode: Int) {\n            logError(\"NSD discovery stop failed: Error code $errorCode\")\n            // Listener might still be attached? Try nullifying anyway.\n             discoveryListener = null\n        }\n    }\n    discoveryListener = listener // Store the listener\n\n    log(\"Client: Starting NSD discovery for type: $SERVICE_TYPE\")\n    try {\n        nsdManager?.discoverServices(SERVICE_TYPE, NsdManager.PROTOCOL_DNS_SD, discoveryListener!!)\n    } catch (e: Exception) {\n        logError(\"Exception starting NSD discovery\", e)\n        discoveryListener = null // Clear listener on exception\n         viewModelScope.launch { _showError.emit(\"Error starting network discovery.\") }\n    }\n}\n\n\n/** CLIENT: Resolves a discovered service to get host and port */\nprivate fun GameViewModel.resolveNsdService(serviceInfo: NsdServiceInfo) {\n    if (nsdManager == null) {\n        logError(\"Cannot resolve NSD service, NsdManager is null.\")\n        resolvingServices.remove(serviceInfo.serviceName)\n        return\n    }\n\n    val serviceName = serviceInfo.serviceName // Capture name for logging in callbacks\n    log(\"Resolving NSD service details for: $serviceName\")\n\n    // Use a try-catch block for the listener creation itself if needed, though less common\n    val listener = object : NsdManager.ResolveListener {\n        override fun onResolveFailed(failedServiceInfo: NsdServiceInfo, errorCode: Int) {\n            logError(\"NSD resolve failed for ${failedServiceInfo.serviceName}: Error code $errorCode\")\n            resolvingServices.remove(failedServiceInfo.serviceName) // Remove from tracker on failure\n            // Optionally remove from discoveredHosts if it was added prematurely? (Shouldn't be)\n        }\n\n        // Suppress deprecation for host property if supporting older APIs\n        @Suppress(\"DEPRECATION\")\n        override fun onServiceResolved(resolvedServiceInfo: NsdServiceInfo) {\n             if (resolvedServiceInfo.host == null || resolvedServiceInfo.port <= 0) {\n                  logError(\"NSD service resolved but host or port is invalid: ${resolvedServiceInfo.serviceName} - Host=${resolvedServiceInfo.host}, Port=${resolvedServiceInfo.port}\")\n                  resolvingServices.remove(resolvedServiceInfo.serviceName)\n                  // Remove from discovered list if it somehow got added\n                  viewModelScope.launch(Dispatchers.Main) {\n                       _discoveredHosts.update { list -> list.filterNot { it.serviceName == resolvedServiceInfo.serviceName } }\n                  }\n                  return // Don't add invalid service\n             }\n\n            log(\"NSD service RESOLVED: ${resolvedServiceInfo.serviceName} at ${resolvedServiceInfo.host}:${resolvedServiceInfo.port}\")\n            // Update the list on the Main thread\n            viewModelScope.launch(Dispatchers.Main) {\n                _discoveredHosts.update { currentList ->\n                    val existingIndex = currentList.indexOfFirst { it.serviceName == resolvedServiceInfo.serviceName }\n                    if (existingIndex != -1) {\n                        // Update existing entry with potentially more complete info\n                        currentList.toMutableList().apply { set(existingIndex, resolvedServiceInfo) }\n                    } else {\n                        // Add new resolved entry\n                        currentList + resolvedServiceInfo\n                    }\n                    // Sort list? Maybe alphabetically?\n                    // .sortedBy { it.serviceName }\n                }\n            }\n            resolvingServices.remove(resolvedServiceInfo.serviceName) // Remove from tracker on success\n        }\n    }\n\n    try {\n        // Call resolveService using the created listener\n        nsdManager?.resolveService(serviceInfo, listener)\n    } catch (e: Exception) {\n        logError(\"Exception calling resolveService for $serviceName\", e)\n        resolvingServices.remove(serviceName) // Remove from tracker on exception during the call\n    }\n}\n\n\n/** CLIENT: Stops NSD discovery */\nfun GameViewModel.stopNsdDiscovery() {\n    if (isHost || nsdManager == null || discoveryListener == null) {\n        log(\"Client: Skipping NSD stop (not client, manager null, or listener null).\")\n        return\n    }\n\n    val listenerToStop = discoveryListener // Capture current listener\n    discoveryListener = null // Nullify immediately\n\n    log(\"Client: Stopping NSD discovery...\")\n    try {\n        nsdManager?.stopServiceDiscovery(listenerToStop)\n    } catch (e: IllegalArgumentException) {\n        // This often means it was already stopped or never started successfully\n        log(\"NSD Discovery likely already stopped: ${e.message}\")\n    } catch (e: Exception) {\n        logError(\"Error stopping NSD discovery\", e)\n    } finally {\n        // Clear list and tracker when explicitly stopping discovery\n        viewModelScope.launch(Dispatchers.Main) {\n            _discoveredHosts.value = emptyList()\n        }\n        resolvingServices.clear()\n    }\n}",
                "network": {
                    "NetworkModels.kt": "package com.example.mindikot.ui.viewmodel.network\n\nimport com.example.mindikot.core.state.GameState\nimport com.example.mindikot.core.model.Card\nimport com.example.mindikot.core.engine.GameEngine\n\n/** Defines the type of message being sent over the network. */\nenum class MessageType {\n    ASSIGN_ID,           // Server -> Client: {data: Int}\n    GAME_STATE_UPDATE,   // Server -> Client: {data: GameState}\n    PLAYER_ACTION,       // Client -> Server: {data: Card or GameEngine.Decision}\n    PLAYER_NAME,         // Client -> Server: {data: String}\n    ERROR,               // Server -> Client: {data: String}\n    DISCONNECTED,        // Server -> Client: Player ID disconnected {data: Int} - Informational\n    LOBBY_FULL,          // Server -> Client: {data: String} - When connection is rejected\n    KICKED               // Server -> Client: {data: String} - When explicitly removed\n    // Consider: ROUND_RESULT, GAME_OVER, KEEP_ALIVE, REQUEST_STATE (Client requesting full update)\n}\n\n/** Represents a message sent between the host and clients. */\ndata class NetworkMessage(\n    val type: MessageType,\n    val data: Any? = null // Requires careful serialization/deserialization\n)"
                },
                "utils": {
                    "GameViewModelUtils.kt": "package com.example.mindikot.ui.viewmodel.utils\n\nimport com.example.mindikot.ui.viewmodel.GameViewModel\nimport java.net.InetAddress\nimport java.net.NetworkInterface\nimport android.util.Log // Use Android's Log for better debugging/filtering\n\n// --- Logging ---\nfun GameViewModel.log(message: String, tag: String = \"GameViewModel\") {\n    // println(\"[$tag] $message\") // Use Android Log instead\n    Log.d(tag, message)\n}\n\nfun GameViewModel.logError(message: String, error: Throwable? = null, tag: String = \"GameViewModel\") {\n    // val errorMsg = error?.message?.let { \": $it\" } ?: \"\"\n    // println(\"[GameViewModel ERROR] $message$errorMsg\") // Use Android Log instead\n    Log.e(tag, message, error)\n}\n\n\n// --- Network Utility ---\n/** Gets the local IP address (needs refinement for robustness) */\nfun GameViewModel.getLocalIpAddress(): InetAddress? {\n    // This is a basic implementation. Consider libraries or more checks for complex networks.\n    return try {\n        val interfaces = NetworkInterface.getNetworkInterfaces()?.toList()\n        interfaces\n            ?.flatMap { intf ->\n                intf.inetAddresses?.toList()?.filter { addr ->\n                    !addr.isLoopbackAddress &&\n                            addr is java.net.Inet4Address &&\n                            // Prioritize common private ranges, adjust if needed for other network types\n                            // Check for common private IPv4 ranges\n                            (addr.isSiteLocalAddress || // Covers 10.x.x.x, 172.16-31.x.x, 192.168.x.x\n                             addr.hostAddress?.startsWith(\"192.168.\") == true) // Explicit check often reliable for WiFi\n                } ?: emptyList()\n            }\n            // Prioritize addresses starting with 192.168. as they are most common for local WiFi\n            ?.sortedByDescending { it.hostAddress?.startsWith(\"192.168.\") == true }\n            ?.firstOrNull()\n    } catch (e: Exception) {\n        logError(\"Could not determine local IP address\", e)\n        null\n    }\n}"
                }
            }
        }
    }
}