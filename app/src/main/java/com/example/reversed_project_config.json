{
    "project_name": "mindikot",
    "structure": {
        "core": {
            "engine": {
                "DeckGenerator.kt": "package com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\n\nobject DeckGenerator {\n    /**\n     * Generates a standard Mindikot deck. For 6 players, Twos are excluded.\n     * @param numPlayers The number of players (4 or 6).\n     * @return A shuffled list of cards for the game.\n     */\n    fun generateDeck(numPlayers: Int): MutableList<Card> {\n        require(numPlayers == 4 || numPlayers == 6) { \"Mindikot supports 4 or 6 players only.\" }\n        val includeTwos = (numPlayers == 4)\n\n        val deck = mutableListOf<Card>()\n        val allSuits = Suit.values()\n        val allRanks = Rank.values()\n\n        for (suit in allSuits) {\n            for (rank in allRanks) {\n                // Skip Twos if playing with 6 players\n                if (!includeTwos && rank == Rank.TWO) {\n                    continue\n                }\n                deck.add(Card(suit, rank))\n            }\n        }\n        // Shuffle the generated deck thoroughly before returning\n        return deck.shuffled().toMutableList()\n    }\n}\n",
                "GameEngine.kt": "package com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\nimport com.example.mindikot.core.state.GameState\nimport com.example.mindikot.core.state.InputType\n\n/**\n * Manages the core game flow, including playing tricks and handling state transitions. NOTE: This\n * implementation outlines the logic flow. A real implementation would need mechanisms (like\n * callbacks, suspend functions, or StateFlow) to handle asynchronous player input from the\n * UI/ViewModel layer. The points requiring input are marked.\n */\nobject GameEngine {\n\n    /**\n     * Determines the set of cards a player can legally play on their turn.\n     *\n     * @param playerHand The list of cards currently in the player's hand.\n     * @param currentTrickPlays The list of (Player, Card) pairs already played in the current\n     * trick.\n     * @param trumpSuit The current trump suit (null if not set).\n     * @param trumpRevealed Whether trump has been revealed.\n     * @return A list of cards from the player's hand that are valid to play.\n     */\n    fun determineValidMoves(\n            playerHand: List<Card>,\n            currentTrickPlays: List<Pair<Player, Card>>,\n            trumpSuit: Suit?,\n            trumpRevealed: Boolean\n    ): List<Card> {\n\n        // If player is leading the trick (no cards played yet)\n        if (currentTrickPlays.isEmpty()) {\n            return playerHand // Can lead any card\n        }\n\n        val leadCard = currentTrickPlays.first().second\n        val leadSuit = leadCard.suit\n\n        // Check if player can follow the lead suit\n        val cardsInLeadSuit = playerHand.filter { it.suit == leadSuit }\n        if (cardsInLeadSuit.isNotEmpty()) {\n            return cardsInLeadSuit // Must follow suit\n        }\n\n        // --- Cannot follow suit ---\n\n        // Check if trump is revealed and active\n        if (trumpRevealed && trumpSuit != null) {\n            // Rule: If cannot follow suit and trump is set, play ANY card.\n            return playerHand\n        } else {\n            // Rule: If cannot follow suit and trump is NOT set, play ANY card.\n            // The decision to CHOOSE/REVEAL/PASS happens separately.\n            // Special case: Mode B Reveal requires trump play if possible AFTER reveal.\n            // This function determines playable cards BEFORE that decision point.\n            return playerHand\n        }\n    }\n\n    // --- Interaction State Management Functions ---\n\n    /**\n     * Prepares the game state to request input from the appropriate player. This should be called\n     * at the start of a trick or after a player has played.\n     *\n     * @param state The current GameState to modify.\n     * @param playerIndex The index of the player whose turn it is.\n     * @return The modified GameState with updated input requirements.\n     */\n    fun requestInput(state: GameState, playerIndex: Int): GameState {\n        val currentPlayer = state.players[playerIndex]\n\n        if (state.currentTrickPlays.isEmpty()) { // Leading the trick\n            state.requiredInputType = InputType.PLAY_CARD\n        } else {\n            val leadSuit = state.currentTrickPlays.first().second.suit\n            val canFollowSuit = currentPlayer.hand.any { it.suit == leadSuit }\n\n            if (canFollowSuit) {\n                state.requiredInputType = InputType.PLAY_CARD\n            } else { // Cannot follow suit\n                if (state.trumpRevealed) {\n                    state.requiredInputType = InputType.PLAY_CARD // Play any card\n                } else { // Trump not revealed - need trump decision\n                    when (state.gameMode) {\n                        GameMode.CHOOSE_WHEN_EMPTY ->\n                                state.requiredInputType =\n                                        InputType.CHOOSE_TRUMP_SUIT // Player must play card to set\n                        // trump\n                        GameMode.FIRST_CARD_HIDDEN ->\n                                state.requiredInputType =\n                                        InputType.REVEAL_OR_PASS // Player chooses Reveal or Pass\n                    }\n                }\n            }\n        }\n        state.awaitingInputFromPlayerIndex = playerIndex\n        println(\n                \"GameEngine: Requesting ${state.requiredInputType} from Player ${state.players[playerIndex].name}\"\n        ) // Logging\n        return state\n    }\n\n    /**\n     * Processes the input received from a player (card played or trump decision). Validates the\n     * input against the rules and current state. Advances the game state (plays card, sets trump,\n     * finishes trick/round).\n     *\n     * @param currentState The current state of the game.\n     * @param playerInput The input received from the player (e.g., Card object, Decision enum).\n     * @return An updated GameState. The state might indicate further input is needed from the next\n     * player, or that the round/game ended.\n     */\n    fun processPlayerInput(\n            currentState: GameState,\n            playerInput:\n                    Any // Could be Card, Decision (Reveal/Pass), Suit (for potential future Mode A\n            // choice)\n            ): GameState {\n\n        val playerIndex =\n                currentState.awaitingInputFromPlayerIndex\n                        ?: run {\n                            println(\"Error: processPlayerInput called when no input was expected.\")\n                            return currentState // Or throw error\n                        }\n        val currentPlayer = currentState.players[playerIndex]\n        val currentRequirement = currentState.requiredInputType\n\n        println(\n                \"GameEngine: Processing input from Player ${currentPlayer.name}, expected: $currentRequirement, received: $playerInput\"\n        ) // Logging\n\n        // --- Validate and Process Input ---\n        when (currentRequirement) {\n            InputType.CHOOSE_TRUMP_SUIT -> {\n                // Mode A: Expecting a Card to be played which sets the trump\n                val playedCard = playerInput as? Card\n                if (playedCard == null || !currentPlayer.hand.contains(playedCard)) {\n                    println(\"Error: Invalid card provided for CHOOSE_TRUMP_SUIT.\")\n                    return currentState // Re-request input\n                }\n                // Validate it's a valid play (must be unable to follow suit)\n                val leadSuit = currentState.currentTrickPlays.firstOrNull()?.second?.suit\n                if (leadSuit != null && currentPlayer.hand.any { it.suit == leadSuit }) {\n                    println(\"Error: Player could follow suit, should not be choosing trump.\")\n                    return currentState // State logic error or invalid input sequence\n                }\n\n                TrumpHandler.setTrumpFromPlayedCard(currentState, playedCard)\n                playCard(currentState, currentPlayer, playedCard) // Play the card\n            }\n            InputType.REVEAL_OR_PASS -> {\n                // Mode B: Expecting a Decision (Reveal or Pass)\n                when (playerInput as? Decision) {\n                    Decision.REVEAL -> {\n                        TrumpHandler.revealHiddenTrump(currentState)\n                        // Now need player to play (Must play trump if possible)\n                        currentState.requiredInputType = InputType.PLAY_CARD\n                        currentState.awaitingInputFromPlayerIndex =\n                                playerIndex // Still this player's turn\n                        println(\n                                \"GameEngine: Player revealed trump. Requesting card play (must play trump if possible).\"\n                        )\n                        return currentState // Request card input with reveal constraint\n                    }\n                    Decision.PASS -> {\n                        TrumpHandler.handleTrumpPass(currentState)\n                        // Player plays ANY card\n                        currentState.requiredInputType = InputType.PLAY_CARD\n                        currentState.awaitingInputFromPlayerIndex =\n                                playerIndex // Still this player's turn\n                        println(\"GameEngine: Player passed trump. Requesting any card play.\")\n                        return currentState // Request card input (any card valid)\n                    }\n                    else -> {\n                        println(\"Error: Invalid decision provided for REVEAL_OR_PASS.\")\n                        return currentState // Re-request input\n                    }\n                }\n            }\n            InputType.PLAY_CARD -> {\n                val playedCard = playerInput as? Card\n                if (playedCard == null || !currentPlayer.hand.contains(playedCard)) {\n                    println(\"Error: Invalid card provided for PLAY_CARD.\")\n                    return currentState // Re-request input\n                }\n\n                // --- Complex Validation for PLAY_CARD ---\n                val leadSuit = currentState.currentTrickPlays.firstOrNull()?.second?.suit\n                val canFollowSuit =\n                        if (leadSuit != null) currentPlayer.hand.any { it.suit == leadSuit }\n                        else false\n\n                // 1. Must follow suit if possible?\n                if (leadSuit != null && playedCard.suit != leadSuit && canFollowSuit) {\n                    println(\n                            \"Error: Player must follow suit $leadSuit but played ${playedCard.suit}.\"\n                    )\n                    return currentState // Re-request input\n                }\n\n                // 2. Mode B Post-Reveal Constraint: Must play trump if revealed and possible?\n                // Need a way to know if this PLAY_CARD followed a REVEAL action in the same turn\n                // cycle...\n                // This architecture makes tracking that tricky. A state machine or temporary flag\n                // might be needed.\n                // Assuming for now the UI/ViewModel layer handles this constraint check *before*\n                // sending.\n\n                // If validation passes:\n                playCard(currentState, currentPlayer, playedCard)\n            }\n            null -> {\n                println(\"Error: processPlayerInput called when requiredInputType is null.\")\n                return currentState\n            }\n        }\n\n        // --- Post-Play State Update ---\n        currentState.requiredInputType = null // Reset requirement after successful processing\n        currentState.awaitingInputFromPlayerIndex = null // Clear awaiting player\n\n        // Check if trick is complete\n        if (currentState.currentTrickPlays.size == currentState.players.size) {\n            finishTrick(\n                    currentState\n            ) // Determine winner, collect cards, update tricksWon, set next leader\n\n            // Check if round ended (hands are empty)\n            if (currentState.players.first().hand.isEmpty()) {\n                println(\"GameEngine: Round finished.\")\n                // --- End of Round ---\n                // Caller (ViewModel) should check hand size and call RoundEvaluator\n                // and handle scoring/next round setup.\n            } else {\n                // Start next trick by requesting input from the new leader\n                return requestInput(currentState, currentState.currentLeaderIndex)\n            }\n        } else {\n            // Trick continues, request input from the next player\n            val nextPlayerIndex = (playerIndex + 1) % currentState.players.size\n            return requestInput(currentState, nextPlayerIndex)\n        }\n\n        return currentState // Return the final state after processing\n    }\n\n    /** Helper to add card to trick plays and remove from hand */\n    private fun playCard(state: GameState, player: Player, card: Card) {\n        state.currentTrickPlays.add(player to card)\n        player.hand.remove(card)\n        println(\"GameEngine: Player ${player.name} played ${card}\") // Logging\n    }\n\n    /** Called when a trick is complete to determine winner and collect cards. */\n    private fun finishTrick(state: GameState) {\n        println(\"GameEngine: Trick finished. Plays: ${state.currentTrickPlays.map { it.second }}\")\n        val winnerPlayer =\n                TrickHandler.determineTrickWinner(state.currentTrickPlays, state.trumpSuit)\n        val winnerIndex = state.players.indexOf(winnerPlayer)\n        println(\"GameEngine: Trick winner: ${winnerPlayer.name}\") // Logging\n\n        // Collect cards for the winning team\n        val winningTeam =\n                state.teams.first {\n                    it.id == winnerPlayer.teamId\n                } // Assuming player.teamId is correct\n        winningTeam.collectedCards.addAll(state.currentTrickPlays.map { it.second })\n        // println(\"Team ${winningTeam.id} collected cards. Total tens: ${winningTeam.countTens()}\")\n        // // Logging\n\n        // --- Update trick count ---\n        val currentTrickCount = state.tricksWon.getOrDefault(winningTeam.id, 0)\n        state.tricksWon[winningTeam.id] = currentTrickCount + 1 // Increment trick count\n        println(\n                \"GameEngine: Team ${winningTeam.id} tricks won this round: ${state.tricksWon[winningTeam.id]}\"\n        ) // Logging trick count\n\n        // Clear trick plays and set next leader\n        state.currentTrickPlays.clear()\n        state.currentLeaderIndex = winnerIndex\n\n        // Reset input requirement for the start of the next trick\n        // The requestInput function will be called next, setting the specific input type.\n        state.requiredInputType = null\n        state.awaitingInputFromPlayerIndex = null\n    }\n\n    // Enum for Reveal/Pass decision\n    enum class Decision {\n        REVEAL,\n        PASS\n    }\n}\n",
                "RoundEvaluator.kt": "package com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\nimport com.example.mindikot.core.state.GameState\n\nobject RoundEvaluator {\n\n    /**\n     * Data class to hold the result of a round evaluation.\n     * @property winningTeam The team that won the round (can be null if draw).\n     * @property isKot True if the win was due to collecting all four Tens.\n     */\n    data class RoundResult(val winningTeam: Team?, val isKot: Boolean)\n\n    /**\n     * Evaluates the end of a round: checks for Kot, then majority of tens, then trick tie-breaker.\n     *\n     * @param state The final GameState at the end of the round.\n     * @return RoundResult indicating the winning team (or null for draw) and whether it was a Kot\n     * win.\n     */\n    fun evaluateRound(state: GameState): RoundResult {\n        val teams = state.teams\n        println(\"Evaluating round end...\") // Logging\n\n        // 1. Instant Kot Check\n        teams.find { it.hasKot() }?.let {\n            println(\"Team ${it.id} wins round by KOT!\") // Logging\n            return RoundResult(it, true)\n        }\n\n        // 2. Count Tens for each team\n        val teamTensCount = teams.associate { team -> team.id to team.countTens() }\n        println(\"Tens collected: $teamTensCount\") // Logging\n\n        // 3. Determine Team with Most Tens\n        val maxTens = teamTensCount.values.maxOrNull() ?: 0\n        val teamsWithMaxTensIds = teamTensCount.filterValues { it == maxTens }.keys\n\n        // 4. Handle Winner Determination\n        if (teamsWithMaxTensIds.size == 1) {\n            // One team has clear majority of tens\n            val winningTeamId = teamsWithMaxTensIds.first()\n            val winningTeam = teams.first { it.id == winningTeamId }\n            println(\n                    \"Team ${winningTeam.id} wins round with majority of tens ($maxTens).\"\n            ) // Logging\n            return RoundResult(winningTeam, false) // Not Kot\n        } else if (teamsWithMaxTensIds.size > 1) {\n            // Tie in tens - apply trick tie-breaker\n            println(\"Tie in tens ($maxTens each). Applying trick tie-breaker.\") // Logging\n            val teamTricksWon = state.tricksWon // Get tricks won map from GameState\n            val tiedTeamsTrickCounts = teamTricksWon.filterKeys { it in teamsWithMaxTensIds }\n            println(\"Tricks won by tied teams: $tiedTeamsTrickCounts\") // Logging\n\n            val maxTricks =\n                    tiedTeamsTrickCounts.values.maxOrNull()\n                            ?: -1 // Use -1 to detect no tricks won case\n            val teamsWithMaxTricks = tiedTeamsTrickCounts.filterValues { it == maxTricks }.keys\n\n            if (teamsWithMaxTricks.size == 1) {\n                // One team won more tricks among the tied teams\n                val winningTeamId = teamsWithMaxTricks.first()\n                val winningTeam = teams.first { it.id == winningTeamId }\n                println(\n                        \"Team ${winningTeam.id} wins round due to trick tie-breaker ($maxTricks tricks).\"\n                ) // Logging\n                return RoundResult(winningTeam, false) // Not Kot\n            } else {\n                // Still tied (same number of tens AND same number of tricks) -> Draw\n                println(\"Round is a DRAW (tied tens and tricks).\") // Logging\n                return RoundResult(null, false) // Indicate draw\n            }\n        } else {\n            // Should not happen if there are teams, means no tens collected by anyone? Treat as\n            // draw.\n            println(\n                    \"Round evaluation resulted in no winner (possibly no tens collected). Treating as Draw.\"\n            ) // Logging\n            return RoundResult(null, false)\n        }\n    }\n}\n",
                "TrickHandler.kt": "package com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\n\nobject TrickHandler {\n    /**\n     * Determines the winner of a completed trick based on Mindikot rules.\n     *\n     * @param playedCards A list of (Player, Card) pairs representing the cards played in the trick,\n     * in order.\n     * @param trumpSuit The active trump suit for the round (can be null if trump is not set).\n     * @return The Player who won the trick.\n     */\n    fun determineTrickWinner(playedCards: List<Pair<Player, Card>>, trumpSuit: Suit?): Player {\n        require(playedCards.isNotEmpty()) { \"Cannot determine winner of an empty trick.\" }\n\n        val leadSuit = playedCards.first().second.suit\n        // var winningPlay: Pair<Player, Card> = playedCards.first() // Assume leader wins initially\n        var winningPlay: Pair<Player, Card>\n\n        // Check for highest trump card first\n        val trumpPlays = playedCards.filter { it.second.suit == trumpSuit && trumpSuit != null }\n        if (trumpPlays.isNotEmpty()) {\n            winningPlay = trumpPlays.maxByOrNull { it.second.rank.value }!!\n        } else {\n            // No trump played, check for highest card of the lead suit\n            val leadSuitPlays = playedCards.filter { it.second.suit == leadSuit }\n            // We know leadSuitPlays is not empty because the leader played one.\n            winningPlay = leadSuitPlays.maxByOrNull { it.second.rank.value }!!\n        }\n\n        return winningPlay.first // Return the winning player\n    }\n}\n",
                "TrumpHandler.kt": "package com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.state.GameState\n\n/**\n * Contains simple helper functions to update the game state related to trump setting. These\n * functions are intended to be called by the GameEngine AFTER a player has made their trump-related\n * decision via external input (UI/ViewModel).\n */\nobject TrumpHandler {\n\n    /**\n     * Updates the game state when a player chooses a trump suit in CHOOSE_WHEN_EMPTY mode by\n     * playing a card that establishes the trump. Precondition: state.trumpRevealed should be false.\n     *\n     * @param state The current GameState to modify.\n     * @param cardPlayed The card whose suit sets the trump.\n     */\n    fun setTrumpFromPlayedCard(state: GameState, cardPlayed: com.example.mindikot.core.model.Card) {\n        if (!state.trumpRevealed) {\n            state.trumpSuit = cardPlayed.suit\n            state.trumpRevealed = true\n            println(\n                    \"TrumpHandler: Trump set to ${state.trumpSuit} by card ${cardPlayed}\"\n            ) // Logging\n        }\n    }\n\n    /**\n     * Updates the game state when a player chooses to reveal the hidden card in FIRST_CARD_HIDDEN\n     * mode. Precondition: state.trumpRevealed should be false and state.hiddenCard should not be\n     * null.\n     *\n     * @param state The current GameState to modify.\n     */\n    fun revealHiddenTrump(state: GameState) {\n        if (!state.trumpRevealed &&\n                        state.hiddenCard != null &&\n                        state.gameMode == com.example.mindikot.core.model.GameMode.FIRST_CARD_HIDDEN\n        ) {\n            state.trumpSuit = state.hiddenCard!!.suit // Set trump to hidden card's suit\n            state.trumpRevealed = true\n            println(\n                    \"TrumpHandler: Trump revealed as ${state.trumpSuit} from hidden card\"\n            ) // Logging\n            // Note: GameEngine must enforce the special play rule for this turn.\n        }\n    }\n\n    /**\n     * Placeholder function to acknowledge the \"Pass\" action in FIRST_CARD_HIDDEN mode. No state\n     * change is needed regarding trump itself.\n     *\n     * @param state The current GameState (not modified here).\n     */\n    fun handleTrumpPass(state: GameState) {\n        // No change to state.trumpSuit or state.trumpRevealed.\n        println(\"TrumpHandler: Player chose to Pass.\") // Logging\n        // GameEngine allows the player to play any card for this trick.\n    }\n}\n"
            },
            "main.py": "from pathlib import Path\n\n# base_dir = Path(\"/mnt/data/mindikot/src/main/java/com/example/mindikot/core\")\nbase_dir = Path(\"src/main/java/com/example/mindikot/core\")\n\n# All file paths relative to base_dir with updated content\nupdated_files_content = {\n    \"model/Card.kt\": \"\"\"\npackage com.example.mindikot.core.model\n\ndata class Card(val suit: Suit, val rank: Rank) {\n    override fun toString(): String = \"${'$'}rank of ${'$'}suit\"\n}\n\"\"\",\n    \"model/Suit.kt\": \"\"\"\npackage com.example.mindikot.core.model\n\nenum class Suit {\n    HEARTS, DIAMONDS, CLUBS, SPADES\n}\n\"\"\",\n    \"model/Rank.kt\": \"\"\"\npackage com.example.mindikot.core.model\n\nenum class Rank(val value: Int) {\n    THREE(3), FOUR(4), FIVE(5), SIX(6), SEVEN(7), EIGHT(8), NINE(9),\n    TEN(10), JACK(11), QUEEN(12), KING(13), ACE(14)\n}\n\"\"\",\n    \"model/Player.kt\": \"\"\"\npackage com.example.mindikot.core.model\n\ndata class Player(val id: Int, val name: String, val teamId: Int, val hand: MutableList<Card> = mutableListOf()) {\n    override fun toString() = \"Player(id=${'$'}id, name=${'$'}name, team=${'$'}teamId)\"\n}\n\"\"\",\n    \"model/Team.kt\": \"\"\"\npackage com.example.mindikot.core.model\n\ndata class Team(val id: Int, val players: List<Player>, val collectedCards: MutableList<Card> = mutableListOf()) {\n    fun countTens(): Int = collectedCards.count { it.rank == Rank.TEN }\n    fun hasKot(): Boolean = countTens() == 4\n}\n\"\"\",\n    \"model/GameMode.kt\": \"\"\"\npackage com.example.mindikot.core.model\n\nenum class GameMode {\n    CHOOSE_WHEN_EMPTY,\n    FIRST_CARD_HIDDEN\n}\n\"\"\",\n    \"engine/DeckGenerator.kt\": \"\"\"\npackage com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\n\nobject DeckGenerator {\n    fun generateDeck(includeTwos: Boolean): MutableList<Card> {\n        val deck = mutableListOf<Card>()\n        for (suit in Suit.values()) {\n            for (rank in Rank.values()) {\n                if (!includeTwos && rank == Rank.THREE) continue\n                deck.add(Card(suit, rank))\n            }\n        }\n        return deck.shuffled().toMutableList()\n    }\n}\n\"\"\",\n    \"engine/TrickHandler.kt\": \"\"\"\npackage com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\n\nobject TrickHandler {\n    fun determineTrickWinner(playedCards: List<Pair<Player, Card>>, trumpSuit: Suit?): Player {\n        val leadSuit = playedCards.first().second.suit\n        val validCards = playedCards.map { (player, card) ->\n            val score = when {\n                card.suit == trumpSuit -> card.rank.value + 100\n                card.suit == leadSuit -> card.rank.value\n                else -> 0\n            }\n            Triple(player, card, score)\n        }\n        return validCards.maxBy { it.third }.first\n    }\n}\n\"\"\",\n    \"engine/TrumpHandler.kt\": \"\"\"\npackage com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\n\nobject TrumpHandler {\n    fun chooseTrumpFromHand(player: Player): Suit {\n        return player.hand.groupingBy { it.suit }.eachCount().maxBy { it.value }.key\n    }\n}\n\"\"\",\n    \"engine/RoundEvaluator.kt\": \"\"\"\npackage com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\n\nobject RoundEvaluator {\n    data class RoundResult(val winningTeam: Team, val isKot: Boolean)\n\n    fun evaluateRound(teams: List<Team>): RoundResult {\n        val teamWithKot = teams.find { it.hasKot() }\n        return if (teamWithKot != null) {\n            RoundResult(teamWithKot, true)\n        } else {\n            val team = teams.maxBy { it.countTens() }\n            RoundResult(team, false)\n        }\n    }\n}\n\"\"\",\n    \"engine/GameEngine.kt\": \"\"\"\npackage com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\nimport com.example.mindikot.core.state.GameState\n\nobject GameEngine {\n    fun playTrick(state: GameState, leaderIndex: Int): Int {\n        val trickCards = mutableListOf<Pair<Player, Card>>()\n        val players = state.players\n        val trumpSuit = state.trumpSuit\n\n        for (i in 0 until players.size) {\n            val currentPlayer = players[(leaderIndex + i) % players.size]\n            val playableCard = currentPlayer.hand.removeAt(0)\n            trickCards.add(currentPlayer to playableCard)\n        }\n\n        val winner = TrickHandler.determineTrickWinner(trickCards, trumpSuit)\n        val team = state.teams.first { it.id == winner.teamId }\n        team.collectedCards.addAll(trickCards.map { it.second })\n\n        return players.indexOf(winner)\n    }\n}\n\"\"\",\n    \"state/GameState.kt\": \"\"\"\npackage com.example.mindikot.core.state\n\nimport com.example.mindikot.core.model.*\n\ndata class GameState(\n    val players: List<Player>,\n    val teams: List<Team>,\n    val gameMode: GameMode,\n    var trumpSuit: Suit? = null,\n    var hiddenTrumpCard: Card? = null\n)\n\"\"\"\n}\n\n# Write each updated file\nfor relative_path, content in updated_files_content.items():\n    path = base_dir / relative_path\n    path.parent.mkdir(parents=True, exist_ok=True)\n    path.write_text(content.strip())\n\n\"\u00e2\u0153\u2026 All specified files were created/updated with actual logic.\"\n",
            "model": {
                "Card.kt": "package com.example.mindikot.core.model\n\ndata class Card(val suit: Suit, val rank: Rank) {\n    override fun toString(): String = \"${rank.displayName} of ${suit}\"\n}\n",
                "GameMode.kt": "package com.example.mindikot.core.model\n\nenum class GameMode {\n    CHOOSE_WHEN_EMPTY,\n    FIRST_CARD_HIDDEN\n}\n",
                "Player.kt": "package com.example.mindikot.core.model\n\ndata class Player(\n    val id: Int,\n    val name: String,\n    val teamId: Int,\n    var hand: MutableList<Card> = mutableListOf()\n) {\n    override fun toString() = \"Player(id=$id, name=$name, team=$teamId)\"\n}\n",
                "Rank.kt": "package com.example.mindikot.core.model\n\nenum class Rank(val value: Int, val displayName: String) {\n    TWO(2, \"2\"),\n    THREE(3, \"3\"),\n    FOUR(4, \"4\"),\n    FIVE(5, \"5\"),\n    SIX(6, \"6\"),\n    SEVEN(7, \"7\"),\n    EIGHT(8, \"8\"),\n    NINE(9, \"9\"),\n    TEN(10, \"10\"),\n    JACK(11, \"J\"),\n    QUEEN(12, \"Q\"),\n    KING(13, \"K\"),\n    ACE(14, \"A\")\n}\n",
                "Suit.kt": "package com.example.mindikot.core.model\n\nenum class Suit {\n    HEARTS, DIAMONDS, CLUBS, SPADES\n}\n",
                "Team.kt": "package com.example.mindikot.core.model\n\ndata class Team(\n    val id: Int,\n    val players: List<Player>,\n    val collectedCards: MutableList<Card> = mutableListOf()\n) {\n    fun countTens(): Int = collectedCards.count { it.rank == Rank.TEN }\n    fun hasKot(): Boolean = countTens() == 4\n}\n"
            },
            "state": {
                "GameState.kt": "package com.example.mindikot.core.state\n\nimport com.example.mindikot.core.model.*\n\n/**\n * Represents the complete state of the Mindikot game at any point in time. This object should be\n * immutable or handled carefully to ensure state consistency, especially when shared across network\n * or threads. Consider using immutable data structures if concurrency becomes complex.\n *\n * @property players List of all players participating in the game.\n * @property teams List of the teams, typically containing references to their players and collected\n * cards.\n * @property gameMode The selected mode for trump determination (e.g., CHOOSE_WHEN_EMPTY,\n * FIRST_CARD_HIDDEN).\n * @property requiredPlayers The number of players required for the game 4 or 6.\n * @property currentLeaderIndex The index (in the `players` list) of the player who leads the\n * current or next trick.\n * @property trumpSuit The suit designated as trump for the current round. Null if trump has not\n * been set yet.\n * @property trumpRevealed Boolean flag indicating whether the trump suit has been determined and\n * revealed for the current round.\n * @property hiddenCard In FIRST_CARD_HIDDEN mode, this holds the card set aside *before dealing*.\n * Null otherwise.\n * @property currentTrickPlays The cards played so far in the trick-in-progress. List<Pair<Player,\n * Card>>.\n * @property awaitingInputFromPlayerIndex Index of the player from whom input is currently awaited.\n * Null if the engine is processing or trick/round ended.\n * @property requiredInputType The type of input needed from the awaiting player.\n * @property tricksWon A map storing the number of tricks won by each team (TeamId -> Trick Count)\n * in the current round. Used for tie-breaking.\n */\ndata class GameState(\n        val players: List<Player>,\n        val teams: List<Team>,\n        val gameMode: GameMode,\n//        val requiredPlayers: Int, // <-- ADD THIS FIELD\n        var currentLeaderIndex: Int = 0,\n        var trumpSuit: Suit? = null,\n        var trumpRevealed: Boolean = false,\n        var hiddenCard: Card? = null, // Card set aside BEFORE dealing in FIRST_CARD_HIDDEN mode\n        val currentTrickPlays: MutableList<Pair<Player, Card>> =\n                mutableListOf(), // State of the current trick\n        var awaitingInputFromPlayerIndex: Int? = null, // Which player needs to act\n        var requiredInputType: InputType? = null, // What kind of action is needed\n        val tricksWon: MutableMap<Int, Int> =\n                mutableMapOf() // TeamId -> Trick Count for current round\n)\n\n/** Enum to represent the type of input currently required from a player. */\nenum class InputType {\n    PLAY_CARD, // Player needs to select a card to play\n    CHOOSE_TRUMP_SUIT, // Player needs to choose a trump suit by playing a card (Mode A)\n    REVEAL_OR_PASS // Player needs to decide Reveal or Pass (Mode B)\n}\n"
            }
        },
        "GameViewModel.kt": "package com.example.mindikot.ui // Adjust package if needed\n\nimport android.Manifest // Required for NSD permissions\nimport android.content.Context // Needed for NsdManager\nimport android.content.pm.PackageManager\nimport android.net.nsd.NsdManager\nimport android.net.nsd.NsdServiceInfo\nimport android.os.Build\nimport androidx.core.content.ContextCompat\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.ViewModelProvider\nimport androidx.lifecycle.viewModelScope\nimport com.example.mindikot.core.engine.DeckGenerator\nimport com.example.mindikot.core.engine.GameEngine\nimport com.example.mindikot.core.engine.RoundEvaluator\nimport com.example.mindikot.core.model.*\nimport com.example.mindikot.core.state.GameState\nimport com.example.mindikot.core.state.InputType\nimport com.google.gson.Gson\nimport com.google.gson.JsonSyntaxException\nimport java.io.BufferedReader\nimport java.io.InputStreamReader\nimport java.io.PrintWriter // Needed for sending messages\nimport java.net.InetAddress\nimport java.net.ServerSocket\nimport java.net.Socket // Needed for client connections\nimport java.util.concurrent.ConcurrentHashMap\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n// Add required permissions to AndroidManifest.xml:\n// <uses-permission android:name=\"android.permission.INTERNET\" />\n// <uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n// <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> // Good practice to\n// check network state\n// For NSD discovery/advertising:\n// <uses-permission android:name=\"android.permission.CHANGE_WIFI_MULTICAST_STATE\" />\n// For Android 12+ (API 31+) NSD requires location permission:\n// <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n// Or for just discovery:\n// <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\"/>\n\nclass GameViewModel(private val applicationContext: Context) : ViewModel() {\n\n    // --- Game State ---\n    private val _state = MutableStateFlow(createInitialEmptyGameState())\n    val state: StateFlow<GameState> = _state.asStateFlow()\n\n    // --- Navigation/Events ---\n    private val _navigateToResultScreen = MutableSharedFlow<RoundEvaluator.RoundResult>()\n    val navigateToResultScreen: SharedFlow<RoundEvaluator.RoundResult> =\n            _navigateToResultScreen.asSharedFlow()\n\n    private val _showError = MutableSharedFlow<String>()\n    val showError: SharedFlow<String> = _showError.asSharedFlow()\n\n    // --- Game/Network Setup ---\n    var isHost: Boolean = false\n        private set\n    var requiredPlayerCount: Int = 4\n        private set\n    var localPlayerId: Int = -1\n        private set\n\n    private val _connectedPlayersCount = MutableStateFlow(0)\n    val connectedPlayersCount: StateFlow<Int> = _connectedPlayersCount\n\n    private val _gameStarted = MutableStateFlow(false)\n    val gameStarted: StateFlow<Boolean> = _gameStarted\n\n    // --- Networking (Host) ---\n    private var serverSocket: ServerSocket? = null\n    private var servicePort: Int = 0 // *** DECLARED servicePort property ***\n        private set\n    var isServerRunning = false\n    private val clientSockets = ConcurrentHashMap<Int, Socket>()\n    private val clientWriters = ConcurrentHashMap<Int, PrintWriter>()\n    private val clientReaders = ConcurrentHashMap<Int, BufferedReader>()\n    private val clientJobs = ConcurrentHashMap<Int, Job>()\n\n    // --- Networking (Client) ---\n    private var clientSocket: Socket? = null\n    private var clientWriter: PrintWriter? = null\n    private var clientReader: BufferedReader? = null\n    private var clientReaderJob: Job? = null\n    private var isConnectedToServer = false\n\n    private var nsdManager: NsdManager? = null\n    // Keep registrationListener for host\n    private var registrationListener: NsdManager.RegistrationListener? = null\n    private var discoveryListener: NsdManager.DiscoveryListener? = null\n    private val SERVICE_TYPE = \"_mindikot._tcp\"\n    private var nsdServiceNameRegistered: String? = null\n\n    private val _discoveredHosts = MutableStateFlow<List<NsdServiceInfo>>(emptyList())\n    val discoveredHosts: StateFlow<List<NsdServiceInfo>> = _discoveredHosts.asStateFlow()\n\n    // Keep host IP state\n    private val _hostIpAddress = MutableStateFlow<String?>(null)\n    val hostIpAddress: StateFlow<String?> = _hostIpAddress.asStateFlow()\n\n    // Optional: Track services currently being resolved to prevent multiple attempts\n    private val resolvingServices = ConcurrentHashMap<String, Boolean>()\n\n    // --- Serialization ---\n    private val gson = Gson()\n\n    // --- Logging ---\n    private fun log(message: String, tag: String = \"GameViewModel\") {\n        println(\"[$tag] $message\")\n    }\n    private fun logError(message: String, error: Throwable? = null) {\n        val errorMsg = error?.message?.let { \": $it\" } ?: \"\"\n        println(\"[GameViewModel ERROR] $message$errorMsg\")\n    }\n\n    // ========================================================================\n    // HOST FUNCTIONS\n    // ========================================================================\n\n    /** HOST: Initializes the game settings (player slots, mode) */\n    fun initializeGameSettings(\n            playerName: String,\n            mode: GameMode,\n            host: Boolean = true,\n            playersNeeded: Int = 4\n    ) {\n        log(\n                \"Initializing game settings as Host. Name: $playerName, Mode: $mode, Players: $playersNeeded\"\n        )\n        isHost = host\n        requiredPlayerCount = playersNeeded\n        localPlayerId = 0\n\n        val players =\n                (0 until playersNeeded).map { i ->\n                    Player(\n                            id = i,\n                            name = if (i == 0) playerName else \"Waiting...\",\n                            teamId = (i % 2) + 1,\n                            hand = mutableListOf()\n                    )\n                }\n        val teams =\n                listOf(\n                        Team(id = 1, players = players.filter { it.teamId == 1 }),\n                        Team(id = 2, players = players.filter { it.teamId == 2 })\n                )\n\n        _state.value =\n                GameState(\n                        players = players,\n                        teams = teams,\n                        gameMode = mode,\n                        tricksWon = mutableMapOf(1 to 0, 2 to 0)\n                )\n        _connectedPlayersCount.value = 1\n        log(\"Initial GameState created for host setup.\")\n    }\n\n    /** HOST: Starts ServerSocket and NSD Registration */\n    fun startServerAndDiscovery(port: Int = 0) { // Port 0 lets OS pick free port\n        if (isServerRunning || !isHost) {\n            log(\"Server already running or not host. Aborting start.\")\n            return\n        }\n        log(\"Attempting to start server and NSD registration...\")\n        isServerRunning = true\n        viewModelScope.launch(Dispatchers.IO) {\n            var serverStarted = false\n            var nsdRegistered = false\n            try {\n                // 1. Start Server Socket\n                serverSocket = ServerSocket(port)\n                val actualPort = serverSocket!!.localPort\n                servicePort = actualPort // *** ASSIGN servicePort here ***\n                log(\"Server socket started successfully on port $actualPort.\")\n                serverStarted = true\n\n                // 2. Get Host IP for display\n                val localIp = getLocalIpAddress()\n                withContext(Dispatchers.Main) { _hostIpAddress.value = localIp?.hostAddress }\n                log(\"Host IP for display: ${localIp?.hostAddress ?: \"Not Found\"}\")\n\n                // 3. Register NSD Service (using the obtained 'actualPort')\n                if (registerNsdService(actualPort)) { // *** PASS actualPort ***\n                    nsdRegistered = true\n                } else {\n                    throw Exception(\"NSD Registration Failed\")\n                }\n\n                log(\"Server and NSD active. Waiting for ${requiredPlayerCount - 1} players...\")\n\n                // 4. Accept Client Connections Loop\n                while (clientSockets.size < requiredPlayerCount - 1 &&\n                        isServerRunning &&\n                        isActive) {\n                    val socket = serverSocket?.accept() ?: break\n                    val currentClientCount = clientSockets.size\n                    val assignedPlayerId = currentClientCount + 1\n\n                    log(\"Client connected, assigning Player ID $assignedPlayerId\")\n\n                    try {\n                        val writer = PrintWriter(socket.getOutputStream(), true)\n                        val reader = BufferedReader(InputStreamReader(socket.getInputStream()))\n\n                        clientSockets[assignedPlayerId] = socket\n                        clientWriters[assignedPlayerId] = writer\n                        clientReaders[assignedPlayerId] = reader\n\n                        sendMessageToClient(\n                                assignedPlayerId,\n                                NetworkMessage(MessageType.ASSIGN_ID, assignedPlayerId)\n                        )\n                        // Send current lobby state\n                        sendMessageToClient(\n                                assignedPlayerId,\n                                NetworkMessage(MessageType.GAME_STATE_UPDATE, _state.value)\n                        )\n\n                        listenToClient(assignedPlayerId, reader) // Start listening\n\n                        withContext(Dispatchers.Main.immediate) {\n                            _connectedPlayersCount.value = clientSockets.size + 1\n                        }\n                        log(\n                                \"Player ID $assignedPlayerId assigned. Connected: ${_connectedPlayersCount.value}/${requiredPlayerCount}\"\n                        )\n\n                        if (_connectedPlayersCount.value == requiredPlayerCount) {\n                            log(\"All players connected!\")\n                            prepareAndBroadcastInitialState()\n                        }\n                    } catch (e: Exception) {\n                        logError(\"Error during client setup (Player $assignedPlayerId)\", e)\n                        runCatching { socket.close() }\n                    }\n                } // End of accept loop\n                log(\"Stopped accepting connections (lobby full or server stopped).\")\n            } catch (e: Exception) {\n                if (isServerRunning) {\n                    logError(\"Server/NSD start failed or accept loop error\", e)\n                    withContext(Dispatchers.Main) {\n                        _showError.emit(\"Error starting host: ${e.message}\")\n                    }\n                }\n                withContext(Dispatchers.Main) {\n                    stopServerAndDiscovery()\n                } // Ensure cleanup on any error\n            } finally {\n                log(\"Server listener loop finished. isServerRunning=$isServerRunning\")\n                // No need to set isServerRunning = false here, stopServerAndDiscovery handles it\n            }\n        }\n    }\n\n    /**\n     * HOST: Registers the game service using NSD. Returns true on success request, false on\n     * immediate failure.\n     */\n    private fun registerNsdService(portToRegister: Int): Boolean { // *** Renamed parameter ***\n        if (registrationListener != null) {\n            log(\"NSD registration already in progress or completed. Unregistering first.\")\n            try {\n                nsdManager?.unregisterService(registrationListener)\n            } catch (e: Exception) {}\n            registrationListener = null\n            nsdServiceNameRegistered = null\n        }\n\n        nsdManager = applicationContext.getSystemService(Context.NSD_SERVICE) as NsdManager?\n        if (nsdManager == null) {\n            /* Error handling */\n            return false\n        }\n\n        registrationListener =\n                object : NsdManager.RegistrationListener {\n                    override fun onServiceRegistered(nsdServiceInfo: NsdServiceInfo) {\n                        nsdServiceNameRegistered = nsdServiceInfo.serviceName\n                        log(\n                                \"NSD Service registered: $nsdServiceNameRegistered on port $portToRegister\"\n                        ) // *** Use parameter ***\n                    }\n                    override fun onRegistrationFailed(serviceInfo: NsdServiceInfo, errorCode: Int) {\n                        logError(\n                                \"NSD registration failed for ${serviceInfo.serviceName}: Error $errorCode\"\n                        )\n                        viewModelScope.launch {\n                            _showError.emit(\"Failed to advertise game (Error $errorCode)\")\n                        }\n                        nsdServiceNameRegistered = null\n                    }\n                    override fun onServiceUnregistered(arg0: NsdServiceInfo) {\n                        log(\"NSD Service unregistered: ${arg0.serviceName}\")\n                        if (arg0.serviceName == nsdServiceNameRegistered) {\n                            nsdServiceNameRegistered = null\n                        }\n                    }\n                    override fun onUnregistrationFailed(\n                            serviceInfo: NsdServiceInfo,\n                            errorCode: Int\n                    ) {\n                        logError(\n                                \"NSD unregistration failed for ${serviceInfo.serviceName}: Error $errorCode\"\n                        )\n                    }\n                }\n\n        val baseName = \"Mindikot\"\n        val uniqueName = \"${baseName}_${(1000..9999).random()}\"\n        val serviceInfo =\n                NsdServiceInfo().apply {\n                    setServiceName(uniqueName)\n                    setServiceType(SERVICE_TYPE)\n                    setPort(portToRegister) // *** Use parameter ***\n                }\n\n        log(\"Attempting to register NSD service: $uniqueName on port $portToRegister\")\n        try {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\n                nsdManager?.registerService(\n                        serviceInfo,\n                        NsdManager.PROTOCOL_DNS_SD,\n                        registrationListener\n                )\n                return true\n            } else {\n                /* Error handling */\n                return false\n            }\n        } catch (e: Exception) {\n            /* Error handling */\n            return false\n        }\n    }\n\n    /** HOST: Stops the ServerSocket and unregisters NSD service. */\n    fun stopServerAndDiscovery() {\n        if (!isHost) return\n        if (!isServerRunning && serverSocket == null && registrationListener == null) {\n            log(\"stopServerAndDiscovery called but server/NSD not active.\")\n            return\n        }\n        log(\"Stopping server and NSD...\")\n        isServerRunning = false\n\n        // 1. Unregister NSD\n        if (nsdManager != null && registrationListener != null) {\n            log(\"Unregistering NSD service: $nsdServiceNameRegistered\")\n            try {\n                nsdManager?.unregisterService(registrationListener)\n            } catch (e: Exception) {\n                /* Error handling */\n            } finally {\n                registrationListener = null\n            } // Clear listener ref\n        }\n\n        // 2. Close Server Socket\n        runCatching { serverSocket?.close() }.onSuccess { log(\"Server socket closed.\") }.onFailure {\n            logError(\"Error closing server socket\", it)\n        }\n        serverSocket = null\n        servicePort = 0 // Reset port\n\n        // 3. Cancel client jobs & close connections\n        val clientIds = clientSockets.keys.toList()\n        clientIds.forEach { removeClient(it) } // Use removeClient for thorough cleanup\n\n        // 4. Reset host state\n        _connectedPlayersCount.value = 0\n        _gameStarted.value = false\n        _hostIpAddress.value = null\n        _state.value = createInitialEmptyGameState()\n        log(\"Server stopped, NSD unregistered, connections closed.\")\n    }\n\n    // ... (Rest of HOST functions: listenToClient, handleClientMessage, prepareAndBroadcast, etc.)\n    // ...\n    /** HOST: Starts a listener coroutine for a specific client. */\n    private fun listenToClient(playerId: Int, reader: BufferedReader) {\n        clientJobs[playerId] =\n                viewModelScope.launch(Dispatchers.IO) {\n                    log(\"Listener started for Player $playerId.\")\n                    try {\n                        while (isActive) { // Loop while coroutine is active\n                            val messageJson =\n                                    reader.readLine() ?: break // null means connection closed\n                            log(\"Received from Player $playerId: $messageJson\")\n                            try {\n                                val message = gson.fromJson(messageJson, NetworkMessage::class.java)\n                                // Process message on Main thread for state safety\n                                withContext(\n                                        Dispatchers.Main.immediate\n                                ) { // Use immediate for faster processing if safe\n                                    handleClientMessage(playerId, message)\n                                }\n                            } catch (e: JsonSyntaxException) {\n                                logError(\"JSON Parse Error from Player $playerId: ${e.message}\")\n                            } catch (e: Exception) {\n                                logError(\"Error handling message from Player $playerId\", e)\n                            }\n                        }\n                    } catch (e: Exception) {\n                        if (isActive) { // Avoid logging errors during cancellation\n                            logError(\"Error reading from Player $playerId socket\", e)\n                        }\n                    } finally {\n                        log(\"Listener stopped for Player $playerId.\")\n                        // Ensure cleanup happens on the Main thread safely\n                        withContext(Dispatchers.Main) { removeClient(playerId) }\n                    }\n                }\n        clientJobs[playerId]?.invokeOnCompletion { throwable ->\n            if (throwable != null && throwable !is CancellationException) {\n                logError(\"Listener job for Player $playerId completed with error\", throwable)\n            } else {\n                log(\"Listener job for Player $playerId completed normally or cancelled.\")\n            }\n            // Ensure cleanup happens on job completion too\n            viewModelScope.launch(Dispatchers.Main) { removeClient(playerId) }\n        }\n    }\n\n    /** HOST: Handles messages received from a specific client. */\n    private fun handleClientMessage(playerId: Int, message: NetworkMessage) {\n        log(\"Handling message: ${message.type} from Player $playerId\")\n        when (message.type) {\n            MessageType.PLAYER_ACTION -> {\n                if (_state.value.awaitingInputFromPlayerIndex == playerId) {\n                    val expectedType = _state.value.requiredInputType\n                    try {\n                        // Deserialize based on expected type - Requires robust handling\n                        val actionData: Any? =\n                                when (expectedType) {\n                                    // Need more robust deserialization (e.g., check data type\n                                    // before parsing)\n                                    InputType.PLAY_CARD,\n                                    InputType.CHOOSE_TRUMP_SUIT ->\n                                            try {\n                                                gson.fromJson(\n                                                        gson.toJson(message.data),\n                                                        Card::class.java\n                                                )\n                                            } catch (e: Exception) {\n                                                null\n                                            }\n                                    InputType.REVEAL_OR_PASS ->\n                                            try {\n                                                gson.fromJson(\n                                                        gson.toJson(message.data),\n                                                        GameEngine.Decision::class.java\n                                                )\n                                            } catch (e: Exception) {\n                                                null\n                                            }\n                                    null -> null // Error case\n                                }\n\n                        if (actionData != null) {\n                            processGameInput(playerId, actionData) // Pass Player ID for context\n                        } else {\n                            logError(\n                                    \"Failed to parse PLAYER_ACTION data for expected type $expectedType from Player $playerId\"\n                            )\n                            sendMessageToClient(\n                                    playerId,\n                                    NetworkMessage(MessageType.ERROR, \"Invalid action data format.\")\n                            )\n                        }\n                    } catch (e: Exception) {\n                        logError(\"Error deserializing PLAYER_ACTION data from Player $playerId\", e)\n                        sendMessageToClient(\n                                playerId,\n                                NetworkMessage(MessageType.ERROR, \"Error processing your action.\")\n                        )\n                    }\n                } else {\n                    log(\n                            \"Received action from Player $playerId but it's not their turn (expected ${_state.value.awaitingInputFromPlayerIndex}).\"\n                    )\n                    sendMessageToClient(\n                            playerId,\n                            NetworkMessage(MessageType.ERROR, \"Not your turn\")\n                    )\n                }\n            }\n            MessageType.PLAYER_NAME -> {\n                // Ensure data is a string before updating\n                val name = message.data as? String\n                if (name != null) {\n                    updatePlayerName(playerId, name) // Update name and broadcast state\n                } else {\n                    logError(\n                            \"Received invalid PLAYER_NAME data from Player $playerId: ${message.data}\"\n                    )\n                }\n            }\n            else -> log(\"Received unhandled message type: ${message.type} from Player $playerId\")\n        }\n    }\n\n    /** HOST: Deals cards, sets hidden card (Mode B), updates state, and broadcasts. */\n    private fun prepareAndBroadcastInitialState() {\n        viewModelScope.launch(Dispatchers.Main.immediate) {\n            log(\"Preparing initial game state for ${requiredPlayerCount} players...\")\n            val currentPlayers = _state.value.players\n            if (currentPlayers.size != requiredPlayerCount ||\n                            currentPlayers.any {\n                                it.name == \"Waiting...\" || it.name == \"[Disconnected]\"\n                            }\n            ) {\n                logError(\"Cannot prepare initial state: Incorrect number or incomplete players.\")\n                // Maybe send error to clients or host UI\n                return@launch\n            }\n\n            val deck = DeckGenerator.generateDeck(requiredPlayerCount)\n            var hiddenCard: Card? = null\n\n            if (_state.value.gameMode == GameMode.FIRST_CARD_HIDDEN) {\n                if (deck.isNotEmpty()) {\n                    hiddenCard = deck.removeAt(0)\n                    log(\"Hidden card set (Mode B): ${hiddenCard.suit}\")\n                } else {\n                    logError(\"Deck empty\")\n                    return@launch\n                }\n            }\n\n            val updatedPlayers = currentPlayers.toMutableList()\n            val cardsPerPlayer = deck.size / requiredPlayerCount\n            if (deck.size % requiredPlayerCount != 0) {\n                logError(\"Deck size not evenly divisible after hidden card!\")\n            }\n\n            for (i in 0 until requiredPlayerCount) {\n                val handCards = deck.take(cardsPerPlayer).toMutableList()\n                if (i < updatedPlayers.size) {\n                    updatedPlayers[i] = updatedPlayers[i].copy(hand = handCards)\n                    deck.removeAll(handCards.toSet())\n                } else {\n                    logError(\"Player index OOB during dealing\")\n                }\n            }\n            log(\"Cards dealt. Remaining deck: ${deck.size}\")\n\n            var initialState =\n                    _state.value.copy(\n                            players = updatedPlayers,\n                            hiddenCard = hiddenCard,\n                            tricksWon = mutableMapOf(1 to 0, 2 to 0),\n                            currentTrickPlays = mutableListOf(),\n                            trumpSuit = null,\n                            trumpRevealed = false,\n                            currentLeaderIndex = 0\n                    )\n            initialState = GameEngine.requestInput(initialState, initialState.currentLeaderIndex)\n            _state.value = initialState\n\n            broadcastGameState(_state.value)\n            log(\"Initial GameState broadcast.\")\n            _gameStarted.value = true\n        }\n    }\n\n    /** HOST: Broadcasts the GameState to all connected clients. */\n    private fun broadcastGameState(gameState: GameState) {\n        if (!isHost) return\n        val message = NetworkMessage(MessageType.GAME_STATE_UPDATE, gameState)\n        log(\"Broadcasting GameState to ${clientWriters.size} clients...\")\n        clientWriters.keys.toList().forEach { id -> sendMessageToClient(id, message) }\n        log(\"Broadcast attempt complete.\")\n    }\n\n    /** HOST: Sends a specific message to a single client. Handles potential errors. */\n    private fun sendMessageToClient(playerId: Int, message: NetworkMessage) {\n        if (!isHost) return\n        val writer = clientWriters[playerId]\n        if (writer == null) {\n            log(\"Cannot send message, writer not found for Player $playerId (already removed?).\")\n            return\n        }\n        viewModelScope.launch(Dispatchers.IO) {\n            try {\n                val messageJson = gson.toJson(message)\n                synchronized(writer) { writer.println(messageJson) }\n                if (writer.checkError()) {\n                    throw Exception(\"PrintWriter error after write.\")\n                }\n            } catch (e: Exception) {\n                logError(\"Error sending message to Player $playerId\", e)\n                withContext(Dispatchers.Main) { removeClient(playerId) }\n            }\n        }\n    }\n\n    /** HOST: Cleans up resources associated with a disconnected or removed client. */\n    private fun removeClient(playerId: Int) {\n        viewModelScope.launch(Dispatchers.Main.immediate) {\n            if (!clientSockets.containsKey(playerId)) return@launch\n\n            log(\"Removing client Player $playerId...\")\n            clientJobs[playerId]?.cancel(\"Client removed\")\n            clientJobs.remove(playerId)\n\n            runCatching { clientWriters[playerId]?.close() }\n            runCatching { clientReaders[playerId]?.close() }\n            runCatching { clientSockets[playerId]?.close() }\n\n            clientWriters.remove(playerId)\n            clientReaders.remove(playerId)\n            clientSockets.remove(playerId)\n\n            _connectedPlayersCount.value = clientSockets.size + 1\n\n            log(\n                    \"Player $playerId removed. Connected: ${_connectedPlayersCount.value}/${requiredPlayerCount}\"\n            )\n\n            if (_gameStarted.value) {\n                val playerName =\n                        _state.value.players.find { it.id == playerId }?.name ?: \"Player $playerId\"\n                _showError.emit(\"$playerName disconnected. Game interrupted.\")\n                broadcastGameState(\n                        _state.value.copy(\n                                players =\n                                        _state.value.players.map {\n                                            if (it.id == playerId)\n                                                    it.copy(\n                                                            name = \"$playerName [LEFT]\",\n                                                            hand = mutableListOf()\n                                                    )\n                                            else it\n                                        }\n                        )\n                )\n                // stopServerAndDiscovery() // Consider stopping the game\n            } else {\n                _state.update { state ->\n                    val updatedPlayers =\n                            state.players.map {\n                                if (it.id == playerId)\n                                        it.copy(name = \"[Disconnected]\", hand = mutableListOf())\n                                else it\n                            }\n                    state.copy(players = updatedPlayers)\n                }\n                broadcastGameState(_state.value)\n            }\n        }\n    }\n\n    // ========================================================================\n    // CLIENT FUNCTIONS\n    // ========================================================================\n\n    fun startNsdDiscovery() {\n        if (isHost) return\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) { /* Permission check */ }\n\n        log(\"Client: Starting NSD discovery...\")\n        stopNsdDiscovery() // Ensure clean state\n        _discoveredHosts.value = emptyList()\n        resolvingServices.clear() // Clear resolving tracker\n\n        nsdManager = applicationContext.getSystemService(Context.NSD_SERVICE) as NsdManager?\n        if (nsdManager == null) { /* Error handling */ return }\n\n        discoveryListener = object : NsdManager.DiscoveryListener {\n            override fun onDiscoveryStarted(regType: String) { log(\"NSD discovery started.\") }\n\n            override fun onServiceFound(service: NsdServiceInfo) {\n                log(\"NSD service found raw: ${service.serviceName}, type: ${service.serviceType}\")\n                // Filter for correct type, avoid self-discovery, and check if already resolving\n                if (service.serviceType == SERVICE_TYPE &&\n                    service.serviceName != nsdServiceNameRegistered &&\n                    !resolvingServices.containsKey(service.serviceName) // Check if already resolving\n                )\n                {\n                    log(\"Attempting to resolve service: ${service.serviceName}\")\n                    resolvingServices[service.serviceName] = true // Mark as resolving\n                    resolveNsdService(service) // Trigger resolution\n                } else {\n                    log(\"Ignoring found service: Type mismatch, self-discovery, or already resolving.\")\n                }\n            }\n\n            override fun onServiceLost(service: NsdServiceInfo) {\n                log(\"NSD service lost: ${service.serviceName}\")\n                // Update UI on Main thread\n                viewModelScope.launch(Dispatchers.Main) {\n                    _discoveredHosts.update { list -> list.filterNot { it.serviceName == service.serviceName } }\n                }\n                resolvingServices.remove(service.serviceName) // Remove from resolving tracker\n            }\n\n            override fun onDiscoveryStopped(serviceType: String) { log(\"NSD discovery stopped.\") }\n            override fun onStartDiscoveryFailed(serviceType: String, errorCode: Int) {\n                logError(\"NSD discovery start failed: Error code $errorCode\")\n                viewModelScope.launch { _showError.emit(\"Failed to search for games (Error $errorCode)\")}\n                stopNsdDiscovery()\n            }\n            override fun onStopDiscoveryFailed(serviceType: String, errorCode: Int) {\n                logError(\"NSD discovery stop failed: Error code $errorCode\")\n            }\n        }\n\n        try {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\n                nsdManager?.discoverServices(SERVICE_TYPE, NsdManager.PROTOCOL_DNS_SD, discoveryListener)\n            } else { /* Handle older API error */ }\n        } catch (e: Exception) { /* Error handling */ }\n    }\n\n    /** CLIENT: Resolves a discovered service to get host and port */\n    private fun resolveNsdService(serviceInfo: NsdServiceInfo) {\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN || nsdManager == null) return\n\n        val serviceName = serviceInfo.serviceName // Capture name for logging in callbacks\n        log(\"Resolving NSD service details for: $serviceName\")\n\n        val listener = object : NsdManager.ResolveListener {\n            override fun onResolveFailed(failedServiceInfo: NsdServiceInfo, errorCode: Int) {\n                logError(\"NSD resolve failed for ${failedServiceInfo.serviceName}: Error code $errorCode\")\n                resolvingServices.remove(failedServiceInfo.serviceName) // Remove from tracker on failure\n            }\n\n            @Suppress(\"DEPRECATION\") // For host property\n            override fun onServiceResolved(resolvedServiceInfo: NsdServiceInfo) {\n                log(\"NSD service RESOLVED: ${resolvedServiceInfo.serviceName} at ${resolvedServiceInfo.host}:${resolvedServiceInfo.port}\")\n                // Update the list on the Main thread\n                viewModelScope.launch(Dispatchers.Main) {\n                    _discoveredHosts.update { currentList ->\n                        val existingIndex = currentList.indexOfFirst { it.serviceName == resolvedServiceInfo.serviceName }\n                        if (existingIndex != -1) {\n                            // Update existing entry with resolved info\n                            currentList.toMutableList().apply { set(existingIndex, resolvedServiceInfo) }\n                        } else {\n                            // Add new resolved entry\n                            currentList + resolvedServiceInfo\n                        }\n                    }\n                }\n                resolvingServices.remove(resolvedServiceInfo.serviceName) // Remove from tracker on success\n            }\n        }\n\n        try {\n            @Suppress(\"DEPRECATION\") // For resolveService method\n            nsdManager?.resolveService(serviceInfo, listener)\n        } catch (e: Exception) {\n            logError(\"Exception calling resolveService for $serviceName\", e)\n            resolvingServices.remove(serviceName) // Remove from tracker on exception\n        }\n    }\n\n    /** CLIENT: Stops NSD discovery */\n    fun stopNsdDiscovery() {\n        if (isHost || nsdManager == null || discoveryListener == null) return\n        log(\"Client: Stopping NSD discovery...\")\n        try {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\n                nsdManager?.stopServiceDiscovery(discoveryListener)\n            }\n        } catch (e: IllegalArgumentException) {\n            log(\"NSD Discovery likely already stopped: ${e.message}\")\n        } catch (e: Exception) { logError(\"Error stopping NSD discovery\", e) }\n        finally {\n            discoveryListener = null\n            _discoveredHosts.value = emptyList() // Clear list when stopping discovery\n            resolvingServices.clear() // Clear resolving tracker\n        }\n    }\n\n    /** CLIENT: Connects to a selected discovered host */\n    fun connectToDiscoveredHost(serviceInfo: NsdServiceInfo, playerName: String) {\n        @Suppress(\"DEPRECATION\") // Suppress warning for serviceInfo.host\n        val hostAddress = serviceInfo.host?.hostAddress\n        val port = serviceInfo.port\n        if (hostAddress != null && port > 0) {\n            log(\"Client: Attempting connection to selected host: ${serviceInfo.serviceName} ($hostAddress:$port)\")\n            connectToServer(hostAddress, port, playerName)\n        } else {\n            logError(\"Client: Cannot connect, resolved service info is invalid (missing host/port): $serviceInfo\")\n            viewModelScope.launch { _showError.emit(\"Failed to get connection details for '${serviceInfo.serviceName}'. Please refresh.\") }\n        }\n    }\n\n    /** CLIENT: Connects to the game host using IP/Port */\n    fun connectToServer(hostAddress: String, port: Int = 8888, playerName: String) {\n        if (isConnectedToServer || isHost) return\n        log(\"Client: Attempting connection to $hostAddress:$port...\")\n        viewModelScope.launch(Dispatchers.IO) {\n            try {\n                disconnectFromServer() // Ensure cleanup before connect\n                delay(100)\n                clientSocket = Socket(hostAddress, port)\n                clientWriter = PrintWriter(clientSocket!!.getOutputStream(), true)\n                clientReader = BufferedReader(InputStreamReader(clientSocket!!.getInputStream()))\n                isConnectedToServer = true\n                log(\"Client: Connected successfully.\")\n                listenToServer()\n                sendMessageToServer(NetworkMessage(MessageType.PLAYER_NAME, playerName))\n            } catch (e: Exception) {\n                logError(\"Client: Connection to $hostAddress:$port failed\", e)\n                isConnectedToServer = false\n                withContext(Dispatchers.Main) { _showError.emit(\"Connection failed: ${e.message}\") }\n                disconnectFromServer() // Cleanup\n            }\n        }\n    }\n\n    /** CLIENT: Listens for messages from the server */\n    private fun listenToServer() {\n        clientReaderJob?.cancel()\n        clientReaderJob =\n                viewModelScope.launch(Dispatchers.IO) {\n                    log(\"Client: Listener started.\")\n                    try {\n                        while (isActive) {\n                            val messageJson = clientReader?.readLine() ?: break\n                            try {\n                                val message = gson.fromJson(messageJson, NetworkMessage::class.java)\n                                withContext(Dispatchers.Main.immediate) {\n                                    handleServerMessage(message)\n                                }\n                            } catch (e: Exception) {\n                                logError(\"Client: Error handling message\", e)\n                            }\n                        }\n                    } catch (e: Exception) {\n                        if (isActive) {\n                            logError(\"Client: Socket read error\", e)\n                        }\n                    } finally {\n                        log(\"Client: Listener stopped.\")\n                        withContext(Dispatchers.Main) { disconnectFromServer() }\n                    }\n                }\n        clientReaderJob?.invokeOnCompletion { /* Optional logging */}\n    }\n\n    /** CLIENT: Handles messages received from the server */\n    private fun handleServerMessage(message: NetworkMessage) {\n        log(\"Client: Handling message: ${message.type}\")\n        when (message.type) {\n            MessageType.ASSIGN_ID -> {\n                val id = (message.data as? Double)?.toInt() ?: -1\n                if (id != -1 && localPlayerId == -1) {\n                    localPlayerId = id\n                    log(\"Client: Assigned Player ID: $localPlayerId\")\n                } else {\n                    /* Handle error/conflict */\n                }\n            }\n            MessageType.GAME_STATE_UPDATE -> {\n                try {\n                    val gameStateJson = gson.toJson(message.data)\n                    val updatedState = gson.fromJson(gameStateJson, GameState::class.java)\n                    if (updatedState.players.isEmpty() && _state.value.players.isNotEmpty())\n                            return // Ignore potential invalid empty state\n\n                    _state.value = updatedState\n                    _connectedPlayersCount.value =\n                            updatedState.players.count {\n                                it.name != \"Waiting...\" && it.name != \"[Disconnected]\"\n                            }\n                    log(\n                            \"Client: GameState updated. Awaiting: ${updatedState.awaitingInputFromPlayerIndex}\"\n                    )\n\n                    val myHand = updatedState.players.find { it.id == localPlayerId }?.hand\n                    if (!_gameStarted.value && myHand?.isNotEmpty() == true) {\n                        _gameStarted.value = true\n                        log(\"Client: Game Started (received hand).\")\n                    }\n                } catch (e: Exception) {\n                    logError(\"Client: Error deserializing GAME_STATE_UPDATE\", e)\n                }\n            }\n            MessageType.ERROR -> {\n                val errorMsg = message.data as? String ?: \"Unknown server error\"\n                logError(\"Client: Received error from server: $errorMsg\")\n                viewModelScope.launch { _showError.emit(errorMsg) }\n            }\n            else -> log(\"Client: Received unhandled message type: ${message.type}\")\n        }\n    }\n\n    /** CLIENT: Sends a message to the host server */\n    private fun sendMessageToServer(message: NetworkMessage) {\n        if (!isConnectedToServer || isHost || clientWriter == null) return\n        viewModelScope.launch(Dispatchers.IO) {\n            try {\n                val messageJson = gson.toJson(message)\n                synchronized(clientWriter!!) { clientWriter?.println(messageJson) }\n                if (clientWriter?.checkError() == true) {\n                    throw Exception(\"PrintWriter error\")\n                }\n            } catch (e: Exception) {\n                logError(\"Client: Error sending message\", e)\n                withContext(Dispatchers.Main) { _showError.emit(\"Connection error.\") }\n            }\n        }\n    }\n\n    /** CLIENT: Disconnects from the server and cleans up resources */\n    fun disconnectFromServer() {\n        if (isHost || (!isConnectedToServer && clientSocket == null)) return\n\n        log(\"Client: Disconnecting...\")\n        isConnectedToServer = false\n        clientReaderJob?.cancel(\"Client disconnecting\")\n        clientReaderJob = null\n\n        runCatching { clientWriter?.close() }\n        runCatching { clientReader?.close() }\n        runCatching { clientSocket?.close() }\n\n        clientSocket = null\n        clientWriter = null\n        clientReader = null\n\n        _gameStarted.value = false\n        _state.value = createInitialEmptyGameState()\n        localPlayerId = -1\n        _connectedPlayersCount.value = 0\n        log(\"Client: Disconnected.\")\n    }\n\n    // ========================================================================\n    // GAME LOGIC PROCESSING (HOST ONLY)\n    // ========================================================================\n\n    /** HOST ONLY: Processes player input using the GameEngine and broadcasts the result */\n    private fun processGameInput(actingPlayerId: Int, playerInput: Any) {\n        if (!isHost) return\n\n        viewModelScope.launch(Dispatchers.Main.immediate) {\n            val currentState = _state.value\n            if (currentState.awaitingInputFromPlayerIndex != actingPlayerId) {\n                /* Error Handling */\n                return@launch\n            }\n\n            log(\"Host: Processing input from Player $actingPlayerId: $playerInput\")\n            try {\n                GameEngine.processPlayerInput(\n                        currentState,\n                        playerInput\n                ) // Modifies currentState directly\n                _state.value = currentState // Update StateFlow\n\n                val roundEnded =\n                        currentState.players.firstOrNull()?.hand?.isEmpty() == true &&\n                                currentState.currentTrickPlays.isEmpty()\n\n                if (roundEnded) {\n                    log(\"Host: Round Ended. Evaluating...\")\n                    val result = RoundEvaluator.evaluateRound(currentState)\n                    log(\n                            \"Host: Round Result: Winner=${result.winningTeam?.id ?: \"Draw\"}, Kot=${result.isKot}\"\n                    )\n                    // TODO: Update scores\n                    broadcastGameState(currentState) // Broadcast final state\n                    delay(200)\n                    _navigateToResultScreen.emit(result) // Notify host UI\n                    // TODO: Next round logic\n                } else {\n                    broadcastGameState(currentState) // Broadcast updated state\n                }\n            } catch (e: IllegalStateException) {\n                logError(\"Host: Invalid move detected for Player $actingPlayerId: ${e.message}\")\n                sendMessageToClient(\n                        actingPlayerId,\n                        NetworkMessage(MessageType.ERROR, \"Invalid Move: ${e.message}\")\n                )\n                // Re-request input without changing state drastically\n                _state.value = GameEngine.requestInput(currentState, actingPlayerId)\n                broadcastGameState(_state.value)\n            } catch (e: Exception) {\n                /* Error handling */\n            }\n        }\n    }\n\n    // ========================================================================\n    // UI ACTION HANDLERS (Called by the UI on the specific device)\n    // ========================================================================\n\n    /** Called when the local player chooses a card to play */\n    fun onCardPlayed(card: Card) {\n        log(\"UI Action: Card played: $card by Local Player $localPlayerId\")\n        val currentState = _state.value\n        val myTurn = currentState.awaitingInputFromPlayerIndex == localPlayerId\n        val expectedInput = currentState.requiredInputType\n\n        if (!myTurn) {\n            viewModelScope.launch { _showError.emit(\"Not your turn!\") }\n            return\n        }\n        if (expectedInput != InputType.PLAY_CARD && expectedInput != InputType.CHOOSE_TRUMP_SUIT) {\n            viewModelScope.launch { _showError.emit(\"Cannot play card now.\") }\n            return\n        }\n        if (currentState.players.find { it.id == localPlayerId }?.hand?.contains(card) != true) {\n            viewModelScope.launch { _showError.emit(\"Card not in hand!\") }\n            return\n        }\n\n        // Client-side valid move check (optional but improves UX)\n        val validMoves =\n                GameEngine.determineValidMoves(\n                        currentState.players.find { it.id == localPlayerId }?.hand ?: emptyList(),\n                        currentState.currentTrickPlays,\n                        currentState.trumpSuit,\n                        currentState.trumpRevealed\n                )\n        if (!validMoves.contains(card)) {\n            logError(\"UI Action: Invalid card $card played. Valid: $validMoves\")\n            viewModelScope.launch { _showError.emit(\"Invalid move.\") }\n            return\n        }\n\n        if (isHost) {\n            processGameInput(localPlayerId, card)\n        } else {\n            sendMessageToServer(NetworkMessage(MessageType.PLAYER_ACTION, card))\n        }\n    }\n\n    /** Called when the local player chooses Reveal or Pass (Mode B) */\n    fun onRevealOrPass(decision: GameEngine.Decision) {\n        log(\"UI Action: Reveal/Pass decision: $decision by Local Player $localPlayerId\")\n        val currentState = _state.value\n        if (currentState.awaitingInputFromPlayerIndex != localPlayerId ||\n                        currentState.requiredInputType != InputType.REVEAL_OR_PASS\n        ) {\n            viewModelScope.launch { _showError.emit(\"Cannot Reveal or Pass now.\") }\n            return\n        }\n        if (isHost) {\n            processGameInput(localPlayerId, decision)\n        } else {\n            sendMessageToServer(NetworkMessage(MessageType.PLAYER_ACTION, decision))\n        }\n    }\n\n    // ========================================================================\n    // UTILITY & LIFECYCLE\n    // ========================================================================\n\n    /** Creates an empty initial game state */\n    private fun createInitialEmptyGameState(): GameState {\n        return GameState(\n                players = emptyList(),\n                teams = emptyList(),\n                gameMode = GameMode.CHOOSE_WHEN_EMPTY,\n                tricksWon = mutableMapOf()\n        )\n    }\n\n    /** HOST: Updates player name in the authoritative state and broadcasts the change */\n    private fun updatePlayerName(playerId: Int, name: String) {\n        if (!isHost) return\n        log(\"Host: Updating Player $playerId name to '$name'\")\n        var nameChanged = false\n        _state.update { currentState ->\n            val currentName = currentState.players.find { it.id == playerId }?.name\n            if (currentName != name && name.isNotBlank()) { // Add check for blank name\n                nameChanged = true\n                val updatedPlayers =\n                        currentState.players.map {\n                            if (it.id == playerId) it.copy(name = name) else it\n                        }\n                currentState.copy(players = updatedPlayers)\n            } else {\n                currentState\n            }\n        }\n        if (nameChanged) {\n            broadcastGameState(_state.value)\n        }\n    }\n\n    /** Gets the local IP address (needs refinement for robustness) */\n    private fun getLocalIpAddress(): InetAddress? {\n        // This is a basic implementation. Consider libraries or more checks for complex networks.\n        return try {\n            val interfaces = java.net.NetworkInterface.getNetworkInterfaces()?.toList()\n            interfaces\n                    ?.flatMap { intf ->\n                        intf.inetAddresses?.toList()?.filter { addr ->\n                            !addr.isLoopbackAddress &&\n                                    addr is java.net.Inet4Address &&\n                                    addr.hostAddress?.startsWith(\"192.168.\") ==\n                                            true // Common for WiFi, adjust if needed\n                        }\n                                ?: emptyList()\n                    }\n                    ?.firstOrNull()\n        } catch (e: Exception) {\n            logError(\"Could not determine local IP address\", e)\n            null\n        }\n    }\n\n    /** Called when ViewModel is cleared - ensures network cleanup */\n    override fun onCleared() {\n        log(\"GameViewModel Cleared.\")\n        if (isHost) {\n            stopServerAndDiscovery()\n        } else {\n            stopNsdDiscovery()\n            disconnectFromServer()\n        }\n        // Optionally nullify NSD manager if strictly needed: nsdManager = null\n        super.onCleared()\n    }\n}\n\n// ========================================================================\n// VIEWMODEL FACTORY (Required for injecting Context)\n// ========================================================================\nclass GameViewModelFactory(private val context: Context) : ViewModelProvider.Factory {\n    override fun <T : ViewModel> create(modelClass: Class<T>): T {\n        if (modelClass.isAssignableFrom(GameViewModel::class.java)) {\n            @Suppress(\"UNCHECKED_CAST\") return GameViewModel(context.applicationContext) as T\n        }\n        throw IllegalArgumentException(\"Unknown ViewModel class: ${modelClass.name}\")\n    }\n}\n\n// ========================================================================\n// DATA CLASSES FOR NETWORKING\n// ========================================================================\n\n/** Defines the type of message being sent over the network. */\nenum class MessageType {\n    ASSIGN_ID, // Server -> Client: {data: Int}\n    GAME_STATE_UPDATE, // Server -> Client: {data: GameState}\n    PLAYER_ACTION, // Client -> Server: {data: Card or GameEngine.Decision}\n    PLAYER_NAME, // Client -> Server: {data: String}\n    ERROR // Server -> Client: {data: String}\n    // Consider: ROUND_RESULT, GAME_OVER, DISCONNECT_NOTICE\n}\n\n/** Represents a message sent between the host and clients. */\ndata class NetworkMessage(\n        val type: MessageType,\n        val data: Any? = null // Requires careful serialization/deserialization\n)\n",
        "MainActivity.kt": "package com.example.mindikot\n\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.Modifier // Ensure this import is added\nimport androidx.navigation.compose.rememberNavController\nimport com.example.mindikot.ui.MainNavHost\nimport com.example.mindikot.ui.components.GameFooter\nimport com.example.mindikot.ui.theme.MindikotTheme\n\nclass MainActivity : ComponentActivity() {\n\n    private external fun stringFromJNI(): String\n\n    companion object {\n        init {\n            System.loadLibrary(\"mindikot\")\n        }\n    }\n\n    @OptIn(ExperimentalMaterial3Api::class) // Opt-In annotation for Material3 APIs\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        setContent {\n            MindikotTheme {\n                val navController = rememberNavController()\n\n                // State to hold the native string\n                var nativeText by remember { mutableStateOf(\"\") }\n\n                // Use LaunchedEffect to call the native method and set the result\n                LaunchedEffect(Unit) {\n                    nativeText = stringFromJNI() // This will run once during composition\n                }\n\n                Scaffold(\n                    topBar = {\n                        TopAppBar(\n                            title = { Text(\"Mindikot Game\") },\n                            colors = TopAppBarDefaults.mediumTopAppBarColors()\n                        )\n                    }\n                    ,\n                    bottomBar = {\n                        GameFooter(version = \"v1.0.0\") // \u00f0\u0178\u2018\u02c6 Footer added here\n                    }\n                ) { paddingValues ->\n                    // Main content is handled by MainNavHost, passing the navigation controller\n                    MainNavHost(navController = navController, modifier = Modifier.padding(paddingValues))\n\n                }\n\n            }\n        }\n    }\n}\n",
        "ui": {
            "components": {
                "GameFooter.kt": "package com.example.mindikot.ui.components\n\nimport android.content.Intent\nimport android.net.Uri\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.text.style.TextDecoration\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun GameFooter(version: String = \"v1.0.0\") {\n    val context = LocalContext.current\n\n    Column(\n            modifier = Modifier.fillMaxWidth().padding(top = 24.dp, bottom = 8.dp),\n            horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Divider(modifier = Modifier.padding(vertical = 8.dp))\n\n        Text(\n                text = \"Made with <love> by delpat\",\n                style =\n                        MaterialTheme.typography.bodySmall.copy(\n                                textDecoration = TextDecoration.Underline\n                        ),\n                color = MaterialTheme.colorScheme.primary,\n                modifier =\n                        Modifier.clickable {\n                            val intent =\n                                    Intent(\n                                            Intent.ACTION_VIEW,\n                                            Uri.parse(\"https://delpat-llp.web.app/\")\n                                    )\n                            context.startActivity(intent)\n                        }\n        )\n\n        Text(\"Version $version\", style = MaterialTheme.typography.bodySmall)\n    }\n}\n",
                "GameStatus.kt": "package com.example.mindikot.ui.components\n\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport com.example.mindikot.core.state.GameState\n\n@Composable\nfun GameStatus(gameState: GameState) {\n    Column {\n        Text(\"Round: ${gameState.gameMode}\", style = MaterialTheme.typography.headlineLarge)\n        Text(\"Current Leader: ${gameState.players[gameState.currentLeaderIndex].name}\", style = MaterialTheme.typography.bodyMedium)\n        Text(\"Trump Suit: ${gameState.trumpSuit?.name ?: \"None\"}\", style = MaterialTheme.typography.bodyMedium)\n    }\n}\n",
                "OtherPlayersDisplay.kt": "package com.example.mindikot.ui.components\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.shape.CircleShape\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Person // Or style_outlined depending on preference\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport com.example.mindikot.core.model.Player\n\n@Composable\nfun OtherPlayerDisplay(player: Player, isCurrentTurn: Boolean, modifier: Modifier = Modifier) {\n    val teamColor =\n            if (player.teamId == 1) Color(0xFFADD8E6)\n            else Color(0xFFFAC898) // Example Light Blue/Peach\n    val turnIndicatorColor =\n            if (isCurrentTurn) MaterialTheme.colorScheme.primary else Color.Transparent\n    val nameColor =\n            if (isCurrentTurn) MaterialTheme.colorScheme.primary\n            else MaterialTheme.colorScheme.onSurface\n\n    Column(\n            modifier =\n                    modifier.padding(8.dp)\n                            .border(\n                                    2.dp,\n                                    turnIndicatorColor,\n                                    CircleShape\n                            ) // Highlight border if turn\n                            .padding(8.dp), // Inner padding\n            horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Icon(\n                imageVector = Icons.Default.Person,\n                contentDescription = player.name,\n                modifier =\n                        Modifier.size(40.dp)\n                                .clip(CircleShape)\n                                .background(teamColor.copy(alpha = 0.5f))\n                                .padding(4.dp)\n        )\n        Spacer(modifier = Modifier.height(4.dp))\n        Text(\n                text = player.name,\n                fontWeight = if (isCurrentTurn) FontWeight.Bold else FontWeight.Normal,\n                fontSize = 14.sp,\n                color = nameColor\n        )\n        Spacer(modifier = Modifier.height(2.dp))\n        Text(\n                text = \"Cards: ${player.hand.size}\", // Display card count\n                fontSize = 12.sp,\n                color = Color.Gray\n        )\n    }\n}\n",
                "PlayerCardView.kt": "package com.example.mindikot.ui.components\n\nimport androidx.compose.foundation.BorderStroke\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.material3.Card\nimport androidx.compose.material3.CardDefaults\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.alpha\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport com.example.mindikot.core.model.Card\n\n@Composable\nfun CardView(\n        card: Card,\n        isValidMove: Boolean, // Can this card be played now?\n        isPlayable: Boolean, // Is it generally the player's turn to play any card?\n        onCardSelected: (Card) -> Unit,\n        modifier: Modifier = Modifier\n) {\n    val elevation = if (isValidMove) 8.dp else 2.dp\n    val alpha = if (isPlayable && !isValidMove) 0.6f else 1.0f // Dim invalid cards when it's turn\n    val borderColor = if (isValidMove) MaterialTheme.colorScheme.primary else Color.Gray\n\n    Card(\n            modifier =\n                    modifier.size(width = 70.dp, height = 100.dp) // Example fixed size\n                            .padding(horizontal = 2.dp, vertical = 4.dp)\n                            .alpha(alpha)\n                            .clickable(\n                                    enabled =\n                                            isValidMove &&\n                                                    isPlayable, // Clickable only if it's a valid\n                                    // move AND it's our turn\n                                    onClick = { onCardSelected(card) }\n                            ),\n            elevation = CardDefaults.cardElevation(defaultElevation = elevation),\n            border = BorderStroke(if (isValidMove) 2.dp else 0.5.dp, borderColor),\n            shape = MaterialTheme.shapes.medium // Or RoundedCornerShape(8.dp)\n    ) {\n        // Basic card representation (improve this visually)\n        Box(modifier = Modifier.padding(4.dp), contentAlignment = Alignment.Center) {\n            Text(\n                    text = \"${card.rank.displayName}${getSuitSymbol(card.suit)}\",\n                    fontSize = 18.sp, // Adjust size\n                    fontWeight = FontWeight.Bold,\n                    color = getSuitColor(card.suit)\n            )\n            // You can add separate Texts for top-left/bottom-right if needed\n        }\n    }\n}\n\n// Helper functions for visual representation (customize as needed)\n@Composable\nfun getSuitColor(suit: com.example.mindikot.core.model.Suit): Color {\n    return when (suit) {\n        com.example.mindikot.core.model.Suit.HEARTS,\n        com.example.mindikot.core.model.Suit.DIAMONDS -> Color.Red\n        com.example.mindikot.core.model.Suit.CLUBS, com.example.mindikot.core.model.Suit.SPADES ->\n                Color.Black\n    }\n}\n\nfun getSuitSymbol(suit: com.example.mindikot.core.model.Suit): String {\n    return when (suit) {\n        com.example.mindikot.core.model.Suit.HEARTS -> \"\u00e2\u2122\u00a5\"\n        com.example.mindikot.core.model.Suit.DIAMONDS -> \"\u00e2\u2122\u00a6\"\n        com.example.mindikot.core.model.Suit.CLUBS -> \"\u00e2\u2122\u00a3\"\n        com.example.mindikot.core.model.Suit.SPADES -> \"\u00e2\u2122\u00a0\"\n    }\n}\n",
                "PlayerHand.kt": "package com.example.mindikot.ui.components\n\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.lazy.LazyRow\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\nimport com.example.mindikot.core.model.Card\nimport com.example.mindikot.core.state.InputType\nimport com.example.mindikot.ui.components.CardView\n@Composable\nfun PlayerHand(\n        cards: List<Card>,\n        validMoves: Set<Card>, // Set of valid cards to play\n        isMyTurn: Boolean, // Is it currently the local player's turn?\n        requiredInputType: InputType?, // What kind of input is expected from the player\n        onCardSelected: (Card) -> Unit // Callback when a card is selected\n) {\n    LazyRow(\n            modifier = Modifier.padding(8.dp), // Optional padding around the hand\n            horizontalArrangement =\n                    androidx.compose.foundation.layout.Arrangement.spacedBy(\n                            4.dp\n                    ) // Spacing between cards\n    ) {\n        items(\n                items = cards,\n                key = { card ->\n                    \"${card.suit}-${card.rank}\"\n                } // Stable item keys for better performance\n        ) { card ->\n            CardView( // Use PlayerCardView now (or renamed CardView)\n                    card = card,\n                    isValidMove =\n                            card in validMoves, // Check if this card is in the valid moves set\n                    isPlayable =\n                            isMyTurn &&\n                                    (requiredInputType == InputType.PLAY_CARD ||\n                                            requiredInputType ==\n                                                    InputType\n                                                            .CHOOSE_TRUMP_SUIT), // Playable if it's\n                    // my turn AND\n                    // Play_Card input\n                    // expected\n                    onCardSelected = onCardSelected\n            )\n        }\n    }\n}\n"
            },
            "navigation": {
                "MainNavHost.kt": "package com.example.mindikot.ui\n\nimport android.content.Context // Import Context\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext // Import LocalContext\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.navigation.NavHostController\nimport androidx.navigation.compose.NavHost\nimport androidx.navigation.compose.composable\n// Import your screens correctly\nimport com.example.mindikot.ui.screens.*\n// Import the factory\nimport com.example.mindikot.ui.GameViewModelFactory\n\n\n@Composable\nfun MainNavHost(navController: NavHostController, modifier: Modifier = Modifier) {\n    // Get Application Context once for the factory\n    val applicationContext = LocalContext.current.applicationContext\n    val factory = GameViewModelFactory(applicationContext) // Create factory instance\n\n    NavHost(navController = navController, startDestination = \"lobby\", modifier = modifier) {\n        composable(\"lobby\") {\n            // Create or get ViewModel scoped to this destination\n            val gameViewModel: GameViewModel = viewModel(factory = factory)\n            // Pass the specific instance to the screen\n            LobbyScreen(navController = navController, viewModel = gameViewModel)\n        }\n        composable(\"game_host\") { // Screen where host waits\n            // Create or get ViewModel scoped to this destination\n            val gameViewModel: GameViewModel = viewModel(factory = factory)\n            GameHostScreen(navController = navController, viewModel = gameViewModel)\n        }\n        composable(\"waiting_for_players\") { // Screen where joiner waits\n            // Create or get ViewModel scoped to this destination\n            val gameViewModel: GameViewModel = viewModel(factory = factory)\n            WaitingForPlayersScreen(navController = navController, viewModel = gameViewModel)\n        }\n        composable(\"game\") { // The actual game screen\n            // Create or get ViewModel scoped to this destination\n            val gameViewModel: GameViewModel = viewModel(factory = factory)\n            GameScreen(navController = navController, viewModel = gameViewModel)\n        }\n        composable(\"result\") {\n            // Create or get ViewModel scoped to this destination\n            val gameViewModel: GameViewModel = viewModel(factory = factory)\n            ResultScreen(navController = navController, viewModel = gameViewModel)\n        }\n    }\n}"
            },
            "screens": {
                "GameHostScreen.kt": "package com.example.mindikot.ui.screens\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.unit.dp\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.navigation.NavController\nimport com.example.mindikot.ui.GameViewModel\nimport com.example.mindikot.ui.GameViewModelFactory\n\n@Composable\nfun GameHostScreen(\n    navController: NavController,\n    viewModel: GameViewModel = viewModel(\n        factory = GameViewModelFactory(LocalContext.current.applicationContext)\n    )\n) {\n    val gameState by viewModel.state.collectAsState()\n    // Use the dedicated count StateFlow from ViewModel\n    val connectedCount by viewModel.connectedPlayersCount.collectAsState()\n    // Get the definitive required count from ViewModel\n    val requiredPlayerCount = viewModel.requiredPlayerCount\n    val gameStarted by viewModel.gameStarted.collectAsState()\n    val hostIp by viewModel.hostIpAddress.collectAsState() // Get host IP for display\n\n    // Log state changes for debugging UI\n    LaunchedEffect(connectedCount, gameState.players) {\n        println(\"[UI - GameHostScreen] connectedCount = $connectedCount, required = $requiredPlayerCount\")\n        println(\"[UI - GameHostScreen] Player List State: ${gameState.players.map { p -> Pair(p.id, p.name) }}\")\n    }\n\n\n    // Navigate to game screen once the game starts\n    LaunchedEffect(gameStarted) {\n        if (gameStarted) {\n            navController.navigate(\"game\") {\n                popUpTo(\"lobby\") { inclusive = false }\n            }\n        }\n    }\n\n    // Server start is handled when navigating here from Lobby's GameConfigCard\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(24.dp),\n        verticalArrangement = Arrangement.spacedBy(16.dp),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\"Game Host Lobby\", style = MaterialTheme.typography.headlineMedium)\n\n        // Display config only if state is initialized\n        if (requiredPlayerCount > 0) { // Use requiredPlayerCount as indicator\n            Text(\"Mode: ${gameState.gameMode.name}\")\n            Text(\"Players Required: $requiredPlayerCount\")\n            if(hostIp != null) {\n                Text(\"Your IP: $hostIp\", style = MaterialTheme.typography.bodySmall, color = Color.Gray)\n            }\n        } else {\n            Text(\"Initializing...\")\n        }\n        Divider(modifier = Modifier.padding(vertical = 8.dp))\n\n        // Use connectedCount and requiredPlayerCount correctly\n        Text(\"Waiting for players... ($connectedCount/$requiredPlayerCount)\")\n\n        // Display players from the GameState\n        LazyColumn(\n            modifier = Modifier\n                .fillMaxWidth()\n                .weight(1f)\n                .padding(vertical = 8.dp),\n            verticalArrangement = Arrangement.spacedBy(8.dp)\n        ) {\n            // Ensure players list is not empty before showing items\n            if (gameState.players.isNotEmpty()) {\n                items(gameState.players, key = { \"player_${it.id}\" }) { player -> // More robust key\n                    val isMe = player.id == viewModel.localPlayerId // Host is ID 0\n                    Card(\n                        modifier = Modifier.fillMaxWidth(),\n                        colors = CardDefaults.cardColors(\n                            containerColor = if (isMe) MaterialTheme.colorScheme.primaryContainer\n                            else if (player.name != \"Waiting...\" && player.name != \"[Disconnected]\")\n                                MaterialTheme.colorScheme.surfaceVariant\n                            else MaterialTheme.colorScheme.surface\n                        ),\n                        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)\n                    ) {\n                        Text(\n                            // Display ID for clarity during debugging\n                            text = \"${player.name} (ID: ${player.id})\" + if (isMe) \" (Host - You)\" else \"\",\n                            modifier = Modifier.padding(16.dp),\n                            style = MaterialTheme.typography.bodyLarge,\n                            color = if (player.name == \"[Disconnected]\") Color.Gray else LocalContentColor.current\n                        )\n                    }\n                }\n            } else {\n                item { Text(\"Waiting for player data...\")} // Placeholder if list is empty\n            }\n        }\n\n        Button(\n            onClick = {\n                viewModel.stopServerAndDiscovery()\n                navController.navigate(\"lobby\") {\n                    popUpTo(\"lobby\") { inclusive = true }\n                }\n            },\n            colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)\n        ) {\n            Text(\"Cancel Game\")\n        }\n\n        if (connectedCount < requiredPlayerCount) {\n            Text(\n                text = \"Game will start automatically when all players join.\",\n                style = MaterialTheme.typography.bodySmall,\n                color = Color.Gray\n            )\n        }\n    }\n}",
                "GameScreen.kt": "package com.example.mindikot.ui.screens\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyRow\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.navigation.NavController\nimport com.example.mindikot.core.engine.GameEngine // Needed for Decision and determineValidMoves\nimport com.example.mindikot.core.model.Card\nimport com.example.mindikot.core.state.InputType\nimport com.example.mindikot.ui.GameViewModel\nimport com.example.mindikot.ui.components.OtherPlayerDisplay\nimport com.example.mindikot.ui.components.CardView\nimport com.example.mindikot.ui.components.getSuitSymbol\nimport kotlinx.coroutines.flow.collectLatest\n\n@Composable\nfun GameScreen(navController: NavController, viewModel: GameViewModel = viewModel()) {\n    val gameState by viewModel.state.collectAsState()\n    val localPlayerId = viewModel.localPlayerId\n    val snackbarHostState = remember { SnackbarHostState() }\n\n    // Find the local player object (handle null briefly during init)\n    val localPlayer =\n            remember(gameState.players, localPlayerId) {\n                gameState.players.find { it.id == localPlayerId }\n            }\n\n    // Determine if it's the local player's turn\n    val isMyTurn =\n            remember(gameState.awaitingInputFromPlayerIndex, localPlayerId) {\n                gameState.awaitingInputFromPlayerIndex == localPlayerId\n            }\n\n    // Calculate valid moves when it's our turn\n    val validMoves =\n            remember(gameState, localPlayerId, isMyTurn) {\n                if (isMyTurn && localPlayer != null) {\n                    GameEngine.determineValidMoves(\n                                    playerHand = localPlayer.hand,\n                                    currentTrickPlays = gameState.currentTrickPlays,\n                                    trumpSuit = gameState.trumpSuit,\n                                    trumpRevealed = gameState.trumpRevealed\n                            )\n                            .toSet() // Use Set for faster lookups\n                } else {\n                    emptySet()\n                }\n            }\n\n    // Listen for errors\n    LaunchedEffect(Unit) {\n        viewModel.showError.collectLatest { message ->\n            snackbarHostState.showSnackbar(message = message, duration = SnackbarDuration.Short)\n        }\n    }\n\n    // Listen for navigation to results\n    LaunchedEffect(Unit) {\n        viewModel.navigateToResultScreen.collectLatest { result ->\n            // Optional: Pass result data to ResultScreen if needed\n            navController.navigate(\"result\") {\n                // Clear back stack up to lobby or game screen\n                popUpTo(\"lobby\") { inclusive = false } // Or popUpTo(\"game\") { inclusive = true }\n            }\n        }\n    }\n\n    Scaffold(snackbarHost = { SnackbarHost(hostState = snackbarHostState) }) { paddingValues ->\n        Column(\n                modifier =\n                        Modifier.fillMaxSize()\n                                .padding(paddingValues)\n                                .padding(8.dp) // Overall padding\n        ) {\n\n            // --- Top Area: Game Status ---\n            GameStatusHeader(gameState = gameState)\n\n            Spacer(modifier = Modifier.height(8.dp))\n\n            // --- Middle Area: Board (Other Players + Trick) ---\n            PlayerBoard(\n                    modifier = Modifier.weight(1f), // Takes up available space\n                    gameState = gameState,\n                    localPlayerId = localPlayerId\n            )\n\n            Spacer(modifier = Modifier.height(8.dp))\n\n            // --- Center Bottom: Action Prompt / Info ---\n            ActionPrompt(gameState = gameState, localPlayerId = localPlayerId)\n\n            Spacer(modifier = Modifier.height(8.dp))\n\n            // --- Bottom Area: Local Player Hand & Actions ---\n            if (localPlayer != null) {\n                LocalPlayerArea(\n                        localPlayerHand = localPlayer.hand,\n                        isMyTurn = isMyTurn,\n                        validMoves = validMoves,\n                        requiredInputType = gameState.requiredInputType,\n                        onCardSelected = { card -> viewModel.onCardPlayed(card) },\n                        onReveal = { viewModel.onRevealOrPass(GameEngine.Decision.REVEAL) },\n                        onPass = { viewModel.onRevealOrPass(GameEngine.Decision.PASS) }\n                )\n            } else {\n                // Placeholder if local player data isn't ready yet\n                Text(\"Loading player data...\")\n            }\n        }\n    }\n}\n\n// --- Helper Composables for GameScreen ---\n\n@Composable\nfun GameStatusHeader(gameState: com.example.mindikot.core.state.GameState) {\n    Row(\n            modifier = Modifier.fillMaxWidth().padding(horizontal = 8.dp, vertical = 4.dp),\n            horizontalArrangement = Arrangement.SpaceBetween,\n            verticalAlignment = Alignment.CenterVertically\n    ) {\n        Text(\n                text = \"Trump: ${gameState.trumpSuit?.let { getSuitSymbol(it) } ?: \"None\"}\",\n                fontWeight = FontWeight.Bold,\n                color =\n                        if (gameState.trumpRevealed) MaterialTheme.colorScheme.primary\n                        else Color.Gray\n        )\n        Text(text = \"Tricks Won:\", fontWeight = FontWeight.Bold)\n        Row {\n            gameState.teams.forEach { team ->\n                Text(\n                        text = \" T${team.id}: ${gameState.tricksWon[team.id] ?: 0}\",\n                        modifier = Modifier.padding(start = 4.dp)\n                        // Optionally color code team scores\n                        )\n            }\n        }\n    }\n    Divider() // Add a visual separator\n}\n\n@Composable\nfun PlayerBoard(\n        modifier: Modifier = Modifier,\n        gameState: com.example.mindikot.core.state.GameState,\n        localPlayerId: Int\n) {\n    // Basic layout - Needs improvement for better positioning based on player count\n    // Using BoxWithConstraints allows placing elements relative to the container size\n    BoxWithConstraints(modifier = modifier.fillMaxWidth()) {\n        val density = androidx.compose.ui.platform.LocalDensity.current\n        val widthDp = with(density) { constraints.maxWidth.toDp() }\n        val heightDp = with(density) { constraints.maxHeight.toDp() }\n\n        // --- Trick Area (Center) ---\n        Box(\n                modifier =\n                        Modifier.align(Alignment.Center)\n                                .size(\n                                        width = widthDp * 0.6f,\n                                        height = heightDp * 0.5f\n                                ), // Adjust size as needed\n                // Optional background/border for trick area\n                // .background(Color.LightGray.copy(alpha=0.2f), RoundedCornerShape(10.dp)),\n                contentAlignment = Alignment.Center\n        ) {\n            // Display cards played in the current trick\n            Row { // Simple horizontal layout for now\n                gameState.currentTrickPlays.forEach { (_, card) ->\n                    // Use a smaller card view for the trick\n                    Card(modifier = Modifier.size(50.dp, 75.dp).padding(2.dp)) {\n                        Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {\n                            Text(\n                                    text = \"${card.rank.displayName}${getSuitSymbol(card.suit)}\",\n                                    color =\n                                            com.example.mindikot.ui.components.getSuitColor(\n                                                    card.suit\n                                            ),\n                                    fontSize = 14.sp\n                            )\n                        }\n                    }\n                }\n            }\n        }\n\n        // --- Other Players ---\n        val otherPlayers = gameState.players.filter { it.id != localPlayerId }\n        // Very basic positioning based on typical 4 player layout\n        // TODO: Adapt this based on gameState.players.size (4 or 6) dynamically\n        otherPlayers.getOrNull(1)?.let { player\n            -> // Assumes player ID order corresponds roughly to seating\n            OtherPlayerDisplay(\n                    player = player,\n                    isCurrentTurn = gameState.awaitingInputFromPlayerIndex == player.id,\n                    modifier = Modifier.align(Alignment.TopCenter)\n            )\n        }\n        otherPlayers.getOrNull(0)?.let { player -> // Player typically to the left\n            OtherPlayerDisplay(\n                    player = player,\n                    isCurrentTurn = gameState.awaitingInputFromPlayerIndex == player.id,\n                    modifier = Modifier.align(Alignment.CenterStart)\n            )\n        }\n        otherPlayers.getOrNull(2)?.let { player -> // Player typically to the right\n            OtherPlayerDisplay(\n                    player = player,\n                    isCurrentTurn = gameState.awaitingInputFromPlayerIndex == player.id,\n                    modifier = Modifier.align(Alignment.CenterEnd)\n            )\n        }\n        // Add logic for players 4, 5 for 6-player game (e.g., TopLeft, TopRight, BottomLeft,\n        // BottomRight)\n    }\n}\n\n@Composable\nfun ActionPrompt(gameState: com.example.mindikot.core.state.GameState, localPlayerId: Int) {\n    val currentTurnPlayerId = gameState.awaitingInputFromPlayerIndex\n    val promptText =\n            when {\n                currentTurnPlayerId == localPlayerId -> {\n                    when (gameState.requiredInputType) {\n                        InputType.PLAY_CARD -> \"Your Turn: Play a card\"\n                        InputType.CHOOSE_TRUMP_SUIT -> \"Your Turn: Play a card to choose trump\"\n                        InputType.REVEAL_OR_PASS -> \"Your Turn: Reveal hidden card or Pass?\"\n                        null -> \"Your Turn...\" // Should ideally not happen if state logic is\n                    // correct\n                    }\n                }\n                currentTurnPlayerId != null -> {\n                    val waitingPlayerName =\n                            gameState.players.find { it.id == currentTurnPlayerId }?.name\n                                    ?: \"Opponent\"\n                    \"Waiting for $waitingPlayerName...\"\n                }\n                else -> {\n                    // No one's turn (e.g., between tricks or rounds)\n                    // Could show last trick winner briefly here using another state mechanism\n                    \"\" // Or \"Trick finished\" / \"Round Starting\" etc.\n                }\n            }\n\n    Text(\n            text = promptText,\n            modifier = Modifier.fillMaxWidth().padding(vertical = 8.dp),\n            textAlign = androidx.compose.ui.text.style.TextAlign.Center,\n            style = MaterialTheme.typography.bodyLarge,\n            fontWeight = FontWeight.Bold\n    )\n}\n\n@Composable\nfun LocalPlayerArea(\n        localPlayerHand: List<Card>,\n        isMyTurn: Boolean,\n        validMoves: Set<Card>,\n        requiredInputType: InputType?,\n        onCardSelected: (Card) -> Unit,\n        onReveal: () -> Unit,\n        onPass: () -> Unit\n) {\n    Column(horizontalAlignment = Alignment.CenterHorizontally) {\n        // --- Player Hand ---\n        LazyRow(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center) {\n            items(localPlayerHand, key = { \"${it.suit}-${it.rank}\" }) { card ->\n                CardView(\n                        card = card,\n                        isValidMove = card in validMoves,\n                        isPlayable =\n                                isMyTurn &&\n                                        (requiredInputType == InputType.PLAY_CARD ||\n                                                requiredInputType == InputType.CHOOSE_TRUMP_SUIT),\n                        onCardSelected = onCardSelected\n                )\n            }\n        }\n\n        Spacer(modifier = Modifier.height(8.dp))\n\n        // --- Action Buttons (Conditional) ---\n        if (isMyTurn && requiredInputType == InputType.REVEAL_OR_PASS) {\n            Row(horizontalArrangement = Arrangement.spacedBy(16.dp)) {\n                Button(onClick = onReveal) { Text(\"Reveal Trump\") }\n                Button(onClick = onPass) { Text(\"Pass\") }\n            }\n        }\n    }\n}\n",
                "LobbyScreen.kt": "package com.example.mindikot.ui.screens\n\n// Required Android & Compose Imports\nimport android.Manifest\nimport android.app.Activity // Needed for shouldShowRequestPermissionRationale\nimport android.content.Context\nimport android.content.Intent\nimport android.content.pm.PackageManager\nimport android.net.Uri\nimport android.os.Build\nimport android.provider.Settings\nimport android.widget.Toast\nimport androidx.activity.compose.rememberLauncherForActivityResult\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.compose.foundation.BorderStroke\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.foundation.verticalScroll\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.unit.dp\nimport androidx.core.app.ActivityCompat // Needed\nimport androidx.core.content.ContextCompat\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.ViewModelProvider\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.navigation.NavController\nimport com.example.mindikot.core.model.GameMode\nimport com.example.mindikot.ui.GameViewModel\nimport com.example.mindikot.ui.GameViewModelFactory\nimport android.net.nsd.NsdServiceInfo\n\n@Composable\nfun LobbyScreen(\n    navController: NavController,\n    viewModel: GameViewModel = viewModel(\n        factory = GameViewModelFactory(LocalContext.current.applicationContext)\n    )\n) {\n    var playerName by remember { mutableStateOf(\"\") }\n    var selectedRole by remember { mutableStateOf<String?>(null) }\n    val context = LocalContext.current\n    val activity = context as? Activity\n\n    var showRationaleDialog by remember { mutableStateOf(false) }\n    var showSettingsGuidance by remember { mutableStateOf(false) }\n\n    // --- Permission Handling ---\n    val requiredPermission = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {\n        Manifest.permission.ACCESS_FINE_LOCATION\n    } else {\n        Manifest.permission.INTERNET // Or just check INTERNET\n    }\n    var hasPermission by remember {\n        mutableStateOf(\n            ContextCompat.checkSelfPermission(context, requiredPermission) == PackageManager.PERMISSION_GRANTED\n        )\n    }\n    val permissionLauncher = rememberLauncherForActivityResult(\n        ActivityResultContracts.RequestPermission()\n    ) { isGranted: Boolean ->\n        hasPermission = isGranted\n        if (!isGranted) {\n            if (activity != null && !ActivityCompat.shouldShowRequestPermissionRationale(activity, requiredPermission)) {\n                showSettingsGuidance = true\n            } else {\n                Toast.makeText(context, \"Permission denied.\", Toast.LENGTH_LONG).show()\n            }\n            selectedRole = null\n        } else {\n            Toast.makeText(context, \"Permission granted!\", Toast.LENGTH_SHORT).show()\n        }\n    }\n    // --- End Permission Handling ---\n\n    LaunchedEffect(playerName) { if (playerName.isBlank()) selectedRole = null }\n\n    // REMOVE OR COMMENT OUT the DisposableEffect that stops the server here\n    // DisposableEffect(Unit) {\n    //     onDispose {\n    //         Log.d(\"LobbyScreen\", \"DisposableEffect onDispose triggered\") // Add log\n    //         viewModel.stopServerAndDiscovery() // DO NOT STOP HERE\n    //         viewModel.disconnectFromServer()\n    //         viewModel.stopNsdDiscovery()\n    //     }\n    // }\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(24.dp)\n            .verticalScroll(rememberScrollState()),\n        verticalArrangement = Arrangement.spacedBy(20.dp),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\"Mindikot Lobby\", style = MaterialTheme.typography.headlineMedium)\n\n        OutlinedTextField(value = playerName,\n            onValueChange = { playerName = it.trim() },\n            label = { Text(\"Enter your name\") },\n            modifier = Modifier.fillMaxWidth(),\n            singleLine = true\n        )\n        Text(\"Select your role:\", style = MaterialTheme.typography.titleMedium)\n\n        // --- Role Selection Logic ---\n        Row(\n            horizontalArrangement = Arrangement.spacedBy(12.dp),\n            verticalAlignment = Alignment.CenterVertically\n        ) {\n            listOf(\"Host\", \"Joiner\").forEach { role ->\n                Button(\n                    onClick = {\n                        if (playerName.isBlank()) {\n                            Toast.makeText(context, \"Please enter name\", Toast.LENGTH_SHORT).show()\n                            return@Button\n                        }\n\n                        // Check current permission status first\n                        val currentPermissionStatus = ContextCompat.checkSelfPermission(context, requiredPermission)\n                        hasPermission = (currentPermissionStatus == PackageManager.PERMISSION_GRANTED)\n\n                        when {\n                            hasPermission -> { // Permission OK\n                                selectedRole = role\n                                // Clear other network state ONLY IF switching roles\n                                if (role == \"Host\") {\n                                    viewModel.stopNsdDiscovery() // Stop searching if switching to host\n                                    viewModel.disconnectFromServer() // Disconnect if switching to host\n                                } else {\n                                    viewModel.stopServerAndDiscovery() // Stop hosting if switching to joiner\n                                }\n                            }\n                            // Need to show rationale?\n                            activity != null && ActivityCompat.shouldShowRequestPermissionRationale(activity, requiredPermission) -> {\n                                showRationaleDialog = true // Show explanation\n                            }\n                            // Need to request permission\n                            else -> {\n                                permissionLauncher.launch(requiredPermission) // Launch request\n                            }\n                        }\n                    },\n                    colors = ButtonDefaults.buttonColors(\n                        containerColor = if (selectedRole == role) MaterialTheme.colorScheme.primary else Color.Gray\n                    )\n                ) { Text(if(role == \"Joiner\") \"Randi\" else \"Host\") } // Using \"Randi\" for Joiner button\n            }\n        }\n\n        // Rationale Dialog\n        if (showRationaleDialog) {\n            AlertDialog(\n                onDismissRequest = { showRationaleDialog = false },\n                title = { Text(\"Permission Needed\") },\n                text = { Text(\"Finding games on the local network requires the Location permission on this version of Android.\") },\n                confirmButton = {\n                    Button(onClick = {\n                        permissionLauncher.launch(requiredPermission)\n                        showRationaleDialog = false\n                    }) { Text(\"Grant Permission\") }\n                },\n                dismissButton = { Button(onClick = { showRationaleDialog = false }) { Text(\"Cancel\") } }\n            )\n        }\n        // Settings Guidance Dialog\n        if (showSettingsGuidance) {\n            AlertDialog(\n                onDismissRequest = { showSettingsGuidance = false },\n                title = { Text(\"Permission Required\") },\n                text = { Text(\"Network permission was denied. Please grant Location permission in App Settings to host or join games.\") },\n                confirmButton = {\n                    Button(onClick = {\n                        val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)\n                        val uri = Uri.fromParts(\"package\", context.packageName, null)\n                        intent.data = uri\n                        context.startActivity(intent)\n                        showSettingsGuidance = false\n                    }) { Text(\"Open Settings\") }\n                },\n                dismissButton = { Button(onClick = { showSettingsGuidance = false }) { Text(\"Cancel\") } }\n            )\n        }\n\n        // --- Conditional UI ---\n        val canProceed = hasPermission // Simplified check\n        if (canProceed) {\n            when (selectedRole) {\n                \"Host\" -> HostSection(navController, viewModel, playerName)\n                \"Joiner\" -> JoinerSection(navController, viewModel, playerName)\n            }\n        } else if (selectedRole != null) {\n            // Show message if role selected but permission denied/pending\n            Text(\n                \"Please grant Location permission to continue as $selectedRole.\",\n                color = MaterialTheme.colorScheme.error,\n                style = MaterialTheme.typography.bodySmall,\n                textAlign = TextAlign.Center\n            )\n        }\n\n    } // End Main Column\n}\n\n\n// --- HostSection Composable --- (No changes needed here)\n@Composable\nfun HostSection(navController: NavController, viewModel: GameViewModel, hostPlayerName: String) {\n    // ... (Implementation remains the same)\n    val hostIp by viewModel.hostIpAddress.collectAsState()\n\n    Column(\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.spacedBy(8.dp),\n        modifier = Modifier.fillMaxWidth() // Allow column to take width\n    ) {\n        if (hostIp != null) {\n            Text(\n                \"Hosting on: $hostIp\",\n                style = MaterialTheme.typography.bodySmall,\n                textAlign = TextAlign.Center\n            )\n            Text(\n                \"(Others on the same WiFi should find your game)\",\n                style = MaterialTheme.typography.bodySmall,\n                textAlign = TextAlign.Center,\n                color = Color.Gray\n            )\n        } else {\n            Text(\"Advertising game on network...\", style = MaterialTheme.typography.bodySmall)\n        }\n        GameConfigCard(\n            navController = navController,\n            viewModel = viewModel,\n            hostPlayerName = hostPlayerName\n        )\n    }\n}\n\n// --- JoinerSection Composable --- (No changes needed here)\n@Composable\nfun JoinerSection(\n    navController: NavController,\n    viewModel: GameViewModel,\n    joinerPlayerName: String\n) {\n    // ... (Implementation remains the same)\n    val discoveredGames by viewModel.discoveredHosts.collectAsState()\n    val context = LocalContext.current\n\n    DisposableEffect(Unit) {\n        viewModel.startNsdDiscovery()\n        onDispose { viewModel.stopNsdDiscovery() }\n    }\n\n    Column(\n        verticalArrangement = Arrangement.spacedBy(16.dp),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = Modifier.fillMaxWidth()\n    ) {\n        Text(\"Join a Game\", style = MaterialTheme.typography.titleMedium)\n\n        Button(onClick = {\n            viewModel.stopNsdDiscovery() // Stop previous first\n            viewModel.startNsdDiscovery() // Restart discovery\n            Toast.makeText(context, \"Refreshing game list...\", Toast.LENGTH_SHORT).show()\n        }) { Text(\"Refresh Game List\") }\n\n        Spacer(modifier = Modifier.height(8.dp))\n\n        // Game List Area\n        Box(modifier = Modifier.heightIn(min = 100.dp, max = 250.dp)) {\n            if (discoveredGames.isEmpty()) {\n                Column(\n                    modifier = Modifier.fillMaxSize(), // Fill the box\n                    horizontalAlignment = Alignment.CenterHorizontally,\n                    verticalArrangement = Arrangement.Center\n                ) {\n                    CircularProgressIndicator(modifier = Modifier.size(30.dp))\n                    Text(\n                        \"Searching for games on network...\",\n                        style = MaterialTheme.typography.bodyMedium,\n                        modifier = Modifier.padding(top = 8.dp),\n                        textAlign = TextAlign.Center\n                    )\n                }\n            } else {\n                LazyColumn(modifier = Modifier.fillMaxWidth()) {\n                    item { // Header item\n                        Text(\n                            \"Available Games:\",\n                            style = MaterialTheme.typography.titleSmall,\n                            modifier = Modifier.padding(bottom = 8.dp)\n                        )\n                    }\n                    items(discoveredGames, key = { it.serviceName }) { serviceInfo ->\n                        Button(\n                            onClick = {\n                                @Suppress(\"DEPRECATION\") // Suppress for serviceInfo.host\n                                if (serviceInfo.host == null || serviceInfo.port <= 0) {\n                                    Toast.makeText(context,\"Game details not ready yet.\", Toast.LENGTH_SHORT).show()\n                                } else {\n                                    Toast.makeText(context, \"Connecting...\", Toast.LENGTH_SHORT).show()\n                                    viewModel.connectToDiscoveredHost(serviceInfo, joinerPlayerName)\n                                    navController.navigate(\"waiting_for_players\")\n                                }\n                            },\n                            modifier = Modifier.fillMaxWidth().padding(vertical = 4.dp) // Add padding\n                        ) {\n                            @Suppress(\"DEPRECATION\") // Suppress for serviceInfo.host\n                            Text(\n                                \"${serviceInfo.serviceName} (${serviceInfo.host?.hostAddress ?: \"IP resolving...\"})\"\n                            )\n                        }\n                    }\n                }\n            }\n        } // End Box\n    } // End Column\n}\n\n\n// --- GameConfigCard Composable --- (No changes needed here)\n@Composable\nfun GameConfigCard(navController: NavController, viewModel: GameViewModel, hostPlayerName: String) {\n    // ... (Implementation remains the same)\n    fun GameMode.displayName(): String = when (this) {\n        GameMode.CHOOSE_WHEN_EMPTY -> \"Choose When Empty\"\n        GameMode.FIRST_CARD_HIDDEN -> \"First Card Hidden\"\n    }\n\n    var numberOfPlayers by remember { mutableStateOf(4) }\n    var gameMode by remember { mutableStateOf(GameMode.CHOOSE_WHEN_EMPTY) }\n\n    Card(\n        modifier = Modifier.fillMaxWidth().padding(top = 16.dp),\n        shape = RoundedCornerShape(16.dp),\n        border = BorderStroke(1.dp, MaterialTheme.colorScheme.outline),\n        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)\n    ) {\n        Column(\n            modifier = Modifier.fillMaxWidth().padding(20.dp),\n            horizontalAlignment = Alignment.CenterHorizontally,\n            verticalArrangement = Arrangement.spacedBy(16.dp)\n        ) {\n            Text(text = \"Host Game Configuration\", style = MaterialTheme.typography.titleLarge)\n            Divider()\n\n            ConfigOptionRow(label = \"Number of Players:\") {\n                listOf(4, 6).forEach { count ->\n                    ConfigButton(\n                        text = \"$count Players\",\n                        isSelected = numberOfPlayers == count,\n                        onClick = { numberOfPlayers = count }\n                    )\n                }\n            }\n\n            ConfigOptionRow(label = \"Game Mode:\") {\n                GameMode.values().forEach { mode ->\n                    ConfigButton(\n                        text = mode.displayName(),\n                        isSelected = gameMode == mode,\n                        onClick = { gameMode = mode }\n                    )\n                }\n            }\n\n            Divider()\n\n            Button(\n                onClick = {\n                    viewModel.initializeGameSettings(\n                        playerName = hostPlayerName,\n                        mode = gameMode,\n                        host = true,\n                        playersNeeded = numberOfPlayers\n                    )\n                    viewModel.startServerAndDiscovery() // Start server after setting state\n                    navController.navigate(\"game_host\")\n                },\n                modifier = Modifier.fillMaxWidth().padding(top = 8.dp)\n            ) { Text(\"Create Game & Wait\") }\n        }\n    }\n}\n\n// --- Helper Composables --- (Keep ConfigOptionRow, ConfigButton as before)\n@Composable\nprivate fun ConfigOptionRow(label: String, content: @Composable RowScope.() -> Unit) {\n    // ... (Implementation from previous step)\n    Column(\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.spacedBy(8.dp),\n        modifier = Modifier.fillMaxWidth() // Allow row to take width\n    ) {\n        Text(label, style = MaterialTheme.typography.titleMedium)\n        Row(\n            horizontalArrangement = Arrangement.spacedBy(12.dp, Alignment.CenterHorizontally), // Center buttons\n            verticalAlignment = Alignment.CenterVertically,\n            modifier = Modifier.padding(top = 4.dp).fillMaxWidth() // Ensure row takes width\n        ) { content() }\n    }\n}\n\n@Composable\nprivate fun ConfigButton(text: String, isSelected: Boolean, onClick: () -> Unit) {\n    // ... (Implementation from previous step)\n    Button(\n        onClick = onClick,\n        colors = ButtonDefaults.buttonColors(\n            containerColor = if (isSelected) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.secondaryContainer,\n            contentColor = if (isSelected) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSecondaryContainer\n        ),\n        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp) // Adjust padding\n    ) {\n        Text(text, textAlign = TextAlign.Center)\n    }\n}\n\n\n// --- ViewModel Factory --- (Keep as before)\nclass GameViewModelFactory(private val context: Context) : ViewModelProvider.Factory {\n    // ... (Implementation from previous step)\n    override fun <T : ViewModel> create(modelClass: Class<T>): T {\n        if (modelClass.isAssignableFrom(GameViewModel::class.java)) {\n            @Suppress(\"UNCHECKED_CAST\")\n            return GameViewModel(context.applicationContext) as T\n        }\n        throw IllegalArgumentException(\"Unknown ViewModel class: ${modelClass.name}\")\n    }\n}",
                "ResultScreen.kt": "package com.example.mindikot.ui.screens\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.unit.dp\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.navigation.NavHostController\nimport com.example.mindikot.core.engine.RoundEvaluator\nimport com.example.mindikot.ui.GameViewModel // Ensure correct import\n\n@Composable\nfun ResultScreen(\n    navController: NavHostController,\n    viewModel: GameViewModel = viewModel(\n        factory = GameViewModelFactory(LocalContext.current.applicationContext) // Use factory if needed\n    )\n) {\n    val gameState by viewModel.state.collectAsState()\n\n    // Calculate result based on last known state\n    val roundResult = remember(gameState) {\n        if (gameState.players.isNotEmpty()) {\n            RoundEvaluator.evaluateRound(gameState)\n        } else {\n            RoundEvaluator.RoundResult(null, false)\n        }\n    }\n\n    Column(\n        modifier = Modifier.fillMaxSize().padding(24.dp),\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\n            text = roundResult.winningTeam?.let { \"Team ${it.id} Wins!\" } ?: \"Round is a Draw!\",\n            style = MaterialTheme.typography.headlineLarge\n        )\n        Spacer(modifier = Modifier.height(16.dp))\n\n        if (roundResult.winningTeam != null) {\n            Text(\n                text = if (roundResult.isKot) \"KOT! All four 10s collected!\" else \"Regular Win\",\n                style = MaterialTheme.typography.bodyLarge\n            )\n        } else {\n            Text(text = \"Scores remain unchanged.\", style = MaterialTheme.typography.bodyLarge)\n        }\n        Spacer(modifier = Modifier.height(32.dp))\n\n        Button(\n            onClick = {\n                // No need to stop server/disconnect here. That happens when LobbyScreen recomposes.\n                // Just navigate back.\n                navController.navigate(\"lobby\") {\n                    popUpTo(\"lobby\") { inclusive = true } // Pop everything back to lobby start\n                }\n            }\n        ) { Text(\"Back to Lobby\") }\n\n        // TODO: Add \"Play Again\" logic if desired (Host only)\n        // This would involve the host triggering a state reset and dealing again.\n    }\n}",
                "WaitingForPlayersScreen.kt": "package com.example.mindikot.ui.screens\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport android.widget.Toast\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.unit.dp\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.navigation.NavController\nimport com.example.mindikot.ui.GameViewModel\nimport kotlinx.coroutines.flow.collectLatest\nimport com.example.mindikot.ui.GameViewModelFactory\n\n@Composable\nfun WaitingForPlayersScreen(\n    navController: NavController,\n    viewModel: GameViewModel = viewModel(\n        factory = GameViewModelFactory(LocalContext.current.applicationContext)\n    )\n) {\n    val gameState by viewModel.state.collectAsState()\n    // Use the dedicated count StateFlow\n    val connectedCount by viewModel.connectedPlayersCount.collectAsState()\n    val isHost = viewModel.isHost // Should be false for this screen\n    // Get the definitive required count from ViewModel\n    val requiredPlayers = viewModel.requiredPlayerCount\n    val gameStarted by viewModel.gameStarted.collectAsState()\n    val localPlayerId = viewModel.localPlayerId\n\n    // Log state changes for debugging UI\n    LaunchedEffect(connectedCount, gameState.players) {\n        println(\"[UI - WaitingScreen] connectedCount = $connectedCount, required = $requiredPlayers\")\n        println(\"[UI - WaitingScreen] Player List State: ${gameState.players.map { p -> Pair(p.id, p.name) }}\")\n        println(\"[UI - WaitingScreen] Local Player ID = $localPlayerId\")\n    }\n\n    // Joiner: Navigate when game starts\n    LaunchedEffect(gameStarted, isHost) {\n        if (!isHost && gameStarted) {\n            println(\"[UI - WaitingScreen] Game started! Navigating to game screen.\") // Log nav\n            navController.navigate(\"game\") {\n                popUpTo(\"waiting_for_players\") { inclusive = true }\n            }\n        }\n    }\n\n    val context = LocalContext.current\n\n    LaunchedEffect(Unit) {\n        viewModel.state.collectLatest { state ->\n            if (!isHost && localPlayerId != -1 &&\n                (state.players.none { it.id == localPlayerId } || state.players.find { it.id == 0 }?.name == \"[Disconnected]\")) {\n                println(\"[UI - WaitingScreen] Disconnected detected. Navigating to lobby.\") // Log nav\n                Toast.makeText(context, \"Disconnected from host.\", Toast.LENGTH_LONG).show()\n                viewModel.disconnectFromServer()\n                navController.navigate(\"lobby\") {\n                    popUpTo(\"lobby\") { inclusive = true }\n                }\n            }\n        }\n    }\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(24.dp),\n        verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\"Waiting for Players...\", style = MaterialTheme.typography.headlineMedium)\n        CircularProgressIndicator()\n\n        // Use connectedCount and requiredPlayers correctly\n        if (requiredPlayers > 0) { // Display only if requiredPlayers is initialized\n            Text(\"Connected Players: $connectedCount / $requiredPlayers\")\n        }\n\n        Spacer(modifier = Modifier.height(16.dp))\n\n        Text(\"Players in Lobby:\", style = MaterialTheme.typography.titleMedium)\n        // Display players from the received gameState\n        Column(horizontalAlignment = Alignment.Start, modifier = Modifier.padding(start = 16.dp)) {\n            if (gameState.players.isNotEmpty()) {\n                gameState.players.forEach { player ->\n                    val suffix = when {\n                        player.id == localPlayerId -> \" (You)\"\n                        player.id == 0 -> \" (Host)\" // Client sees player 0 as Host\n                        else -> \"\"\n                    }\n                    Text(\n                        // Display ID for clarity during debugging\n                        text = \"- ${player.name} (ID: ${player.id})$suffix\",\n                        style = MaterialTheme.typography.bodyLarge,\n                        color = if (player.name == \"[Disconnected]\") Color.Gray else LocalContentColor.current\n                    )\n                }\n            } else {\n                Text(\"Waiting for lobby details...\")\n            }\n        }\n\n        Spacer(modifier = Modifier.height(32.dp))\n\n        // Client only has Leave button here\n        Text(\"Waiting for the host to start the game...\")\n        Button(onClick = {\n            viewModel.disconnectFromServer()\n            navController.navigate(\"lobby\") { popUpTo(\"lobby\") {inclusive = true} }\n        }, colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.secondary)) {\n            Text(\"Leave Lobby\")\n        }\n    }\n}"
            },
            "theme": {
                "Color.kt": "package com.example.mindikot.ui.theme\n\nimport androidx.compose.ui.graphics.Color\n\nval Purple80 = Color(0xFFD0BCFF)\nval PurpleGrey80 = Color(0xFFCCC2DC)\nval Pink80 = Color(0xFFEFB8C8)\n\nval Purple40 = Color(0xFF6650a4)\nval PurpleGrey40 = Color(0xFF625b71)\nval Pink40 = Color(0xFF7D5260)\n",
                "Theme.kt": "package com.example.mindikot.ui.theme\n\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.platform.LocalContext\n\nprivate val LightColors = lightColorScheme(\n    primary = Purple40,\n    secondary = PurpleGrey40,\n    tertiary = Pink40\n)\n\n@Composable\nfun MindikotTheme(\n    useDarkTheme: Boolean = isSystemInDarkTheme(),\n    content: @Composable () -> Unit\n) {\n    MaterialTheme(\n        colorScheme = LightColors,\n        typography = Typography(),\n        content = content\n    )\n}\n"
            }
        }
    }
}