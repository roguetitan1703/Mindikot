{
    "project_name": "mindikot",
    "structure": {
        "core": {
            "engine": {
                "DeckGenerator.kt": "package com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\n\nobject DeckGenerator {\n    /**\n     * Generates a standard Mindikot deck. For 6 players, Twos are excluded.\n     * @param numPlayers The number of players (4 or 6).\n     * @return A shuffled list of cards for the game.\n     */\n    fun generateDeck(numPlayers: Int): MutableList<Card> {\n        require(numPlayers == 4 || numPlayers == 6) { \"Mindikot supports 4 or 6 players only.\" }\n        val includeTwos = (numPlayers == 4)\n\n        val deck = mutableListOf<Card>()\n        val allSuits = Suit.values()\n        val allRanks = Rank.values()\n\n        for (suit in allSuits) {\n            for (rank in allRanks) {\n                // Skip Twos if playing with 6 players\n                if (!includeTwos && rank == Rank.TWO) {\n                    continue\n                }\n                deck.add(Card(suit, rank))\n            }\n        }\n        // Shuffle the generated deck thoroughly before returning\n        return deck.shuffled().toMutableList()\n    }\n}\n",
                "GameEngine.kt": "package com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\nimport com.example.mindikot.core.state.GameState\nimport com.example.mindikot.core.state.InputType\n\n/**\n * Manages the core game flow, including playing tricks and handling state transitions. NOTE: This\n * implementation outlines the logic flow. A real implementation would need mechanisms (like\n * callbacks, suspend functions, or StateFlow) to handle asynchronous player input from the\n * UI/ViewModel layer. The points requiring input are marked.\n */\nobject GameEngine {\n\n    /**\n     * Determines the set of cards a player can legally play on their turn.\n     *\n     * @param playerHand The list of cards currently in the player's hand.\n     * @param currentTrickPlays The list of (Player, Card) pairs already played in the current\n     * trick.\n     * @param trumpSuit The current trump suit (null if not set).\n     * @param trumpRevealed Whether trump has been revealed.\n     * @return A list of cards from the player's hand that are valid to play.\n     */\n    fun determineValidMoves(\n            playerHand: List<Card>,\n            currentTrickPlays: List<Pair<Player, Card>>,\n            trumpSuit: Suit?,\n            trumpRevealed: Boolean\n    ): List<Card> {\n\n        // If player is leading the trick (no cards played yet)\n        if (currentTrickPlays.isEmpty()) {\n            return playerHand // Can lead any card\n        }\n\n        val leadCard = currentTrickPlays.first().second\n        val leadSuit = leadCard.suit\n\n        // Check if player can follow the lead suit\n        val cardsInLeadSuit = playerHand.filter { it.suit == leadSuit }\n        if (cardsInLeadSuit.isNotEmpty()) {\n            return cardsInLeadSuit // Must follow suit\n        }\n\n        // --- Cannot follow suit ---\n\n        // Check if trump is revealed and active\n        if (trumpRevealed && trumpSuit != null) {\n            // Rule: If cannot follow suit and trump is set, play ANY card.\n            return playerHand\n        } else {\n            // Rule: If cannot follow suit and trump is NOT set, play ANY card.\n            // The decision to CHOOSE/REVEAL/PASS happens separately.\n            // Special case: Mode B Reveal requires trump play if possible AFTER reveal.\n            // This function determines playable cards BEFORE that decision point.\n            return playerHand\n        }\n    }\n\n    // --- Interaction State Management Functions ---\n\n    /**\n     * Prepares the game state to request input from the appropriate player. This should be called\n     * at the start of a trick or after a player has played.\n     *\n     * @param state The current GameState to modify.\n     * @param playerIndex The index of the player whose turn it is.\n     * @return The modified GameState with updated input requirements.\n     */\n    fun requestInput(state: GameState, playerIndex: Int): GameState {\n        val currentPlayer = state.players[playerIndex]\n\n        if (state.currentTrickPlays.isEmpty()) { // Leading the trick\n            state.requiredInputType = InputType.PLAY_CARD\n        } else {\n            val leadSuit = state.currentTrickPlays.first().second.suit\n            val canFollowSuit = currentPlayer.hand.any { it.suit == leadSuit }\n\n            if (canFollowSuit) {\n                state.requiredInputType = InputType.PLAY_CARD\n            } else { // Cannot follow suit\n                if (state.trumpRevealed) {\n                    state.requiredInputType = InputType.PLAY_CARD // Play any card\n                } else { // Trump not revealed - need trump decision\n                    when (state.gameMode) {\n                        GameMode.CHOOSE_WHEN_EMPTY ->\n                                state.requiredInputType =\n                                        InputType.CHOOSE_TRUMP_SUIT // Player must play card to set\n                        // trump\n                        GameMode.FIRST_CARD_HIDDEN ->\n                                state.requiredInputType =\n                                        InputType.REVEAL_OR_PASS // Player chooses Reveal or Pass\n                    }\n                }\n            }\n        }\n        state.awaitingInputFromPlayerIndex = playerIndex\n        println(\n                \"GameEngine: Requesting ${state.requiredInputType} from Player ${state.players[playerIndex].name}\"\n        ) // Logging\n        return state\n    }\n\n    /**\n     * Processes the input received from a player (card played or trump decision). Validates the\n     * input against the rules and current state. Advances the game state (plays card, sets trump,\n     * finishes trick/round).\n     *\n     * @param currentState The current state of the game.\n     * @param playerInput The input received from the player (e.g., Card object, Decision enum).\n     * @return An updated GameState. The state might indicate further input is needed from the next\n     * player, or that the round/game ended.\n     */\n    fun processPlayerInput(\n            currentState: GameState,\n            playerInput:\n                    Any // Could be Card, Decision (Reveal/Pass), Suit (for potential future Mode A\n            // choice)\n            ): GameState {\n\n        val playerIndex =\n                currentState.awaitingInputFromPlayerIndex\n                        ?: run {\n                            println(\"Error: processPlayerInput called when no input was expected.\")\n                            return currentState // Or throw error\n                        }\n        val currentPlayer = currentState.players[playerIndex]\n        val currentRequirement = currentState.requiredInputType\n\n        println(\n                \"GameEngine: Processing input from Player ${currentPlayer.name}, expected: $currentRequirement, received: $playerInput\"\n        ) // Logging\n\n        // --- Validate and Process Input ---\n        when (currentRequirement) {\n            InputType.CHOOSE_TRUMP_SUIT -> {\n                // Mode A: Expecting a Card to be played which sets the trump\n                val playedCard = playerInput as? Card\n                if (playedCard == null || !currentPlayer.hand.contains(playedCard)) {\n                    println(\"Error: Invalid card provided for CHOOSE_TRUMP_SUIT.\")\n                    return currentState // Re-request input\n                }\n                // Validate it's a valid play (must be unable to follow suit)\n                val leadSuit = currentState.currentTrickPlays.firstOrNull()?.second?.suit\n                if (leadSuit != null && currentPlayer.hand.any { it.suit == leadSuit }) {\n                    println(\"Error: Player could follow suit, should not be choosing trump.\")\n                    return currentState // State logic error or invalid input sequence\n                }\n\n                TrumpHandler.setTrumpFromPlayedCard(currentState, playedCard)\n                playCard(currentState, currentPlayer, playedCard) // Play the card\n            }\n            InputType.REVEAL_OR_PASS -> {\n                // Mode B: Expecting a Decision (Reveal or Pass)\n                when (playerInput as? Decision) {\n                    Decision.REVEAL -> {\n                        TrumpHandler.revealHiddenTrump(currentState)\n                        // Now need player to play (Must play trump if possible)\n                        currentState.requiredInputType = InputType.PLAY_CARD\n                        currentState.awaitingInputFromPlayerIndex =\n                                playerIndex // Still this player's turn\n                        println(\n                                \"GameEngine: Player revealed trump. Requesting card play (must play trump if possible).\"\n                        )\n                        return currentState // Request card input with reveal constraint\n                    }\n                    Decision.PASS -> {\n                        TrumpHandler.handleTrumpPass(currentState)\n                        // Player plays ANY card\n                        currentState.requiredInputType = InputType.PLAY_CARD\n                        currentState.awaitingInputFromPlayerIndex =\n                                playerIndex // Still this player's turn\n                        println(\"GameEngine: Player passed trump. Requesting any card play.\")\n                        return currentState // Request card input (any card valid)\n                    }\n                    else -> {\n                        println(\"Error: Invalid decision provided for REVEAL_OR_PASS.\")\n                        return currentState // Re-request input\n                    }\n                }\n            }\n            InputType.PLAY_CARD -> {\n                val playedCard = playerInput as? Card\n                if (playedCard == null || !currentPlayer.hand.contains(playedCard)) {\n                    println(\"Error: Invalid card provided for PLAY_CARD.\")\n                    return currentState // Re-request input\n                }\n\n                // --- Complex Validation for PLAY_CARD ---\n                val leadSuit = currentState.currentTrickPlays.firstOrNull()?.second?.suit\n                val canFollowSuit =\n                        if (leadSuit != null) currentPlayer.hand.any { it.suit == leadSuit }\n                        else false\n\n                // 1. Must follow suit if possible?\n                if (leadSuit != null && playedCard.suit != leadSuit && canFollowSuit) {\n                    println(\n                            \"Error: Player must follow suit $leadSuit but played ${playedCard.suit}.\"\n                    )\n                    return currentState // Re-request input\n                }\n\n                // 2. Mode B Post-Reveal Constraint: Must play trump if revealed and possible?\n                // Need a way to know if this PLAY_CARD followed a REVEAL action in the same turn\n                // cycle...\n                // This architecture makes tracking that tricky. A state machine or temporary flag\n                // might be needed.\n                // Assuming for now the UI/ViewModel layer handles this constraint check *before*\n                // sending.\n\n                // If validation passes:\n                playCard(currentState, currentPlayer, playedCard)\n            }\n            null -> {\n                println(\"Error: processPlayerInput called when requiredInputType is null.\")\n                return currentState\n            }\n        }\n\n        // --- Post-Play State Update ---\n        currentState.requiredInputType = null // Reset requirement after successful processing\n        currentState.awaitingInputFromPlayerIndex = null // Clear awaiting player\n\n        // Check if trick is complete\n        if (currentState.currentTrickPlays.size == currentState.players.size) {\n            finishTrick(\n                    currentState\n            ) // Determine winner, collect cards, update tricksWon, set next leader\n\n            // Check if round ended (hands are empty)\n            if (currentState.players.first().hand.isEmpty()) {\n                println(\"GameEngine: Round finished.\")\n                // --- End of Round ---\n                // Caller (ViewModel) should check hand size and call RoundEvaluator\n                // and handle scoring/next round setup.\n            } else {\n                // Start next trick by requesting input from the new leader\n                return requestInput(currentState, currentState.currentLeaderIndex)\n            }\n        } else {\n            // Trick continues, request input from the next player\n            val nextPlayerIndex = (playerIndex + 1) % currentState.players.size\n            return requestInput(currentState, nextPlayerIndex)\n        }\n\n        return currentState // Return the final state after processing\n    }\n\n    /** Helper to add card to trick plays and remove from hand */\n    private fun playCard(state: GameState, player: Player, card: Card) {\n        state.currentTrickPlays.add(player to card)\n        player.hand.remove(card)\n        println(\"GameEngine: Player ${player.name} played ${card}\") // Logging\n    }\n\n    /** Called when a trick is complete to determine winner and collect cards. */\n    private fun finishTrick(state: GameState) {\n        println(\"GameEngine: Trick finished. Plays: ${state.currentTrickPlays.map { it.second }}\")\n        val winnerPlayer =\n                TrickHandler.determineTrickWinner(state.currentTrickPlays, state.trumpSuit)\n        val winnerIndex = state.players.indexOf(winnerPlayer)\n        println(\"GameEngine: Trick winner: ${winnerPlayer.name}\") // Logging\n\n        // Collect cards for the winning team\n        val winningTeam =\n                state.teams.first {\n                    it.id == winnerPlayer.teamId\n                } // Assuming player.teamId is correct\n        winningTeam.collectedCards.addAll(state.currentTrickPlays.map { it.second })\n        // println(\"Team ${winningTeam.id} collected cards. Total tens: ${winningTeam.countTens()}\")\n        // // Logging\n\n        // --- Update trick count ---\n        val currentTrickCount = state.tricksWon.getOrDefault(winningTeam.id, 0)\n        state.tricksWon[winningTeam.id] = currentTrickCount + 1 // Increment trick count\n        println(\n                \"GameEngine: Team ${winningTeam.id} tricks won this round: ${state.tricksWon[winningTeam.id]}\"\n        ) // Logging trick count\n\n        // Clear trick plays and set next leader\n        state.currentTrickPlays.clear()\n        state.currentLeaderIndex = winnerIndex\n\n        // Reset input requirement for the start of the next trick\n        // The requestInput function will be called next, setting the specific input type.\n        state.requiredInputType = null\n        state.awaitingInputFromPlayerIndex = null\n    }\n\n    // Enum for Reveal/Pass decision\n    enum class Decision {\n        REVEAL,\n        PASS\n    }\n}\n",
                "RoundEvaluator.kt": "package com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\nimport com.example.mindikot.core.state.GameState\n\nobject RoundEvaluator {\n\n    /**\n     * Data class to hold the result of a round evaluation.\n     * @property winningTeam The team that won the round (can be null if draw).\n     * @property isKot True if the win was due to collecting all four Tens.\n     */\n    data class RoundResult(val winningTeam: Team?, val isKot: Boolean)\n\n    /**\n     * Evaluates the end of a round: checks for Kot, then majority of tens, then trick tie-breaker.\n     *\n     * @param state The final GameState at the end of the round.\n     * @return RoundResult indicating the winning team (or null for draw) and whether it was a Kot\n     * win.\n     */\n    fun evaluateRound(state: GameState): RoundResult {\n        val teams = state.teams\n        println(\"Evaluating round end...\") // Logging\n\n        // 1. Instant Kot Check\n        teams.find { it.hasKot() }?.let {\n            println(\"Team ${it.id} wins round by KOT!\") // Logging\n            return RoundResult(it, true)\n        }\n\n        // 2. Count Tens for each team\n        val teamTensCount = teams.associate { team -> team.id to team.countTens() }\n        println(\"Tens collected: $teamTensCount\") // Logging\n\n        // 3. Determine Team with Most Tens\n        val maxTens = teamTensCount.values.maxOrNull() ?: 0\n        val teamsWithMaxTensIds = teamTensCount.filterValues { it == maxTens }.keys\n\n        // 4. Handle Winner Determination\n        if (teamsWithMaxTensIds.size == 1) {\n            // One team has clear majority of tens\n            val winningTeamId = teamsWithMaxTensIds.first()\n            val winningTeam = teams.first { it.id == winningTeamId }\n            println(\n                    \"Team ${winningTeam.id} wins round with majority of tens ($maxTens).\"\n            ) // Logging\n            return RoundResult(winningTeam, false) // Not Kot\n        } else if (teamsWithMaxTensIds.size > 1) {\n            // Tie in tens - apply trick tie-breaker\n            println(\"Tie in tens ($maxTens each). Applying trick tie-breaker.\") // Logging\n            val teamTricksWon = state.tricksWon // Get tricks won map from GameState\n            val tiedTeamsTrickCounts = teamTricksWon.filterKeys { it in teamsWithMaxTensIds }\n            println(\"Tricks won by tied teams: $tiedTeamsTrickCounts\") // Logging\n\n            val maxTricks =\n                    tiedTeamsTrickCounts.values.maxOrNull()\n                            ?: -1 // Use -1 to detect no tricks won case\n            val teamsWithMaxTricks = tiedTeamsTrickCounts.filterValues { it == maxTricks }.keys\n\n            if (teamsWithMaxTricks.size == 1) {\n                // One team won more tricks among the tied teams\n                val winningTeamId = teamsWithMaxTricks.first()\n                val winningTeam = teams.first { it.id == winningTeamId }\n                println(\n                        \"Team ${winningTeam.id} wins round due to trick tie-breaker ($maxTricks tricks).\"\n                ) // Logging\n                return RoundResult(winningTeam, false) // Not Kot\n            } else {\n                // Still tied (same number of tens AND same number of tricks) -> Draw\n                println(\"Round is a DRAW (tied tens and tricks).\") // Logging\n                return RoundResult(null, false) // Indicate draw\n            }\n        } else {\n            // Should not happen if there are teams, means no tens collected by anyone? Treat as\n            // draw.\n            println(\n                    \"Round evaluation resulted in no winner (possibly no tens collected). Treating as Draw.\"\n            ) // Logging\n            return RoundResult(null, false)\n        }\n    }\n}\n",
                "TrickHandler.kt": "package com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\n\nobject TrickHandler {\n    /**\n     * Determines the winner of a completed trick based on Mindikot rules.\n     *\n     * @param playedCards A list of (Player, Card) pairs representing the cards played in the trick,\n     * in order.\n     * @param trumpSuit The active trump suit for the round (can be null if trump is not set).\n     * @return The Player who won the trick.\n     */\n    fun determineTrickWinner(playedCards: List<Pair<Player, Card>>, trumpSuit: Suit?): Player {\n        require(playedCards.isNotEmpty()) { \"Cannot determine winner of an empty trick.\" }\n\n        val leadSuit = playedCards.first().second.suit\n        // var winningPlay: Pair<Player, Card> = playedCards.first() // Assume leader wins initially\n        var winningPlay: Pair<Player, Card>\n\n        // Check for highest trump card first\n        val trumpPlays = playedCards.filter { it.second.suit == trumpSuit && trumpSuit != null }\n        if (trumpPlays.isNotEmpty()) {\n            winningPlay = trumpPlays.maxByOrNull { it.second.rank.value }!!\n        } else {\n            // No trump played, check for highest card of the lead suit\n            val leadSuitPlays = playedCards.filter { it.second.suit == leadSuit }\n            // We know leadSuitPlays is not empty because the leader played one.\n            winningPlay = leadSuitPlays.maxByOrNull { it.second.rank.value }!!\n        }\n\n        return winningPlay.first // Return the winning player\n    }\n}\n",
                "TrumpHandler.kt": "package com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.state.GameState\n\n/**\n * Contains simple helper functions to update the game state related to trump setting. These\n * functions are intended to be called by the GameEngine AFTER a player has made their trump-related\n * decision via external input (UI/ViewModel).\n */\nobject TrumpHandler {\n\n    /**\n     * Updates the game state when a player chooses a trump suit in CHOOSE_WHEN_EMPTY mode by\n     * playing a card that establishes the trump. Precondition: state.trumpRevealed should be false.\n     *\n     * @param state The current GameState to modify.\n     * @param cardPlayed The card whose suit sets the trump.\n     */\n    fun setTrumpFromPlayedCard(state: GameState, cardPlayed: com.example.mindikot.core.model.Card) {\n        if (!state.trumpRevealed) {\n            state.trumpSuit = cardPlayed.suit\n            state.trumpRevealed = true\n            println(\n                    \"TrumpHandler: Trump set to ${state.trumpSuit} by card ${cardPlayed}\"\n            ) // Logging\n        }\n    }\n\n    /**\n     * Updates the game state when a player chooses to reveal the hidden card in FIRST_CARD_HIDDEN\n     * mode. Precondition: state.trumpRevealed should be false and state.hiddenCard should not be\n     * null.\n     *\n     * @param state The current GameState to modify.\n     */\n    fun revealHiddenTrump(state: GameState) {\n        if (!state.trumpRevealed &&\n                        state.hiddenCard != null &&\n                        state.gameMode == com.example.mindikot.core.model.GameMode.FIRST_CARD_HIDDEN\n        ) {\n            state.trumpSuit = state.hiddenCard!!.suit // Set trump to hidden card's suit\n            state.trumpRevealed = true\n            println(\n                    \"TrumpHandler: Trump revealed as ${state.trumpSuit} from hidden card\"\n            ) // Logging\n            // Note: GameEngine must enforce the special play rule for this turn.\n        }\n    }\n\n    /**\n     * Placeholder function to acknowledge the \"Pass\" action in FIRST_CARD_HIDDEN mode. No state\n     * change is needed regarding trump itself.\n     *\n     * @param state The current GameState (not modified here).\n     */\n    fun handleTrumpPass(state: GameState) {\n        // No change to state.trumpSuit or state.trumpRevealed.\n        println(\"TrumpHandler: Player chose to Pass.\") // Logging\n        // GameEngine allows the player to play any card for this trick.\n    }\n}\n"
            },
            "main.py": "from pathlib import Path\n\n# base_dir = Path(\"/mnt/data/mindikot/src/main/java/com/example/mindikot/core\")\nbase_dir = Path(\"src/main/java/com/example/mindikot/core\")\n\n# All file paths relative to base_dir with updated content\nupdated_files_content = {\n    \"model/Card.kt\": \"\"\"\npackage com.example.mindikot.core.model\n\ndata class Card(val suit: Suit, val rank: Rank) {\n    override fun toString(): String = \"${'$'}rank of ${'$'}suit\"\n}\n\"\"\",\n    \"model/Suit.kt\": \"\"\"\npackage com.example.mindikot.core.model\n\nenum class Suit {\n    HEARTS, DIAMONDS, CLUBS, SPADES\n}\n\"\"\",\n    \"model/Rank.kt\": \"\"\"\npackage com.example.mindikot.core.model\n\nenum class Rank(val value: Int) {\n    THREE(3), FOUR(4), FIVE(5), SIX(6), SEVEN(7), EIGHT(8), NINE(9),\n    TEN(10), JACK(11), QUEEN(12), KING(13), ACE(14)\n}\n\"\"\",\n    \"model/Player.kt\": \"\"\"\npackage com.example.mindikot.core.model\n\ndata class Player(val id: Int, val name: String, val teamId: Int, val hand: MutableList<Card> = mutableListOf()) {\n    override fun toString() = \"Player(id=${'$'}id, name=${'$'}name, team=${'$'}teamId)\"\n}\n\"\"\",\n    \"model/Team.kt\": \"\"\"\npackage com.example.mindikot.core.model\n\ndata class Team(val id: Int, val players: List<Player>, val collectedCards: MutableList<Card> = mutableListOf()) {\n    fun countTens(): Int = collectedCards.count { it.rank == Rank.TEN }\n    fun hasKot(): Boolean = countTens() == 4\n}\n\"\"\",\n    \"model/GameMode.kt\": \"\"\"\npackage com.example.mindikot.core.model\n\nenum class GameMode {\n    CHOOSE_WHEN_EMPTY,\n    FIRST_CARD_HIDDEN\n}\n\"\"\",\n    \"engine/DeckGenerator.kt\": \"\"\"\npackage com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\n\nobject DeckGenerator {\n    fun generateDeck(includeTwos: Boolean): MutableList<Card> {\n        val deck = mutableListOf<Card>()\n        for (suit in Suit.values()) {\n            for (rank in Rank.values()) {\n                if (!includeTwos && rank == Rank.THREE) continue\n                deck.add(Card(suit, rank))\n            }\n        }\n        return deck.shuffled().toMutableList()\n    }\n}\n\"\"\",\n    \"engine/TrickHandler.kt\": \"\"\"\npackage com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\n\nobject TrickHandler {\n    fun determineTrickWinner(playedCards: List<Pair<Player, Card>>, trumpSuit: Suit?): Player {\n        val leadSuit = playedCards.first().second.suit\n        val validCards = playedCards.map { (player, card) ->\n            val score = when {\n                card.suit == trumpSuit -> card.rank.value + 100\n                card.suit == leadSuit -> card.rank.value\n                else -> 0\n            }\n            Triple(player, card, score)\n        }\n        return validCards.maxBy { it.third }.first\n    }\n}\n\"\"\",\n    \"engine/TrumpHandler.kt\": \"\"\"\npackage com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\n\nobject TrumpHandler {\n    fun chooseTrumpFromHand(player: Player): Suit {\n        return player.hand.groupingBy { it.suit }.eachCount().maxBy { it.value }.key\n    }\n}\n\"\"\",\n    \"engine/RoundEvaluator.kt\": \"\"\"\npackage com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\n\nobject RoundEvaluator {\n    data class RoundResult(val winningTeam: Team, val isKot: Boolean)\n\n    fun evaluateRound(teams: List<Team>): RoundResult {\n        val teamWithKot = teams.find { it.hasKot() }\n        return if (teamWithKot != null) {\n            RoundResult(teamWithKot, true)\n        } else {\n            val team = teams.maxBy { it.countTens() }\n            RoundResult(team, false)\n        }\n    }\n}\n\"\"\",\n    \"engine/GameEngine.kt\": \"\"\"\npackage com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\nimport com.example.mindikot.core.state.GameState\n\nobject GameEngine {\n    fun playTrick(state: GameState, leaderIndex: Int): Int {\n        val trickCards = mutableListOf<Pair<Player, Card>>()\n        val players = state.players\n        val trumpSuit = state.trumpSuit\n\n        for (i in 0 until players.size) {\n            val currentPlayer = players[(leaderIndex + i) % players.size]\n            val playableCard = currentPlayer.hand.removeAt(0)\n            trickCards.add(currentPlayer to playableCard)\n        }\n\n        val winner = TrickHandler.determineTrickWinner(trickCards, trumpSuit)\n        val team = state.teams.first { it.id == winner.teamId }\n        team.collectedCards.addAll(trickCards.map { it.second })\n\n        return players.indexOf(winner)\n    }\n}\n\"\"\",\n    \"state/GameState.kt\": \"\"\"\npackage com.example.mindikot.core.state\n\nimport com.example.mindikot.core.model.*\n\ndata class GameState(\n    val players: List<Player>,\n    val teams: List<Team>,\n    val gameMode: GameMode,\n    var trumpSuit: Suit? = null,\n    var hiddenTrumpCard: Card? = null\n)\n\"\"\"\n}\n\n# Write each updated file\nfor relative_path, content in updated_files_content.items():\n    path = base_dir / relative_path\n    path.parent.mkdir(parents=True, exist_ok=True)\n    path.write_text(content.strip())\n\n\"\u00e2\u0153\u2026 All specified files were created/updated with actual logic.\"\n",
            "model": {
                "Card.kt": "package com.example.mindikot.core.model\n\ndata class Card(val suit: Suit, val rank: Rank) {\n    override fun toString(): String = \"${rank.displayName} of ${suit}\"\n}\n",
                "GameMode.kt": "package com.example.mindikot.core.model\n\nenum class GameMode {\n    CHOOSE_WHEN_EMPTY,\n    FIRST_CARD_HIDDEN\n}\n",
                "Player.kt": "package com.example.mindikot.core.model\n\ndata class Player(\n    val id: Int,\n    val name: String,\n    val teamId: Int,\n    var hand: MutableList<Card> = mutableListOf()\n) {\n    override fun toString() = \"Player(id=$id, name=$name, team=$teamId)\"\n}\n",
                "Rank.kt": "package com.example.mindikot.core.model\n\nenum class Rank(val value: Int, val displayName: String) {\n    TWO(2, \"2\"),\n    THREE(3, \"3\"),\n    FOUR(4, \"4\"),\n    FIVE(5, \"5\"),\n    SIX(6, \"6\"),\n    SEVEN(7, \"7\"),\n    EIGHT(8, \"8\"),\n    NINE(9, \"9\"),\n    TEN(10, \"10\"),\n    JACK(11, \"J\"),\n    QUEEN(12, \"Q\"),\n    KING(13, \"K\"),\n    ACE(14, \"A\")\n}\n",
                "Suit.kt": "package com.example.mindikot.core.model\n\nenum class Suit {\n    HEARTS, DIAMONDS, CLUBS, SPADES\n}\n",
                "Team.kt": "package com.example.mindikot.core.model\n\ndata class Team(\n    val id: Int,\n    val players: List<Player>,\n    val collectedCards: MutableList<Card> = mutableListOf()\n) {\n    fun countTens(): Int = collectedCards.count { it.rank == Rank.TEN }\n    fun hasKot(): Boolean = countTens() == 4\n}\n"
            },
            "state": {
                "GameState.kt": "package com.example.mindikot.core.state\n\nimport com.example.mindikot.core.model.*\n\n/**\n * Represents the complete state of the Mindikot game at any point in time. This object should be\n * immutable or handled carefully to ensure state consistency, especially when shared across network\n * or threads. Consider using immutable data structures if concurrency becomes complex.\n *\n * @property players List of all players participating in the game.\n * @property teams List of the teams, typically containing references to their players and collected\n * cards.\n * @property gameMode The selected mode for trump determination (e.g., CHOOSE_WHEN_EMPTY,\n * FIRST_CARD_HIDDEN).\n * @property currentLeaderIndex The index (in the `players` list) of the player who leads the\n * current or next trick.\n * @property trumpSuit The suit designated as trump for the current round. Null if trump has not\n * been set yet.\n * @property trumpRevealed Boolean flag indicating whether the trump suit has been determined and\n * revealed for the current round.\n * @property hiddenCard In FIRST_CARD_HIDDEN mode, this holds the card set aside *before dealing*.\n * Null otherwise.\n * @property currentTrickPlays The cards played so far in the trick-in-progress. List<Pair<Player,\n * Card>>.\n * @property awaitingInputFromPlayerIndex Index of the player from whom input is currently awaited.\n * Null if the engine is processing or trick/round ended.\n * @property requiredInputType The type of input needed from the awaiting player.\n * @property tricksWon A map storing the number of tricks won by each team (TeamId -> Trick Count)\n * in the current round. Used for tie-breaking.\n */\ndata class GameState(\n        val players: List<Player>,\n        val teams: List<Team>,\n        val gameMode: GameMode,\n        var currentLeaderIndex: Int = 0,\n        var trumpSuit: Suit? = null,\n        var trumpRevealed: Boolean = false,\n        var hiddenCard: Card? = null, // Card set aside BEFORE dealing in FIRST_CARD_HIDDEN mode\n        val currentTrickPlays: MutableList<Pair<Player, Card>> =\n                mutableListOf(), // State of the current trick\n        var awaitingInputFromPlayerIndex: Int? = null, // Which player needs to act\n        var requiredInputType: InputType? = null, // What kind of action is needed\n        val tricksWon: MutableMap<Int, Int> =\n                mutableMapOf() // TeamId -> Trick Count for current round\n)\n\n/** Enum to represent the type of input currently required from a player. */\nenum class InputType {\n    PLAY_CARD, // Player needs to select a card to play\n    CHOOSE_TRUMP_SUIT, // Player needs to choose a trump suit by playing a card (Mode A)\n    REVEAL_OR_PASS // Player needs to decide Reveal or Pass (Mode B)\n}\n"
            }
        },
        "GameViewModel.kt": "package com.example.mindikot.ui // Adjust package if needed\n\n// Add Gson dependency to build.gradle (app level): implementation 'com.google.code.gson:gson:2.10.1' or later\n// OR replace Gson with kotlinx.serialization (recommended)\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.mindikot.core.engine.DeckGenerator\nimport com.example.mindikot.core.engine.GameEngine\nimport com.example.mindikot.core.engine.RoundEvaluator\nimport com.example.mindikot.core.model.*\nimport com.example.mindikot.core.state.GameState\nimport com.example.mindikot.core.state.InputType\nimport com.google.gson.Gson\nimport com.google.gson.JsonSyntaxException\nimport java.io.BufferedReader\nimport java.io.InputStreamReader\nimport java.io.PrintWriter // Needed for sending messages\nimport java.net.ServerSocket\nimport java.net.Socket // Needed for client connections\nimport java.util.concurrent.ConcurrentHashMap\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nclass GameViewModel : ViewModel() {\n\n    // --- Game State ---\n    // Start with an empty state, will be initialized by host/client setup\n    private val _state = MutableStateFlow(createInitialEmptyGameState())\n    val state: StateFlow<GameState> = _state.asStateFlow()\n\n    // --- Navigation/Events ---\n    // Emits the result of the round for navigation/display\n    private val _navigateToResultScreen = MutableSharedFlow<RoundEvaluator.RoundResult>()\n    val navigateToResultScreen: SharedFlow<RoundEvaluator.RoundResult> =\n        _navigateToResultScreen.asSharedFlow()\n\n    // Emits error messages for the UI\n    private val _showError = MutableSharedFlow<String>()\n    val showError: SharedFlow<String> = _showError.asSharedFlow()\n\n    // --- Game/Network Setup ---\n    var isHost: Boolean = false\n        private set\n    var requiredPlayerCount: Int = 4 // Default\n        private set\n    var localPlayerId: Int = -1 // ID of the player on this device (-1 means not assigned)\n        private set\n\n    // Tracks connected players for lobby UI\n    private val _connectedPlayersCount = MutableStateFlow(0)\n    val connectedPlayersCount: StateFlow<Int> = _connectedPlayersCount\n\n    // Tracks if the actual gameplay has started (cards dealt)\n    private val _gameStarted = MutableStateFlow(false)\n    val gameStarted: StateFlow<Boolean> = _gameStarted\n\n    // --- Networking (Host) ---\n    private var serverSocket: ServerSocket? = null\n    private var isServerRunning = false\n    private val clientSockets = ConcurrentHashMap<Int, Socket>() // Map Player ID -> Socket\n    private val clientWriters = ConcurrentHashMap<Int, PrintWriter>() // Map Player ID -> Writer\n    private val clientReaders = ConcurrentHashMap<Int, BufferedReader>() // Map Player ID -> Reader\n    private val clientJobs = ConcurrentHashMap<Int, Job>() // Map Player ID -> Listener Job\n\n    // --- Networking (Client) ---\n    private var clientSocket: Socket? = null\n    private var clientWriter: PrintWriter? = null\n    private var clientReader: BufferedReader? = null\n    private var clientReaderJob: Job? = null\n    private var isConnectedToServer = false\n\n    // --- Serialization ---\n    // Using Gson for simplicity, consider kotlinx.serialization for production\n    private val gson = Gson()\n\n    // --- Logging ---\n    private fun log(message: String, tag: String = \"GameViewModel\") {\n        println(\"[$tag] $message\") // Simple console logging\n    }\n    private fun logError(message: String, error: Throwable? = null) {\n        val errorMsg = error?.message?.let { \": $it\" } ?: \"\"\n        println(\"[GameViewModel ERROR] $message$errorMsg\")\n    }\n\n    // ========================================================================\n    // HOST FUNCTIONS\n    // ========================================================================\n\n    /** HOST: Initializes the game settings and player slots before starting the server. */\n    fun initializeGameSettings(\n        playerName: String,\n        mode: GameMode,\n        host: Boolean = true,\n        playersNeeded: Int = 4\n    ) {\n        log(\"Initializing game settings as Host.\")\n        isHost = host\n        requiredPlayerCount = playersNeeded\n        localPlayerId = 0 // Host is always Player 0\n\n        // Create player placeholders\n        val players =\n            (0 until playersNeeded).map { i ->\n                Player(\n                    id = i,\n                    name =\n                        if (i == 0) playerName\n                        else \"Waiting...\", // Host name, others waiting\n                    teamId = (i % 2) + 1, // Alternate teams 1 and 2\n                    hand = mutableListOf() // Hands dealt only when game starts\n                )\n            }\n\n        val teams =\n            listOf(\n                Team(id = 1, players = players.filter { it.teamId == 1 }),\n                Team(id = 2, players = players.filter { it.teamId == 2 })\n            )\n\n        // Make sure GameState includes all fields, including tricksWon map\n        _state.value =\n            GameState(\n                players = players,\n                teams = teams,\n                gameMode = mode,\n                currentLeaderIndex = 0, // Start with player 0\n                trumpSuit = null,\n                trumpRevealed = false,\n                hiddenCard = null,\n                currentTrickPlays = mutableListOf(),\n                awaitingInputFromPlayerIndex = null,\n                requiredInputType = null,\n                tricksWon = mutableMapOf(1 to 0, 2 to 0) // Initialize trick counts\n            )\n        _connectedPlayersCount.value = 1 // Host counts as connected\n        log(\"Initial GameState created for host setup.\")\n    }\n\n    /** HOST: Starts the server socket and listens for client connections. */\n    fun startServer(port: Int = 8888) {\n        if (isServerRunning || !isHost) return\n        log(\"Starting server on port $port...\")\n        isServerRunning = true\n        viewModelScope.launch(Dispatchers.IO) {\n            try {\n                serverSocket = ServerSocket(port)\n                log(\"Server started. Waiting for ${requiredPlayerCount - 1} players...\")\n\n                while (clientSockets.size < requiredPlayerCount - 1 && isServerRunning) {\n                    val socket = serverSocket?.accept() ?: break // Wait for a client\n                    val currentClientCount = clientSockets.size\n                    val assignedPlayerId = currentClientCount + 1 // Player IDs 1, 2, 3...\n\n                    log(\"Client connected, assigning Player ID $assignedPlayerId\")\n\n                    try {\n                        val writer = PrintWriter(socket.getOutputStream(), true)\n                        val reader = BufferedReader(InputStreamReader(socket.getInputStream()))\n\n                        // Store connection details BEFORE starting listener\n                        clientSockets[assignedPlayerId] = socket\n                        clientWriters[assignedPlayerId] = writer\n                        clientReaders[assignedPlayerId] = reader\n\n                        // 1. Send the assigned player ID FIRST\n                        sendMessageToClient(\n                            assignedPlayerId,\n                            NetworkMessage(MessageType.ASSIGN_ID, assignedPlayerId)\n                        )\n\n                        // 2. Start listening for messages from this specific client\n                        listenToClient(assignedPlayerId, reader)\n\n                        // 3. Send the current GameState (lobby state) - Important for client to see lobby\n                        sendMessageToClient(\n                            assignedPlayerId,\n                            NetworkMessage(MessageType.GAME_STATE_UPDATE, _state.value)\n                        )\n\n                        // Update connected player count (on Main thread)\n                        withContext(Dispatchers.Main) {\n                            _connectedPlayersCount.value = clientSockets.size + 1 // +1 for host\n                        }\n                        log(\n                            \"Player ID $assignedPlayerId assigned and listener started. Connected: ${_connectedPlayersCount.value}/${requiredPlayerCount}\"\n                        )\n\n                        // Check if lobby is full after this connection\n                        if (_connectedPlayersCount.value == requiredPlayerCount) {\n                            log(\"All players connected!\")\n                            // Automatically start game preparation\n                            prepareAndBroadcastInitialState()\n                            break // Stop accepting connections once full\n                        }\n\n                    } catch (e: Exception) {\n                        logError(\"Error setting up connection for Player $assignedPlayerId\", e)\n                        // Clean up potentially partial connection\n                        runCatching { socket.close() }\n                        // No need to removeClient here, as they weren't fully added/tracked yet\n                    }\n                }\n\n                log(\"Stopped accepting connections (lobby full or server stopped).\")\n\n            } catch (e: Exception) {\n                if (isServerRunning) {\n                    logError(\"Server error\", e)\n                    withContext(Dispatchers.Main) { _showError.emit(\"Server Error: ${e.message}\") }\n                    stopServer() // Clean up on error\n                }\n            } finally {\n                log(\"Server listener loop finished.\")\n                isServerRunning = false // Ensure flag is reset if loop exits\n            }\n        }\n    }\n\n    /** HOST: Starts a listener coroutine for a specific client. */\n    private fun listenToClient(playerId: Int, reader: BufferedReader) {\n        clientJobs[playerId] =\n            viewModelScope.launch(Dispatchers.IO) {\n                log(\"Listener started for Player $playerId.\")\n                try {\n                    while (isActive) { // Loop while coroutine is active\n                        val messageJson =\n                            reader.readLine() ?: break // null means connection closed\n                        log(\"Received from Player $playerId: $messageJson\")\n                        try {\n                            val message = gson.fromJson(messageJson, NetworkMessage::class.java)\n                            // Process message on Main thread for state safety\n                            withContext(\n                                Dispatchers.Main.immediate\n                            ) { // Use immediate for faster processing if safe\n                                handleClientMessage(playerId, message)\n                            }\n                        } catch (e: JsonSyntaxException) {\n                            logError(\"JSON Parse Error from Player $playerId: ${e.message}\")\n                        } catch (e: Exception) {\n                            logError(\"Error handling message from Player $playerId: ${e.message}\")\n                        }\n                    }\n                } catch (e: Exception) {\n                    if (isActive) { // Avoid logging errors during cancellation\n                        logError(\"Error reading from Player $playerId socket\", e)\n                    }\n                } finally {\n                    log(\"Listener stopped for Player $playerId.\")\n                    // Ensure cleanup happens on the Main thread safely\n                    withContext(Dispatchers.Main) {\n                        removeClient(playerId)\n                    }\n                }\n            }\n        // Optional: Add completion handler for debugging\n        clientJobs[playerId]?.invokeOnCompletion { throwable ->\n            if (throwable != null && throwable !is CancellationException) {\n                logError(\"Listener job for Player $playerId completed with error\", throwable)\n            } else {\n                log(\"Listener job for Player $playerId completed normally or cancelled.\")\n            }\n            // Redundant cleanup call here if finally block is guaranteed, but can be defensive\n            viewModelScope.launch(Dispatchers.Main) { removeClient(playerId) }\n        }\n    }\n\n    /** HOST: Handles messages received from a specific client. */\n    private fun handleClientMessage(playerId: Int, message: NetworkMessage) {\n        log(\"Handling message: ${message.type} from Player $playerId\")\n        when (message.type) {\n            MessageType.PLAYER_ACTION -> {\n                if (_state.value.awaitingInputFromPlayerIndex == playerId) {\n                    val expectedType = _state.value.requiredInputType\n                    try {\n                        val actionData: Any? = // Deserialize based on expected type\n                            when (expectedType) {\n                                InputType.PLAY_CARD -> gson.fromJson(gson.toJson(message.data), Card::class.java)\n                                InputType.REVEAL_OR_PASS -> gson.fromJson(gson.toJson(message.data), GameEngine.Decision::class.java)\n                                InputType.CHOOSE_TRUMP_SUIT -> gson.fromJson(gson.toJson(message.data), Card::class.java)\n                                null -> null // Error case handled below\n                            }\n\n                        if (actionData != null) {\n                            processGameInput(playerId, actionData) // Pass Player ID for context\n                        } else {\n                            logError(\"Failed to parse PLAYER_ACTION data for expected type $expectedType from Player $playerId\")\n                            sendMessageToClient(playerId, NetworkMessage(MessageType.ERROR, \"Invalid action data format.\"))\n                        }\n                    } catch (e: Exception) {\n                        logError(\"Error deserializing PLAYER_ACTION data from Player $playerId\", e)\n                        sendMessageToClient(playerId, NetworkMessage(MessageType.ERROR, \"Error processing your action.\"))\n                    }\n                } else {\n                    log(\"Received action from Player $playerId but it's not their turn (expected ${_state.value.awaitingInputFromPlayerIndex}).\")\n                    sendMessageToClient(playerId, NetworkMessage(MessageType.ERROR, \"Not your turn\"))\n                }\n            }\n            MessageType.PLAYER_NAME -> {\n                val name = message.data as? String ?: \"Player $playerId\"\n                updatePlayerName(playerId, name) // Update name and broadcast state\n            }\n            else -> log(\"Received unhandled message type: ${message.type} from Player $playerId\")\n        }\n    }\n\n    /** HOST: Deals cards, sets hidden card (Mode B), updates state, and broadcasts. */\n    private fun prepareAndBroadcastInitialState() {\n        // Ensure this runs on Main thread for state safety\n        viewModelScope.launch(Dispatchers.Main.immediate) {\n            log(\"Preparing initial game state for ${requiredPlayerCount} players...\")\n            val currentPlayers = _state.value.players\n            if (currentPlayers.size != requiredPlayerCount) {\n                logError(\"Cannot prepare initial state: Incorrect number of players (${currentPlayers.size}/${requiredPlayerCount})\")\n                _showError.emit(\"Cannot start game - waiting for players.\")\n                return@launch\n            }\n\n            val deck = DeckGenerator.generateDeck(requiredPlayerCount)\n            var hiddenCard: Card? = null\n\n            // Handle hidden card for Mode B *before* dealing\n            if (_state.value.gameMode == GameMode.FIRST_CARD_HIDDEN) {\n                if (deck.isNotEmpty()) {\n                    hiddenCard = deck.removeAt(0) // Take from top\n                    log(\"Hidden card set (Mode B): ${hiddenCard.suit}\")\n                } else {\n                    logError(\"Deck empty before hidden card selection!\")\n                    _showError.emit(\"Error starting game: Deck empty.\")\n                    // Maybe stop server or reset lobby state\n                    return@launch\n                }\n            }\n\n            // Deal cards\n            val updatedPlayers = currentPlayers.toMutableList()\n            val cardsPerPlayer = deck.size / requiredPlayerCount\n            if (deck.size % requiredPlayerCount != 0) {\n                logError(\"Deck size ${deck.size} not evenly divisible by $requiredPlayerCount players after potential hidden card!\")\n                // Proceeding, but some players might get fewer cards if deck is wrong size\n            }\n\n            for (i in 0 until requiredPlayerCount) {\n                val handCards = deck.take(cardsPerPlayer).toMutableList()\n                if (i < updatedPlayers.size) {\n                    updatedPlayers[i] = updatedPlayers[i].copy(hand = handCards)\n                    // More efficient removal needed if deck is large, but for ~52 cards this is ok\n                    deck.removeAll(handCards.toSet())\n                } else {\n                    logError(\"Player index $i out of bounds during dealing (size ${updatedPlayers.size})\")\n                }\n            }\n            log(\"Cards dealt. Remaining deck size: ${deck.size}\") // Should be 0\n\n            // Update GameState - Ensure ALL fields are correctly set/reset for a new round\n            var initialState = _state.value.copy(\n                players = updatedPlayers,\n                hiddenCard = hiddenCard,\n                tricksWon = mutableMapOf(1 to 0, 2 to 0), // Reset trick counts\n                currentTrickPlays = mutableListOf(),      // Ensure trick plays are clear\n                trumpSuit = null,                         // Ensure trump is reset\n                trumpRevealed = false,                    // Ensure trump revealed is reset\n                currentLeaderIndex = 0                    // Reset leader to player 0\n            )\n\n            // Set initial input request for the first leader\n            initialState = GameEngine.requestInput(initialState, initialState.currentLeaderIndex)\n\n            _state.value = initialState // Update the StateFlow\n\n            // Broadcast the initial state to all clients\n            broadcastGameState(_state.value)\n            log(\"Initial GameState broadcast.\")\n\n            // Mark game as started AFTER broadcasting state\n            _gameStarted.value = true\n        }\n    }\n\n    /** HOST: Broadcasts the GameState to all connected clients. */\n    private fun broadcastGameState(gameState: GameState) {\n        if (!isHost) return\n        val message = NetworkMessage(MessageType.GAME_STATE_UPDATE, gameState)\n        log(\"Broadcasting GameState to ${clientWriters.size} clients...\")\n        clientWriters.forEach { (id, _) -> // Iterate keys safely\n            sendMessageToClient(id, message)\n        }\n        log(\"Broadcast attempt complete.\")\n    }\n\n    /** HOST: Sends a specific message to a single client. Handles potential errors. */\n    private fun sendMessageToClient(playerId: Int, message: NetworkMessage) {\n        if (!isHost) return\n        val writer = clientWriters[playerId]\n        if (writer == null) {\n            log(\"Cannot send message, writer not found for Player $playerId (already removed?).\")\n            return\n        }\n        viewModelScope.launch(Dispatchers.IO) { // Send on IO thread\n            try {\n                val messageJson = gson.toJson(message) // Ensure thread safety if gson instance is shared without care\n                synchronized(writer) { // Synchronize access to the writer\n                    writer.println(messageJson)\n                }\n                if (writer.checkError()) { // Check for errors after writing\n                    throw Exception(\"PrintWriter error occurred.\")\n                }\n                log(\"Sent to Player $playerId: ${message.type}\")\n            } catch (e: Exception) {\n                logError(\"Error sending message to Player $playerId\", e)\n                // Error likely means client disconnected, trigger removal\n                withContext(Dispatchers.Main) { removeClient(playerId) }\n            }\n        }\n    }\n\n    /** HOST: Cleans up resources associated with a disconnected or removed client. */\n    private fun removeClient(playerId: Int) {\n        // Ensure running on Main thread for state safety\n        viewModelScope.launch(Dispatchers.Main.immediate) { // Use immediate if called from IO completion handler\n            if (!clientSockets.containsKey(playerId)) {\n                log(\"Attempted to remove Player $playerId, but already removed.\")\n                return@launch // Already removed\n            }\n\n            log(\"Removing client Player $playerId...\")\n            clientJobs[playerId]?.cancel() // Cancel listener job FIRST\n            clientJobs.remove(playerId)\n\n            // Close streams and socket safely\n            runCatching { clientWriters[playerId]?.close() }.onFailure { logError(\"Error closing writer for $playerId\", it) }\n            runCatching { clientReaders[playerId]?.close() }.onFailure { logError(\"Error closing reader for $playerId\", it) }\n            runCatching { clientSockets[playerId]?.close() }.onFailure { logError(\"Error closing socket for $playerId\", it) }\n\n            // Remove from maps\n            clientWriters.remove(playerId)\n            clientReaders.remove(playerId)\n            clientSockets.remove(playerId)\n\n            // Update connected count\n            _connectedPlayersCount.value = clientSockets.size + 1\n\n            log(\"Player $playerId removed. Connected: ${_connectedPlayersCount.value}/${requiredPlayerCount}\")\n\n            // Handle game interruption\n            if (_gameStarted.value) {\n                _showError.emit(\"Player ${state.value.players.find { it.id == playerId }?.name ?: playerId} disconnected. Game interrupted.\")\n                // Option: Stop the game immediately\n                stopServer() // Or implement more graceful handling later\n            } else {\n                // If still in lobby, update player list to show disconnected state\n                _state.update { state ->\n                    val updatedPlayers = state.players.map {\n                        if (it.id == playerId) it.copy(name = \"[Disconnected]\", hand = mutableListOf()) // Mark as disconnected, clear hand\n                        else it\n                    }\n                    state.copy(players = updatedPlayers)\n                }\n                broadcastGameState(_state.value) // Inform others player left lobby\n            }\n        }\n    }\n\n    /** HOST: Stops the server and cleans up all connections. */\n    fun stopServer() {\n        if (!isHost || !isServerRunning) return // Prevent multiple calls or client calls\n        log(\"Stopping server...\")\n        isServerRunning = false // Signal loops to stop\n\n        // Close server socket first to prevent new connections\n        runCatching { serverSocket?.close() }.onFailure { logError(\"Error closing server socket\", it)}\n        serverSocket = null\n\n        // Cancel all client listening jobs\n        clientJobs.values.forEach { it.cancel() }\n        clientJobs.clear()\n\n        // Close all client connections\n        // Create a temporary list of keys to avoid ConcurrentModificationException\n        val clientIds = clientSockets.keys.toList()\n        clientIds.forEach { id ->\n            // Use the removeClient function for proper cleanup of each client\n            removeClient(id) // This will handle closing sockets/streams and removing from maps\n        }\n        // Double check maps are clear (should be by removeClient)\n        clientSockets.clear()\n        clientWriters.clear()\n        clientReaders.clear()\n\n        // Reset state after cleanup\n        _connectedPlayersCount.value = 0\n        _gameStarted.value = false\n        _state.value = createInitialEmptyGameState()\n        log(\"Server stopped and connections closed.\")\n    }\n\n\n    // ========================================================================\n    // CLIENT FUNCTIONS\n    // ========================================================================\n\n    /** CLIENT: Connects to the host server. */\n    fun connectToServer(hostAddress: String, port: Int = 8888, playerName: String) {\n        if (isConnectedToServer || isHost) return\n        log(\"Client: Attempting to connect to $hostAddress:$port...\")\n        viewModelScope.launch(Dispatchers.IO) {\n            try {\n                // Explicitly close any existing connection attempt first\n                disconnectFromServer()\n                delay(100) // Short delay before reconnecting\n\n                clientSocket = Socket(hostAddress, port)\n                clientWriter = PrintWriter(clientSocket!!.getOutputStream(), true)\n                clientReader = BufferedReader(InputStreamReader(clientSocket!!.getInputStream()))\n                isConnectedToServer = true\n                log(\"Client: Connected successfully.\")\n\n                // Start listening for messages from the server\n                listenToServer()\n\n                // Send player name to host (important for host to identify player)\n                sendMessageToServer(NetworkMessage(MessageType.PLAYER_NAME, playerName))\n\n                // UI should navigate to a \"Waiting in Lobby\" screen here\n\n            } catch (e: Exception) {\n                logError(\"Client: Connection failed\", e)\n                isConnectedToServer = false\n                withContext(Dispatchers.Main) {\n                    _showError.emit(\"Connection failed: ${e.message}\")\n                }\n                disconnectFromServer() // Ensure cleanup after failure\n            }\n        }\n    }\n\n    /** CLIENT: Listens for messages from the server. */\n    private fun listenToServer() {\n        clientReaderJob?.cancel() // Ensure only one listener runs\n        clientReaderJob = viewModelScope.launch(Dispatchers.IO) {\n            log(\"Client: Listener started.\")\n            try {\n                while (isActive) {\n                    val messageJson = clientReader?.readLine() ?: break // null means connection closed gracefully\n                    log(\"Client: Received from server: $messageJson\")\n                    try {\n                        val message = gson.fromJson(messageJson, NetworkMessage::class.java)\n                        // Process message on Main thread for UI/State updates\n                        withContext(Dispatchers.Main.immediate) {\n                            handleServerMessage(message)\n                        }\n                    } catch (e: JsonSyntaxException) {\n                        logError(\"Client: JSON Parse Error from server\", e)\n                    } catch (e: Exception) {\n                        logError(\"Client: Error handling message from server\", e)\n                    }\n                }\n            } catch (e: Exception) {\n                // Log error only if the job is still active (not cancelled intentionally)\n                if (isActive) {\n                    logError(\"Client: Error reading from server socket\", e)\n                    withContext(Dispatchers.Main) {\n                        _showError.emit(\"Lost connection to server.\")\n                    }\n                }\n            } finally {\n                log(\"Client: Listener stopped.\")\n                // Trigger disconnection logic on the main thread\n                withContext(Dispatchers.Main) {\n                    disconnectFromServer() // Ensure full cleanup\n                }\n            }\n        }\n        clientReaderJob?.invokeOnCompletion { throwable ->\n            log(\"Client listener job completed.\")\n            if (throwable != null && throwable !is CancellationException) {\n                logError(\"Client listener job completed with error\", throwable)\n            }\n            // Disconnect when the listener job ends for any reason\n            viewModelScope.launch(Dispatchers.Main) { disconnectFromServer() }\n        }\n    }\n\n    /** CLIENT: Handles messages received from the server. */\n    private fun handleServerMessage(message: NetworkMessage) {\n        log(\"Client: Handling message: ${message.type}\")\n        when (message.type) {\n            MessageType.ASSIGN_ID -> {\n                // Server assigned our player ID\n                val id = (message.data as? Double)?.toInt() ?: -1 // Gson quirk with numbers\n                if (id != -1 && localPlayerId == -1) { // Assign only if not already assigned\n                    localPlayerId = id\n                    log(\"Client: Assigned Player ID: $localPlayerId\")\n                } else if (localPlayerId != -1 && localPlayerId != id) {\n                    logError(\"Client: Received conflicting Player ID from server (Current: $localPlayerId, Received: $id).\")\n                    // Might indicate a server issue or reconnect problem. Consider disconnecting.\n                } else if (id == -1) {\n                    logError(\"Client: Received invalid Player ID (-1) from server.\")\n                }\n            }\n            MessageType.GAME_STATE_UPDATE -> {\n                // Server sent updated GameState\n                try {\n                    // Use TypeToken for complex generic types if needed, but re-serializing often works\n                    val gameStateJson = gson.toJson(message.data) // Convert Any back to JSON\n                    val updatedState = gson.fromJson(gameStateJson, GameState::class.java) // Deserialize specific type\n\n                    // Basic validation of received state\n                    if (updatedState.players.isEmpty()) {\n                        logError(\"Client: Received empty player list in GAME_STATE_UPDATE.\")\n                        return // Ignore potentially invalid state\n                    }\n\n                    _state.value = updatedState // Update local state authoritative from server\n\n                    // Update connected players count based on received state (count non-waiting/disconnected)\n                    _connectedPlayersCount.value = updatedState.players.count {\n                        it.name != \"Waiting...\" && it.name != \"[Disconnected]\"\n                    }\n\n                    log(\"Client: GameState updated. Awaiting input from: ${updatedState.awaitingInputFromPlayerIndex}\")\n\n                    // Determine if game started based on hands being dealt\n                    val myHand = updatedState.players.find { it.id == localPlayerId }?.hand\n                    if (!_gameStarted.value && myHand?.isNotEmpty() == true) {\n                        _gameStarted.value = true\n                        log(\"Client: Game Started (received non-empty hand).\")\n                    } else if (_gameStarted.value && myHand?.isEmpty() == true && updatedState.currentTrickPlays.isEmpty()) {\n                        // If game was started but now hand is empty and no trick ongoing, likely round end\n                        log(\"Client: Received state potentially indicating round end.\")\n                        // The host should ideally send a specific ROUND_END message with results\n                        // Or client UI navigates based on _navigateToResultScreen which host triggers somehow\n                    }\n\n                } catch (e: Exception) {\n                    logError(\"Client: Error deserializing GAME_STATE_UPDATE\", e)\n                }\n            }\n            MessageType.REQUEST_INPUT -> {\n                // Optional: Server explicitly asks for input\n                val requestedPlayerId = (message.data as? Double)?.toInt() ?: -1\n                if (requestedPlayerId == localPlayerId) {\n                    log(\"Client: Server explicitly requested input. UI should check GameState.\")\n                    // UI should already be reactive to GameState.awaitingInputFromPlayerIndex\n                }\n            }\n            MessageType.ERROR -> {\n                val errorMsg = message.data as? String ?: \"Unknown error from server\"\n                logError(\"Client: Received error message from server: $errorMsg\")\n                viewModelScope.launch { _showError.emit(errorMsg) } // Show error to user\n            }\n            // Other message types might be needed (e.g., ROUND_RESULT, GAME_OVER)\n            else -> log(\"Client: Received unhandled message type: ${message.type}\")\n        }\n    }\n\n    /** CLIENT: Sends a message to the host server. */\n    private fun sendMessageToServer(message: NetworkMessage) {\n        if (!isConnectedToServer || isHost || clientWriter == null) {\n            log(\"Client: Cannot send message. Not connected or is host.\")\n            return\n        }\n        viewModelScope.launch(Dispatchers.IO) {\n            try {\n                val messageJson = gson.toJson(message)\n                synchronized(clientWriter!!) { // Synchronize access\n                    clientWriter?.println(messageJson)\n                }\n                if (clientWriter?.checkError() == true) {\n                    throw Exception(\"PrintWriter error occurred.\")\n                }\n                log(\"Client: Sent message: ${message.type}\")\n            } catch (e: Exception) {\n                logError(\"Client: Error sending message\", e)\n                // Attempt to handle gracefully, maybe disconnect\n                withContext(Dispatchers.Main) {\n                    _showError.emit(\"Failed to send action. Check connection.\")\n                    // Consider triggering disconnect if send fails\n                    // disconnectFromServer()\n                }\n            }\n        }\n    }\n\n    /** CLIENT: Disconnects from the server and cleans up resources. */\n    fun disconnectFromServer() {\n        if (isHost) return // Host shouldn't call this\n        if (!isConnectedToServer && clientSocket == null) return // Already disconnected\n\n        log(\"Client: Disconnecting...\")\n        isConnectedToServer = false // Set flag immediately\n        clientReaderJob?.cancel() // Cancel listener job\n        clientReaderJob = null\n\n        // Close streams and socket safely\n        runCatching { clientWriter?.close() }.onFailure{ logError(\"Error closing client writer\", it)}\n        runCatching { clientReader?.close() }.onFailure{ logError(\"Error closing client reader\", it)}\n        runCatching { clientSocket?.close() }.onFailure{ logError(\"Error closing client socket\", it)}\n\n        clientSocket = null\n        clientWriter = null\n        clientReader = null\n\n        // Reset client-specific state\n        _gameStarted.value = false\n        _state.value = createInitialEmptyGameState() // Reset state\n        localPlayerId = -1\n        _connectedPlayersCount.value = 0\n        log(\"Client: Disconnected and cleaned up.\")\n    }\n\n\n    // ========================================================================\n    // GAME LOGIC PROCESSING (HOST ONLY)\n    // ========================================================================\n\n    /**\n     * HOST ONLY: Processes player input using the GameEngine and broadcasts the result.\n     * @param actingPlayerId The ID of the player whose action is being processed.\n     * @param playerInput The action data (Card, Decision, etc.).\n     */\n    private fun processGameInput(actingPlayerId: Int, playerInput: Any) {\n        if (!isHost) {\n            logError(\"Client attempted local game processing!\")\n            return\n        }\n\n        viewModelScope.launch(Dispatchers.Main.immediate) { // Process immediately on Main thread\n            val currentState = _state.value // Get current state\n\n            // --- Basic Validation ---\n            if (currentState.awaitingInputFromPlayerIndex != actingPlayerId) {\n                logError(\"Input processed for wrong player. Expected: ${currentState.awaitingInputFromPlayerIndex}, Got: $actingPlayerId\")\n                sendMessageToClient(actingPlayerId, NetworkMessage(MessageType.ERROR, \"Not your turn\"))\n                return@launch // Ignore input\n            }\n            // Could add validation: is playerInput type compatible with currentState.requiredInputType?\n\n            // --- Process with GameEngine ---\n            log(\"Host: Processing input from Player $actingPlayerId: $playerInput\")\n            try {\n                // GameEngine modifies the state object directly in this implementation\n                GameEngine.processPlayerInput(currentState, playerInput)\n\n                // Update the StateFlow *after* engine modification\n                _state.value = currentState // This triggers UI updates via collectAsState\n\n                // Check for round end condition *after* state update\n                val roundEnded = currentState.players.firstOrNull()?.hand?.isEmpty() == true && currentState.currentTrickPlays.isEmpty()\n\n                if (roundEnded) {\n                    log(\"Host: Round Ended. Evaluating...\")\n                    val result = RoundEvaluator.evaluateRound(currentState) // Evaluate the final state\n                    log(\"Host: Round Result: Winner=${result.winningTeam?.id ?: \"Draw\"}, Kot=${result.isKot}\")\n                    // TODO: Update actual game scores (if tracking across rounds)\n\n                    // Broadcast the FINAL state of the round\n                    broadcastGameState(currentState)\n                    // Delay slightly for clients to process final state, then emit result event\n                    delay(200) // Adjust as needed\n                    _navigateToResultScreen.emit(result) // Signal host UI / potentially broadcast result separately\n\n                    // TODO: Implement logic for next round (reset state, deal again) or end game\n                    // resetForNextRound() ?\n                } else {\n                    // Round continues, broadcast the updated state (showing next player's turn etc.)\n                    broadcastGameState(currentState)\n                }\n\n            } catch (e: IllegalStateException) {\n                logError(\"Host: Invalid move detected by GameEngine for Player $actingPlayerId: ${e.message}\")\n                sendMessageToClient(actingPlayerId, NetworkMessage(MessageType.ERROR, \"Invalid Move: ${e.message}\"))\n                // State was potentially mutated by engine before error, need to revert or re-request carefully\n                // For simplicity, just re-request from the same player based on the *original* state before the failed attempt.\n                // This requires passing a copy to GameEngine or having a revert mechanism.\n                // Safer option: Re-request input based on the *current* (potentially partially modified) state.\n                _state.value = GameEngine.requestInput(_state.value, actingPlayerId) // Re-request input\n                broadcastGameState(_state.value) // Broadcast state showing it's still their turn\n\n            } catch (e: Exception) {\n                logError(\"Host: Unexpected error processing game input for Player $actingPlayerId\", e)\n                _showError.emit(\"Internal Server Error.\") // Generic error for host UI\n                // Consider stopping the game or notifying clients of a server error\n            }\n        }\n    }\n\n    // ========================================================================\n    // UI ACTION HANDLERS (Called by the UI on the specific device)\n    // ========================================================================\n\n    /** Called when the local player chooses a card to play */\n    fun onCardPlayed(card: Card) {\n        log(\"UI Action: Card played: $card by Local Player $localPlayerId\")\n        val currentState = _state.value\n        val myTurn = currentState.awaitingInputFromPlayerIndex == localPlayerId\n        val expectedInput = currentState.requiredInputType\n\n        if (!myTurn) {\n            logError(\"Attempted to play card when not local player's turn.\")\n            viewModelScope.launch { _showError.emit(\"Not your turn!\") }\n            return\n        }\n        // Check if PLAY_CARD or CHOOSE_TRUMP_SUIT (which involves playing a card) is expected\n        if (expectedInput != InputType.PLAY_CARD && expectedInput != InputType.CHOOSE_TRUMP_SUIT) {\n            logError(\"Attempted to play card when expected input was $expectedInput\")\n            viewModelScope.launch { _showError.emit(\"Cannot play a card right now.\") }\n            return\n        }\n        // Basic check: Does the player have the card?\n        if (currentState.players.find { it.id == localPlayerId }?.hand?.contains(card) != true) {\n            logError(\"Attempted to play card not in hand: $card\")\n            viewModelScope.launch { _showError.emit(\"Card not in hand!\") }\n            return\n        }\n        // More complex validation (following suit, post-reveal trump) should ideally happen\n        // *before* sending/processing, possibly using GameEngine.determineValidMoves.\n        // For now, we rely on GameEngine in processGameInput for final validation.\n\n        if (isHost) {\n            processGameInput(localPlayerId, card) // Host processes directly\n        } else {\n            sendMessageToServer(NetworkMessage(MessageType.PLAYER_ACTION, card)) // Client sends to host\n        }\n    }\n\n    /** Called when the local player chooses Reveal or Pass (Mode B) */\n    fun onRevealOrPass(decision: GameEngine.Decision) {\n        log(\"UI Action: Reveal/Pass decision: $decision by Local Player $localPlayerId\")\n        val currentState = _state.value\n        if (currentState.awaitingInputFromPlayerIndex != localPlayerId || currentState.requiredInputType != InputType.REVEAL_OR_PASS) {\n            logError(\"Attempted Reveal/Pass at wrong time/turn. Expected: ${currentState.requiredInputType}\")\n            viewModelScope.launch { _showError.emit(\"Cannot Reveal or Pass now.\") }\n            return\n        }\n\n        if (isHost) {\n            processGameInput(localPlayerId, decision)\n        } else {\n            sendMessageToServer(NetworkMessage(MessageType.PLAYER_ACTION, decision))\n        }\n    }\n\n    // ========================================================================\n    // UTILITY & LIFECYCLE\n    // ========================================================================\n\n    /** Creates an empty initial game state */\n    private fun createInitialEmptyGameState(): GameState {\n        return GameState(\n            players = emptyList(),\n            teams = emptyList(),\n            gameMode = GameMode.CHOOSE_WHEN_EMPTY, // Default mode\n            // Initialize all fields, including the map\n            tricksWon = mutableMapOf()\n        )\n    }\n\n    /** HOST: Updates player name in the authoritative state and broadcasts the change */\n    private fun updatePlayerName(playerId: Int, name: String) {\n        if (!isHost) return // Only host modifies the authoritative state\n        log(\"Host: Updating Player $playerId name to '$name'\")\n        var nameUpdated = false\n        _state.update { currentState ->\n            val updatedPlayers = currentState.players.map {\n                if (it.id == playerId && it.name != name) {\n                    nameUpdated = true\n                    it.copy(name = name)\n                } else it\n            }\n            // Only update state if name actually changed\n            if (nameUpdated) currentState.copy(players = updatedPlayers) else currentState\n        }\n        // Broadcast the updated state only if the name actually changed\n        if (nameUpdated) {\n            broadcastGameState(_state.value)\n        }\n    }\n\n    /** Called when ViewModel is cleared - ensures network cleanup */\n    override fun onCleared() {\n        log(\"GameViewModel Cleared.\")\n        if (isHost) {\n            stopServer() // Host stops server and cleans up clients\n        } else {\n            disconnectFromServer() // Client disconnects\n        }\n        super.onCleared()\n    }\n}\n\n// ========================================================================\n// DATA CLASSES FOR NETWORKING\n// ========================================================================\n\n/** Defines the type of message being sent over the network. */\nenum class MessageType {\n    ASSIGN_ID,          // Server -> Client: Your assigned player ID {data: Int}\n    GAME_STATE_UPDATE,  // Server -> Client: The current full GameState {data: GameState}\n    PLAYER_ACTION,      // Client -> Server: Player performed an action {data: Card or Decision}\n    // REQUEST_INPUT is optional if clients purely rely on GameState.awaitingInputFromPlayerIndex\n    REQUEST_INPUT,      // Server -> Client: It's your turn, input needed {data: PlayerID}\n    PLAYER_NAME,        // Client -> Server: Sending player's chosen name {data: String}\n    ERROR               // Server -> Client: An error occurred {data: String}\n    // Consider adding: ROUND_RESULT, GAME_OVER messages\n}\n\n/** Represents a message sent between the host and clients. */\ndata class NetworkMessage(\n    val type: MessageType,\n    /**\n     * Data payload. Needs careful serialization/deserialization based on 'type'.\n     * Examples: Int, GameState, Card, GameEngine.Decision, String.\n     */\n    val data: Any? = null\n)",
        "MainActivity.kt": "package com.example.mindikot\n\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.Modifier // Ensure this import is added\nimport androidx.navigation.compose.rememberNavController\nimport com.example.mindikot.ui.MainNavHost\nimport com.example.mindikot.ui.theme.MindikotTheme\n\nclass MainActivity : ComponentActivity() {\n\n    private external fun stringFromJNI(): String\n\n    companion object {\n        init {\n            System.loadLibrary(\"mindikot\")\n        }\n    }\n\n    @OptIn(ExperimentalMaterial3Api::class) // Opt-In annotation for Material3 APIs\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        setContent {\n            MindikotTheme {\n                val navController = rememberNavController()\n\n                // State to hold the native string\n                var nativeText by remember { mutableStateOf(\"\") }\n\n                // Use LaunchedEffect to call the native method and set the result\n                LaunchedEffect(Unit) {\n                    nativeText = stringFromJNI() // This will run once during composition\n                }\n\n                Scaffold(\n                    topBar = {\n                        TopAppBar(\n                            title = { Text(\"Mindikot Game\") },\n                            colors = TopAppBarDefaults.mediumTopAppBarColors()\n                        )\n                    }\n                ) { paddingValues ->\n                    // Main content is handled by MainNavHost, passing the navigation controller\n                    MainNavHost(navController = navController, modifier = Modifier.padding(paddingValues))\n                }\n            }\n        }\n    }\n}\n\n@Preview(showBackground = true)\n@Composable\nfun DefaultPreview() {\n    MindikotTheme {\n        val navController = rememberNavController()\n        MainNavHost(navController = navController)\n    }\n}\n",
        "ui": {
            "components": {
                "CardView.kt": "package com.example.mindikot.ui.components\n\nimport androidx.compose.foundation.BorderStroke\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.material3.Card\nimport androidx.compose.material3.CardDefaults\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.alpha\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport com.example.mindikot.core.model.Card\n\n@Composable\nfun PlayerCardView(\n        card: Card,\n        isValidMove: Boolean, // Can this card be played now?\n        isPlayable: Boolean, // Is it generally the player's turn to play any card?\n        onCardSelected: (Card) -> Unit,\n        modifier: Modifier = Modifier\n) {\n    val elevation = if (isValidMove) 8.dp else 2.dp\n    val alpha = if (isPlayable && !isValidMove) 0.6f else 1.0f // Dim invalid cards when it's turn\n    val borderColor = if (isValidMove) MaterialTheme.colorScheme.primary else Color.Gray\n\n    Card(\n            modifier =\n                    modifier.size(width = 70.dp, height = 100.dp) // Example fixed size\n                            .padding(horizontal = 2.dp, vertical = 4.dp)\n                            .alpha(alpha)\n                            .clickable(\n                                    enabled =\n                                            isValidMove &&\n                                                    isPlayable, // Clickable only if it's a valid\n                                    // move AND it's our turn\n                                    onClick = { onCardSelected(card) }\n                            ),\n            elevation = CardDefaults.cardElevation(defaultElevation = elevation),\n            border = BorderStroke(if (isValidMove) 2.dp else 0.5.dp, borderColor),\n            shape = MaterialTheme.shapes.medium // Or RoundedCornerShape(8.dp)\n    ) {\n        // Basic card representation (improve this visually)\n        Box(modifier = Modifier.padding(4.dp), contentAlignment = Alignment.Center) {\n            Text(\n                    text = \"${card.rank.displayName}${getSuitSymbol(card.suit)}\",\n                    fontSize = 18.sp, // Adjust size\n                    fontWeight = FontWeight.Bold,\n                    color = getSuitColor(card.suit)\n            )\n            // You can add separate Texts for top-left/bottom-right if needed\n        }\n    }\n}\n\n// Helper functions for visual representation (customize as needed)\n@Composable\nfun getSuitColor(suit: com.example.mindikot.core.model.Suit): Color {\n    return when (suit) {\n        com.example.mindikot.core.model.Suit.HEARTS,\n        com.example.mindikot.core.model.Suit.DIAMONDS -> Color.Red\n        com.example.mindikot.core.model.Suit.CLUBS, com.example.mindikot.core.model.Suit.SPADES ->\n                Color.Black\n    }\n}\n\nfun getSuitSymbol(suit: com.example.mindikot.core.model.Suit): String {\n    return when (suit) {\n        com.example.mindikot.core.model.Suit.HEARTS -> \"\u00e2\u2122\u00a5\"\n        com.example.mindikot.core.model.Suit.DIAMONDS -> \"\u00e2\u2122\u00a6\"\n        com.example.mindikot.core.model.Suit.CLUBS -> \"\u00e2\u2122\u00a3\"\n        com.example.mindikot.core.model.Suit.SPADES -> \"\u00e2\u2122\u00a0\"\n    }\n}\n",
                "GameStatus.kt": "package com.example.mindikot.ui.components\n\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport com.example.mindikot.core.state.GameState\n\n@Composable\nfun GameStatus(gameState: GameState) {\n    Column {\n        Text(\"Round: ${gameState.gameMode}\", style = MaterialTheme.typography.headlineLarge)\n        Text(\"Current Leader: ${gameState.players[gameState.currentLeaderIndex].name}\", style = MaterialTheme.typography.bodyMedium)\n        Text(\"Trump Suit: ${gameState.trumpSuit?.name ?: \"None\"}\", style = MaterialTheme.typography.bodyMedium)\n    }\n}\n",
                "OtherPlayersDisplay.kt": "package com.example.mindikot.ui.components\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.shape.CircleShape\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Person // Or style_outlined depending on preference\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport com.example.mindikot.core.model.Player\n\n@Composable\nfun OtherPlayerDisplay(player: Player, isCurrentTurn: Boolean, modifier: Modifier = Modifier) {\n    val teamColor =\n            if (player.teamId == 1) Color(0xFFADD8E6)\n            else Color(0xFFFAC898) // Example Light Blue/Peach\n    val turnIndicatorColor =\n            if (isCurrentTurn) MaterialTheme.colorScheme.primary else Color.Transparent\n    val nameColor =\n            if (isCurrentTurn) MaterialTheme.colorScheme.primary\n            else MaterialTheme.colorScheme.onSurface\n\n    Column(\n            modifier =\n                    modifier.padding(8.dp)\n                            .border(\n                                    2.dp,\n                                    turnIndicatorColor,\n                                    CircleShape\n                            ) // Highlight border if turn\n                            .padding(8.dp), // Inner padding\n            horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Icon(\n                imageVector = Icons.Default.Person,\n                contentDescription = player.name,\n                modifier =\n                        Modifier.size(40.dp)\n                                .clip(CircleShape)\n                                .background(teamColor.copy(alpha = 0.5f))\n                                .padding(4.dp)\n        )\n        Spacer(modifier = Modifier.height(4.dp))\n        Text(\n                text = player.name,\n                fontWeight = if (isCurrentTurn) FontWeight.Bold else FontWeight.Normal,\n                fontSize = 14.sp,\n                color = nameColor\n        )\n        Spacer(modifier = Modifier.height(2.dp))\n        Text(\n                text = \"Cards: ${player.hand.size}\", // Display card count\n                fontSize = 12.sp,\n                color = Color.Gray\n        )\n    }\n}\n",
                "PlayerHand.kt": "package com.example.mindikot.ui.components\n\nimport androidx.compose.foundation.lazy.LazyRow\nimport androidx.compose.foundation.lazy.items // <-- Ensure this import is added\nimport androidx.compose.runtime.Composable\nimport com.example.mindikot.core.model.Card\n\n@Composable\nfun PlayerHand(cards: List<Card>, onCardSelected: (Card) -> Unit) {\n    LazyRow {\n        items(cards) { card -> // Use the items function that works with a list of objects\n            CardView(card = card, onCardSelected = onCardSelected)\n        }\n    }\n}\n"
            },
            "navigation": {
                "MainNavHost.kt": "package com.example.mindikot.ui\n\nimport androidx.compose.runtime.Composable\nimport androidx.navigation.NavHostController\nimport androidx.navigation.compose.NavHost\nimport androidx.navigation.compose.composable\nimport androidx.compose.ui.Modifier\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport com.example.mindikot.ui.GameViewModel\nimport com.example.mindikot.ui.screens.*\n\n@Composable\nfun MainNavHost(navController: NavHostController, modifier: Modifier = Modifier) {\n    val gameViewModel: GameViewModel = viewModel() // ViewModel created once here\n\n    NavHost(navController = navController, startDestination = \"lobby\", modifier = modifier) {\n        composable(\"lobby\") {\n            LobbyScreen(navController = navController, viewModel = gameViewModel)\n        }\n        composable(\"game\") {\n            GameScreen(navController = navController, viewModel = gameViewModel)\n        }\n        composable(\"result\") {\n            ResultScreen(navController = navController) // no VM needed here\n        }\n        composable(\"waiting_for_players\") {\n            WaitingForPlayersScreen(navController = navController, viewModel = gameViewModel)\n        }\n        composable(\"game_host\") {\n            GameHostScreen(navController = navController, viewModel = gameViewModel)\n        }\n    }\n}\n"
            },
            "screens": {
                "GameHostScreen.kt": "package com.example.mindikot.ui.screens\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\nimport androidx.navigation.NavController\nimport com.example.mindikot.ui.GameViewModel\n\n@Composable\nfun GameHostScreen(navController: NavController, viewModel: GameViewModel) {\n    val gameState by viewModel.state.collectAsState()\n    val requiredPlayerCount = if (gameState.players.size == 4) 4 else 6\n    val players = gameState.players.sortedBy { if (it.name == viewModel.me) Int.MIN_VALUE else it.id }\n\n    val gameMode = gameState.gameMode\n    var isGameLoading by remember { mutableStateOf(true) } // Track if the game is being created\n\n    // Simulating the game creation process, replace with actual logic (e.g., network call)\n    LaunchedEffect(isGameLoading) {\n        // Fake loading delay\n        if (isGameLoading) {\n            // Simulate waiting for the game to be ready (e.g., create host)\n            kotlinx.coroutines.delay(2000) // This simulates a 2-second loading delay for creating the game\n            isGameLoading = false\n        }\n    }\n    LaunchedEffect(Unit) {\n        viewModel.startServer()\n    }\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(24.dp),\n        verticalArrangement = Arrangement.spacedBy(16.dp),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\"Game Host Lobby\", style = MaterialTheme.typography.headlineMedium)\n\n        // Show loading indicator while creating the game\n        if (isGameLoading) {\n            CircularProgressIndicator()\n            Text(\"Creating game...\", style = MaterialTheme.typography.bodyMedium)\n        } else {\n            // Game creation finished, now show the host lobby screen\n            Text(\"Game Mode: ${gameMode.name}\")\n            Text(\"Waiting for players... (${players.size}/$requiredPlayerCount)\")\n\n            // List of players joining the game\n            LazyColumn(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .weight(1f),\n                verticalArrangement = Arrangement.spacedBy(8.dp)\n            ) {\n                items(players) { player ->\n                    Card(\n                        modifier = Modifier.fillMaxWidth(),\n                        colors = CardDefaults.cardColors(\n                            containerColor = if (player.name == viewModel.me) MaterialTheme.colorScheme.primaryContainer\n                            else MaterialTheme.colorScheme.surface\n                        ),\n                        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)\n                    ) {\n                        Text(\n                            text = player.name + if (player.name == viewModel.me) \" (You)\" else \"\",\n                            modifier = Modifier.padding(16.dp),\n                            style = MaterialTheme.typography.bodyLarge\n                        )\n                    }\n                }\n\n            }\n\n            // Button to start the game when the required player count is met\n            Button(\n                onClick = { navController.navigate(\"game\") },\n                enabled = players.size == requiredPlayerCount\n            ) {\n                Text(\"Start Game\")\n            }\n            // Back button at the top\n            Button(\n                onClick = {\n                    viewModel.stopServer()\n                    navController.navigate(\"lobby\") {\n                        popUpTo(\"lobby\") { inclusive = true }\n                    }\n                },\n                colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.secondary)\n            ) {\n                Text(\"Go Back to Lobby\")\n            }\n\n        }\n    }\n}\n",
                "GameScreen.kt": "package com.example.mindikot.ui.screens\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyRow\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.navigation.NavController\nimport com.example.mindikot.ui.GameViewModel\nimport com.example.mindikot.core.engine.GameEngine // Needed for Decision and determineValidMoves\nimport com.example.mindikot.core.model.Card\nimport com.example.mindikot.core.state.InputType\nimport com.example.mindikot.ui.components.OtherPlayerDisplay\nimport com.example.mindikot.ui.components.PlayerCardView\nimport com.example.mindikot.ui.components.getSuitSymbol\nimport kotlinx.coroutines.flow.collectLatest\n\n@Composable\nfun GameScreen(navController: NavController, viewModel: GameViewModel = viewModel()) {\n    val gameState by viewModel.state.collectAsState()\n    val localPlayerId = viewModel.localPlayerId\n    val snackbarHostState = remember { SnackbarHostState() }\n\n    // Find the local player object (handle null briefly during init)\n    val localPlayer =\n            remember(gameState.players, localPlayerId) {\n                gameState.players.find { it.id == localPlayerId }\n            }\n\n    // Determine if it's the local player's turn\n    val isMyTurn =\n            remember(gameState.awaitingInputFromPlayerIndex, localPlayerId) {\n                gameState.awaitingInputFromPlayerIndex == localPlayerId\n            }\n\n    // Calculate valid moves when it's our turn\n    val validMoves =\n            remember(gameState, localPlayerId, isMyTurn) {\n                if (isMyTurn && localPlayer != null) {\n                    GameEngine.determineValidMoves(\n                                    playerHand = localPlayer.hand,\n                                    currentTrickPlays = gameState.currentTrickPlays,\n                                    trumpSuit = gameState.trumpSuit,\n                                    trumpRevealed = gameState.trumpRevealed\n                            )\n                            .toSet() // Use Set for faster lookups\n                } else {\n                    emptySet()\n                }\n            }\n\n    // Listen for errors\n    LaunchedEffect(Unit) {\n        viewModel.showError.collectLatest { message ->\n            snackbarHostState.showSnackbar(message = message, duration = SnackbarDuration.Short)\n        }\n    }\n\n    // Listen for navigation to results\n    LaunchedEffect(Unit) {\n        viewModel.navigateToResultScreen.collectLatest { result ->\n            // Optional: Pass result data to ResultScreen if needed\n            navController.navigate(\"result\") {\n                // Clear back stack up to lobby or game screen\n                popUpTo(\"lobby\") { inclusive = false } // Or popUpTo(\"game\") { inclusive = true }\n            }\n        }\n    }\n\n    Scaffold(snackbarHost = { SnackbarHost(hostState = snackbarHostState) }) { paddingValues ->\n        Column(\n                modifier =\n                        Modifier.fillMaxSize()\n                                .padding(paddingValues)\n                                .padding(8.dp) // Overall padding\n        ) {\n\n            // --- Top Area: Game Status ---\n            GameStatusHeader(gameState = gameState)\n\n            Spacer(modifier = Modifier.height(8.dp))\n\n            // --- Middle Area: Board (Other Players + Trick) ---\n            PlayerBoard(\n                    modifier = Modifier.weight(1f), // Takes up available space\n                    gameState = gameState,\n                    localPlayerId = localPlayerId\n            )\n\n            Spacer(modifier = Modifier.height(8.dp))\n\n            // --- Center Bottom: Action Prompt / Info ---\n            ActionPrompt(gameState = gameState, localPlayerId = localPlayerId)\n\n            Spacer(modifier = Modifier.height(8.dp))\n\n            // --- Bottom Area: Local Player Hand & Actions ---\n            if (localPlayer != null) {\n                LocalPlayerArea(\n                        localPlayerHand = localPlayer.hand,\n                        isMyTurn = isMyTurn,\n                        validMoves = validMoves,\n                        requiredInputType = gameState.requiredInputType,\n                        onCardSelected = { card -> viewModel.onCardPlayed(card) },\n                        onReveal = { viewModel.onRevealOrPass(GameEngine.Decision.REVEAL) },\n                        onPass = { viewModel.onRevealOrPass(GameEngine.Decision.PASS) }\n                )\n            } else {\n                // Placeholder if local player data isn't ready yet\n                Text(\"Loading player data...\")\n            }\n        }\n    }\n}\n\n// --- Helper Composables for GameScreen ---\n\n@Composable\nfun GameStatusHeader(gameState: com.example.mindikot.core.state.GameState) {\n    Row(\n            modifier = Modifier.fillMaxWidth().padding(horizontal = 8.dp, vertical = 4.dp),\n            horizontalArrangement = Arrangement.SpaceBetween,\n            verticalAlignment = Alignment.CenterVertically\n    ) {\n        Text(\n                text = \"Trump: ${gameState.trumpSuit?.let { getSuitSymbol(it) } ?: \"None\"}\",\n                fontWeight = FontWeight.Bold,\n                color =\n                        if (gameState.trumpRevealed) MaterialTheme.colorScheme.primary\n                        else Color.Gray\n        )\n        Text(text = \"Tricks Won:\", fontWeight = FontWeight.Bold)\n        Row {\n            gameState.teams.forEach { team ->\n                Text(\n                        text = \" T${team.id}: ${gameState.tricksWon[team.id] ?: 0}\",\n                        modifier = Modifier.padding(start = 4.dp)\n                        // Optionally color code team scores\n                        )\n            }\n        }\n    }\n    Divider() // Add a visual separator\n}\n\n@Composable\nfun PlayerBoard(\n        modifier: Modifier = Modifier,\n        gameState: com.example.mindikot.core.state.GameState,\n        localPlayerId: Int\n) {\n    // Basic layout - Needs improvement for better positioning based on player count\n    // Using BoxWithConstraints allows placing elements relative to the container size\n    BoxWithConstraints(modifier = modifier.fillMaxWidth()) {\n        val density = androidx.compose.ui.platform.LocalDensity.current\n        val widthDp = with(density) { constraints.maxWidth.toDp() }\n        val heightDp = with(density) { constraints.maxHeight.toDp() }\n\n        // --- Trick Area (Center) ---\n        Box(\n                modifier =\n                        Modifier.align(Alignment.Center)\n                                .size(\n                                        width = widthDp * 0.6f,\n                                        height = heightDp * 0.5f\n                                ), // Adjust size as needed\n                // Optional background/border for trick area\n                // .background(Color.LightGray.copy(alpha=0.2f), RoundedCornerShape(10.dp)),\n                contentAlignment = Alignment.Center\n        ) {\n            // Display cards played in the current trick\n            Row { // Simple horizontal layout for now\n                gameState.currentTrickPlays.forEach { (_, card) ->\n                    // Use a smaller card view for the trick\n                    Card(modifier = Modifier.size(50.dp, 75.dp).padding(2.dp)) {\n                        Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {\n                            Text(\n                                    text = \"${card.rank.displayName}${getSuitSymbol(card.suit)}\",\n                                    color =\n                                            com.example.mindikot.ui.components.getSuitColor(\n                                                    card.suit\n                                            ),\n                                    fontSize = 14.sp\n                            )\n                        }\n                    }\n                }\n            }\n        }\n\n        // --- Other Players ---\n        val otherPlayers = gameState.players.filter { it.id != localPlayerId }\n        // Very basic positioning based on typical 4 player layout\n        // TODO: Adapt this based on gameState.players.size (4 or 6) dynamically\n        otherPlayers.getOrNull(1)?.let { player\n            -> // Assumes player ID order corresponds roughly to seating\n            OtherPlayerDisplay(\n                    player = player,\n                    isCurrentTurn = gameState.awaitingInputFromPlayerIndex == player.id,\n                    modifier = Modifier.align(Alignment.TopCenter)\n            )\n        }\n        otherPlayers.getOrNull(0)?.let { player -> // Player typically to the left\n            OtherPlayerDisplay(\n                    player = player,\n                    isCurrentTurn = gameState.awaitingInputFromPlayerIndex == player.id,\n                    modifier = Modifier.align(Alignment.CenterStart)\n            )\n        }\n        otherPlayers.getOrNull(2)?.let { player -> // Player typically to the right\n            OtherPlayerDisplay(\n                    player = player,\n                    isCurrentTurn = gameState.awaitingInputFromPlayerIndex == player.id,\n                    modifier = Modifier.align(Alignment.CenterEnd)\n            )\n        }\n        // Add logic for players 4, 5 for 6-player game (e.g., TopLeft, TopRight, BottomLeft,\n        // BottomRight)\n    }\n}\n\n@Composable\nfun ActionPrompt(gameState: com.example.mindikot.core.state.GameState, localPlayerId: Int) {\n    val currentTurnPlayerId = gameState.awaitingInputFromPlayerIndex\n    val promptText =\n            when {\n                currentTurnPlayerId == localPlayerId -> {\n                    when (gameState.requiredInputType) {\n                        InputType.PLAY_CARD -> \"Your Turn: Play a card\"\n                        InputType.CHOOSE_TRUMP_SUIT -> \"Your Turn: Play a card to choose trump\"\n                        InputType.REVEAL_OR_PASS -> \"Your Turn: Reveal hidden card or Pass?\"\n                        null -> \"Your Turn...\" // Should ideally not happen if state logic is\n                    // correct\n                    }\n                }\n                currentTurnPlayerId != null -> {\n                    val waitingPlayerName =\n                            gameState.players.find { it.id == currentTurnPlayerId }?.name\n                                    ?: \"Opponent\"\n                    \"Waiting for $waitingPlayerName...\"\n                }\n                else -> {\n                    // No one's turn (e.g., between tricks or rounds)\n                    // Could show last trick winner briefly here using another state mechanism\n                    \"\" // Or \"Trick finished\" / \"Round Starting\" etc.\n                }\n            }\n\n    Text(\n            text = promptText,\n            modifier = Modifier.fillMaxWidth().padding(vertical = 8.dp),\n            textAlign = androidx.compose.ui.text.style.TextAlign.Center,\n            style = MaterialTheme.typography.bodyLarge,\n            fontWeight = FontWeight.Bold\n    )\n}\n\n@Composable\nfun LocalPlayerArea(\n        localPlayerHand: List<Card>,\n        isMyTurn: Boolean,\n        validMoves: Set<Card>,\n        requiredInputType: InputType?,\n        onCardSelected: (Card) -> Unit,\n        onReveal: () -> Unit,\n        onPass: () -> Unit\n) {\n    Column(horizontalAlignment = Alignment.CenterHorizontally) {\n        // --- Player Hand ---\n        LazyRow(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center) {\n            items(localPlayerHand, key = { \"${it.suit}-${it.rank}\" }) { card ->\n                PlayerCardView(\n                        card = card,\n                        isValidMove = card in validMoves,\n                        isPlayable =\n                                isMyTurn &&\n                                        (requiredInputType == InputType.PLAY_CARD ||\n                                                requiredInputType == InputType.CHOOSE_TRUMP_SUIT),\n                        onCardSelected = onCardSelected\n                )\n            }\n        }\n\n        Spacer(modifier = Modifier.height(8.dp))\n\n        // --- Action Buttons (Conditional) ---\n        if (isMyTurn && requiredInputType == InputType.REVEAL_OR_PASS) {\n            Row(horizontalArrangement = Arrangement.spacedBy(16.dp)) {\n                Button(onClick = onReveal) { Text(\"Reveal Trump\") }\n                Button(onClick = onPass) { Text(\"Pass\") }\n            }\n        }\n    }\n}\n",
                "LobbyScreen.kt": "package com.example.mindikot.ui.screens\n\nimport android.widget.Toast\nimport androidx.compose.foundation.BorderStroke\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.foundation.verticalScroll\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.unit.dp\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.navigation.NavController\nimport com.example.mindikot.core.model.GameMode\nimport com.example.mindikot.ui.GameViewModel\n\n@Composable\nfun LobbyScreen(navController: NavController, viewModel: GameViewModel) {\n    var playerName by remember { mutableStateOf(\"\") }\n    var isHost by remember { mutableStateOf(false) }\n    var availableGames by remember { mutableStateOf(listOf<String>()) }\n    var gameSelected by remember { mutableStateOf<String?>(null) }\n    var allPlayersJoined by remember { mutableStateOf(false) }\n    var hasSearched by remember { mutableStateOf(false) }\n    var role by remember { mutableStateOf<String?>(null) }\n\n    val context = LocalContext.current\n\n    LaunchedEffect(playerName) { if (playerName.isBlank()) role = null }\n\n    Column(\n            modifier = Modifier.fillMaxSize().padding(24.dp),\n            verticalArrangement = Arrangement.spacedBy(24.dp),\n            horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\"Mindikot Lobby\", style = MaterialTheme.typography.headlineMedium)\n\n        OutlinedTextField(\n                value = playerName,\n                onValueChange = {\n                    playerName = it\n                    viewModel.setPlayerName(it)\n                },\n                label = { Text(\"Enter your name\") },\n                modifier = Modifier.fillMaxWidth()\n        )\n\n        Text(\"Select your role:\", style = MaterialTheme.typography.titleMedium)\n\n        RoleSelector(\n                selectedRole = role,\n                onRoleSelected = { selected ->\n                    if (playerName.isBlank()) {\n                        Toast.makeText(context, \"Please enter your name first\", Toast.LENGTH_SHORT)\n                                .show()\n                    } else {\n                        role = selected\n                        isHost = (selected == \"Host\")\n                    }\n                }\n        )\n\n        when {\n            isHost && role == \"Host\" -> {\n                GameConfigCard(navController, viewModel, playerName)\n            }\n            role == \"Joiner\" -> {\n                JoinGameSection(\n                        hasSearched = hasSearched,\n                        availableGames = availableGames,\n                        onSearch = {\n                            hasSearched = true\n                            availableGames = listOf() // Replace with actual discovery logic\n                        },\n                        onJoin = {\n                            gameSelected = it\n                            navController.navigate(\"waiting_for_players\")\n                        }\n                )\n            }\n        }\n\n        if (isHost && allPlayersJoined) {\n            Button(onClick = { navController.navigate(\"game\") }) { Text(\"Start Game\") }\n        }\n    }\n}\n\n@Composable\nfun RoleSelector(selectedRole: String?, onRoleSelected: (String) -> Unit) {\n    Row(\n            horizontalArrangement = Arrangement.spacedBy(12.dp),\n            verticalAlignment = Alignment.CenterVertically\n    ) {\n        listOf(\"Host\", \"Joiner\").forEach { role ->\n            Button(\n                    onClick = { onRoleSelected(role) },\n                    colors =\n                            ButtonDefaults.buttonColors(\n                                    containerColor =\n                                            if (selectedRole == role)\n                                                    MaterialTheme.colorScheme.primary\n                                            else Color.Gray\n                            )\n            ) { Text(if (role == \"Joiner\") \"Randi\" else \"Host\") }\n        }\n    }\n}\n\n@Composable\nfun JoinGameSection(\n        hasSearched: Boolean,\n        availableGames: List<String>,\n        onSearch: () -> Unit,\n        onJoin: (String) -> Unit\n) {\n    Column(\n            verticalArrangement = Arrangement.spacedBy(16.dp),\n            horizontalAlignment = Alignment.CenterHorizontally,\n            modifier = Modifier.fillMaxWidth()\n    ) {\n        Text(\"Join a game lobby\", style = MaterialTheme.typography.titleMedium)\n\n        Button(onClick = onSearch) { Text(\"Search for Games\") }\n\n        if (hasSearched) {\n            if (availableGames.isEmpty()) {\n                Text(\n                        text = \"No lobby found\",\n                        style = MaterialTheme.typography.bodyLarge,\n                        color = MaterialTheme.colorScheme.error\n                )\n            } else {\n                availableGames.forEach { game ->\n                    Button(onClick = { onJoin(game) }, modifier = Modifier.fillMaxWidth()) {\n                        Text(game)\n                    }\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun GameConfigCard(navController: NavController, viewModel: GameViewModel, playerName: String) {\n    fun GameMode.displayName(): String =\n            when (this) {\n                GameMode.CHOOSE_WHEN_EMPTY -> \"Choose When Empty\"\n                GameMode.FIRST_CARD_HIDDEN -> \"First Card Hidden\"\n            }\n\n    var numberOfPlayers by remember { mutableStateOf(4) }\n    var gameMode by remember { mutableStateOf(GameMode.CHOOSE_WHEN_EMPTY) }\n\n    Card(\n            modifier = Modifier.fillMaxWidth().padding(16.dp),\n            shape = RoundedCornerShape(20.dp),\n            border = BorderStroke(2.dp, MaterialTheme.colorScheme.primary),\n            elevation = CardDefaults.cardElevation(8.dp)\n    ) {\n        // Add scroll state\n        val scrollState = rememberScrollState()\n\n        Column(\n                modifier = Modifier.fillMaxWidth().verticalScroll(scrollState).padding(24.dp),\n                horizontalAlignment = Alignment.CenterHorizontally,\n                verticalArrangement = Arrangement.spacedBy(20.dp)\n        ) {\n            Text(text = \"Game Configuration\", style = MaterialTheme.typography.headlineSmall)\n\n            Divider()\n\n            //  Player Count Selection\n            Column(\n                    verticalArrangement = Arrangement.spacedBy(12.dp),\n                    horizontalAlignment = Alignment.CenterHorizontally\n            ) {\n                Text(\"Select Number of Players\", style = MaterialTheme.typography.titleMedium)\n\n                Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {\n                    listOf(4, 6).forEach { count ->\n                        ElevatedButton(\n                                onClick = { numberOfPlayers = count },\n                                colors =\n                                        ButtonDefaults.elevatedButtonColors(\n                                                containerColor =\n                                                        if (numberOfPlayers == count)\n                                                                MaterialTheme.colorScheme.primary\n                                                        else Color.LightGray\n                                        )\n                        ) {\n                            Text(\n                                    \"$count Players\",\n                                    style = MaterialTheme.typography.labelLarge,\n                                    color =\n                                            if (numberOfPlayers == count) Color.White\n                                            else Color.Black\n                            )\n                        }\n                    }\n                }\n            }\n\n            Divider()\n\n            //  Game Mode Selection\n            Column(\n                    verticalArrangement = Arrangement.spacedBy(12.dp),\n                    horizontalAlignment = Alignment.CenterHorizontally\n            ) {\n                Text(\"Select Game Mode\", style = MaterialTheme.typography.titleMedium)\n\n                Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {\n                    GameMode.entries.forEach { mode ->\n                        ElevatedButton(\n                                onClick = { gameMode = mode },\n                                modifier = Modifier.width(160.dp), // Adjust width as needed\n                                colors =\n                                        ButtonDefaults.elevatedButtonColors(\n                                                containerColor =\n                                                        if (gameMode == mode)\n                                                                MaterialTheme.colorScheme.primary\n                                                        else Color.LightGray\n                                        )\n                        ) {\n                            Text(\n                                    text = mode.displayName(),\n                                    style = MaterialTheme.typography.labelLarge,\n                                    color = if (gameMode == mode) Color.White else Color.Black,\n                                    maxLines = 2,\n                                    textAlign = TextAlign.Center\n                            )\n                        }\n                    }\n                }\n            }\n\n            Divider()\n\n            //  Summary\n            Column(horizontalAlignment = Alignment.CenterHorizontally) {\n                Text(\n                        text = \"\u00e2\u0153\u2026 Players: $numberOfPlayers\",\n                        style = MaterialTheme.typography.bodyLarge\n                )\n                Text(\n                        text = \"\u00e2\u0153\u2026 Mode: ${gameMode.displayName()}\",\n                        style = MaterialTheme.typography.bodyLarge\n                )\n            }\n\n            //  Confirm\n            Button(\n                    onClick = {\n                        viewModel.setupGame(\n                                playerName,\n                                gameMode,\n                                host = true,\n                                playersNeeded = numberOfPlayers\n                        )\n                        navController.navigate(\"game_host\")\n                    },\n                    enabled = numberOfPlayers in listOf(4, 6),\n                    modifier = Modifier.fillMaxWidth().padding(top = 12.dp)\n            ) { Text(\"Create Game\") }\n        }\n    }\n}\n",
                "ResultScreen.kt": "package com.example.mindikot.ui.screens\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\nimport androidx.navigation.NavHostController\nimport com.example.mindikot.core.engine.RoundEvaluator\nimport com.example.mindikot.ui.GameViewModel\n\n@Composable\nfun ResultScreen(\n        navController: NavHostController,\n        viewModel: GameViewModel = androidx.lifecycle.viewmodel.compose.viewModel()\n) {\n    val gameState by viewModel.state.collectAsState()\n\n    val roundResult = remember(gameState) { RoundEvaluator.evaluateRound(gameState) }\n\n    Column(\n            modifier = Modifier.fillMaxSize().padding(24.dp),\n            verticalArrangement = Arrangement.Center,\n            horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\n                text = roundResult.winningTeam?.let { \" Team ${it.id} wins!\" } ?: \"No winning team\",\n                style = MaterialTheme.typography.headlineLarge\n        )\n\n        Spacer(modifier = Modifier.height(16.dp))\n\n        Text(\n                text = if (roundResult.isKot) \" KOT! All four 10s collected!\" else \"Regular Win\",\n                style = MaterialTheme.typography.bodyLarge\n        )\n\n        Spacer(modifier = Modifier.height(32.dp))\n\n        Button(\n                onClick = {\n                    viewModel.restartGame()\n                    navController.navigate(\"lobby\") { popUpTo(\"result\") { inclusive = true } }\n                }\n        ) { Text(\"Back to Lobby\") }\n    }\n}\n",
                "WaitingForPlayersScreen.kt": "package com.example.mindikot.ui.screens\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.navigation.NavController\nimport com.example.mindikot.ui.GameViewModel\n\n@Composable\nfun WaitingForPlayersScreen(navController: NavController, viewModel: GameViewModel = viewModel()) {\n    val gameState by viewModel.state.collectAsState()\n    val isHost = viewModel.isHost\n    val players = gameState.players\n    val requiredPlayers = viewModel.requiredPlayerCount\n    val gameStarted by viewModel.gameStarted.collectAsState()\n\n    // Auto-navigate for joiners when game starts\n    LaunchedEffect(gameStarted) {\n        if (!isHost && gameStarted) {\n            navController.navigate(\"game\") {\n                popUpTo(\"waiting_for_players\") { inclusive = true }\n            }\n        }\n    }\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(24.dp),\n        verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\"Waiting for Players...\", style = MaterialTheme.typography.headlineMedium)\n\n        Text(\"Connected Players: ${players.size} / $requiredPlayers\")\n\n        // Show the player names\n        players.forEach {\n            Text(text = it.name, style = MaterialTheme.typography.bodyLarge)\n        }\n\n        if (isHost) {\n            Text(\"You are the host. Start the game when ready.\")\n            Button(\n                onClick = {\n                    viewModel.startGame()\n                    navController.navigate(\"game\")\n                },\n                enabled = players.size == requiredPlayers\n            ) {\n                Text(\"Start Game\")\n            }\n        } else {\n            Text(\"Waiting for host to start the game...\")\n        }\n    }\n}\n"
            },
            "theme": {
                "Color.kt": "package com.example.mindikot.ui.theme\n\nimport androidx.compose.ui.graphics.Color\n\nval Purple80 = Color(0xFFD0BCFF)\nval PurpleGrey80 = Color(0xFFCCC2DC)\nval Pink80 = Color(0xFFEFB8C8)\n\nval Purple40 = Color(0xFF6650a4)\nval PurpleGrey40 = Color(0xFF625b71)\nval Pink40 = Color(0xFF7D5260)\n",
                "Theme.kt": "package com.example.mindikot.ui.theme\n\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.platform.LocalContext\n\nprivate val LightColors = lightColorScheme(\n    primary = Purple40,\n    secondary = PurpleGrey40,\n    tertiary = Pink40\n)\n\n@Composable\nfun MindikotTheme(\n    useDarkTheme: Boolean = isSystemInDarkTheme(),\n    content: @Composable () -> Unit\n) {\n    MaterialTheme(\n        colorScheme = LightColors,\n        typography = Typography(),\n        content = content\n    )\n}\n"
            }
        }
    }
}