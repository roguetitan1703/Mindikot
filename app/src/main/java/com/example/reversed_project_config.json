{
    "project_name": "mindikot",
    "structure": {
        "core": {
            "engine": {
                "DeckGenerator.kt": "package com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\n\nobject DeckGenerator {\n    /**\n     * Generates a standard Mindikot deck. For 6 players, Twos are excluded.\n     * @param numPlayers The number of players (4 or 6).\n     * @return A shuffled list of cards for the game.\n     */\n    fun generateDeck(numPlayers: Int): MutableList<Card> {\n        require(numPlayers == 4 || numPlayers == 6) { \"Mindikot supports 4 or 6 players only.\" }\n        val includeTwos = (numPlayers == 4)\n\n        val deck = mutableListOf<Card>()\n        val allSuits = Suit.values()\n        val allRanks = Rank.values()\n\n        for (suit in allSuits) {\n            for (rank in allRanks) {\n                // Skip Twos if playing with 6 players\n                if (!includeTwos && rank == Rank.TWO) {\n                    continue\n                }\n                deck.add(Card(suit, rank))\n            }\n        }\n        // Shuffle the generated deck thoroughly before returning\n        return deck.shuffled().toMutableList()\n    }\n}\n",
                "GameEngine.kt": "package com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\nimport com.example.mindikot.core.state.GameState\nimport com.example.mindikot.core.state.InputType\n\n/**\n * Manages the core game flow, including playing tricks and handling state transitions. NOTE: This\n * implementation outlines the logic flow. A real implementation would need mechanisms (like\n * callbacks, suspend functions, or StateFlow) to handle asynchronous player input from the\n * UI/ViewModel layer. The points requiring input are marked.\n */\nobject GameEngine {\n\n    /**\n     * Determines the set of cards a player can legally play on their turn.\n     *\n     * @param playerHand The list of cards currently in the player's hand.\n     * @param currentTrickPlays The list of (Player, Card) pairs already played in the current\n     * trick.\n     * @param trumpSuit The current trump suit (null if not set).\n     * @param trumpRevealed Whether trump has been revealed.\n     * @return A list of cards from the player's hand that are valid to play.\n     */\n    fun determineValidMoves(\n            playerHand: List<Card>,\n            currentTrickPlays: List<Pair<Player, Card>>,\n            trumpSuit: Suit?,\n            trumpRevealed: Boolean\n    ): List<Card> {\n\n        // If player is leading the trick (no cards played yet)\n        if (currentTrickPlays.isEmpty()) {\n            return playerHand // Can lead any card\n        }\n\n        val leadCard = currentTrickPlays.first().second\n        val leadSuit = leadCard.suit\n\n        // Check if player can follow the lead suit\n        val cardsInLeadSuit = playerHand.filter { it.suit == leadSuit }\n        if (cardsInLeadSuit.isNotEmpty()) {\n            return cardsInLeadSuit // Must follow suit\n        }\n\n        // --- Cannot follow suit ---\n\n        // Check if trump is revealed and active\n        if (trumpRevealed && trumpSuit != null) {\n            // Rule: If cannot follow suit and trump is set, play ANY card.\n            return playerHand\n        } else {\n            // Rule: If cannot follow suit and trump is NOT set, play ANY card.\n            // The decision to CHOOSE/REVEAL/PASS happens separately.\n            // Special case: Mode B Reveal requires trump play if possible AFTER reveal.\n            // This function determines playable cards BEFORE that decision point.\n            return playerHand\n        }\n    }\n\n    // --- Interaction State Management Functions ---\n\n    /**\n     * Prepares the game state to request input from the appropriate player. This should be called\n     * at the start of a trick or after a player has played.\n     *\n     * @param state The current GameState to modify.\n     * @param playerIndex The index of the player whose turn it is.\n     * @return The modified GameState with updated input requirements.\n     */\n    fun requestInput(state: GameState, playerIndex: Int): GameState {\n        val currentPlayer = state.players[playerIndex]\n\n        if (state.currentTrickPlays.isEmpty()) { // Leading the trick\n            state.requiredInputType = InputType.PLAY_CARD\n        } else {\n            val leadSuit = state.currentTrickPlays.first().second.suit\n            val canFollowSuit = currentPlayer.hand.any { it.suit == leadSuit }\n\n            if (canFollowSuit) {\n                state.requiredInputType = InputType.PLAY_CARD\n            } else { // Cannot follow suit\n                if (state.trumpRevealed) {\n                    state.requiredInputType = InputType.PLAY_CARD // Play any card\n                } else { // Trump not revealed - need trump decision\n                    when (state.gameMode) {\n                        GameMode.CHOOSE_WHEN_EMPTY ->\n                                state.requiredInputType =\n                                        InputType.CHOOSE_TRUMP_SUIT // Player must play card to set\n                        // trump\n                        GameMode.FIRST_CARD_HIDDEN ->\n                                state.requiredInputType =\n                                        InputType.REVEAL_OR_PASS // Player chooses Reveal or Pass\n                    }\n                }\n            }\n        }\n        state.awaitingInputFromPlayerIndex = playerIndex\n        println(\n                \"GameEngine: Requesting ${state.requiredInputType} from Player ${state.players[playerIndex].name}\"\n        ) // Logging\n        return state\n    }\n\n    /**\n     * Processes the input received from a player (card played or trump decision). Validates the\n     * input against the rules and current state. Advances the game state (plays card, sets trump,\n     * finishes trick/round).\n     *\n     * @param currentState The current state of the game.\n     * @param playerInput The input received from the player (e.g., Card object, Decision enum).\n     * @return An updated GameState. The state might indicate further input is needed from the next\n     * player, or that the round/game ended.\n     */\n    fun processPlayerInput(\n            currentState: GameState,\n            playerInput:\n                    Any // Could be Card, Decision (Reveal/Pass), Suit (for potential future Mode A\n            // choice)\n            ): GameState {\n\n        val playerIndex =\n                currentState.awaitingInputFromPlayerIndex\n                        ?: run {\n                            println(\"Error: processPlayerInput called when no input was expected.\")\n                            return currentState // Or throw error\n                        }\n        val currentPlayer = currentState.players[playerIndex]\n        val currentRequirement = currentState.requiredInputType\n\n        println(\n                \"GameEngine: Processing input from Player ${currentPlayer.name}, expected: $currentRequirement, received: $playerInput\"\n        ) // Logging\n\n        // --- Validate and Process Input ---\n        when (currentRequirement) {\n            InputType.CHOOSE_TRUMP_SUIT -> {\n                // Mode A: Expecting a Card to be played which sets the trump\n                val playedCard = playerInput as? Card\n                if (playedCard == null || !currentPlayer.hand.contains(playedCard)) {\n                    println(\"Error: Invalid card provided for CHOOSE_TRUMP_SUIT.\")\n                    return currentState // Re-request input\n                }\n                // Validate it's a valid play (must be unable to follow suit)\n                val leadSuit = currentState.currentTrickPlays.firstOrNull()?.second?.suit\n                if (leadSuit != null && currentPlayer.hand.any { it.suit == leadSuit }) {\n                    println(\"Error: Player could follow suit, should not be choosing trump.\")\n                    return currentState // State logic error or invalid input sequence\n                }\n\n                TrumpHandler.setTrumpFromPlayedCard(currentState, playedCard)\n                playCard(currentState, currentPlayer, playedCard) // Play the card\n            }\n            InputType.REVEAL_OR_PASS -> {\n                // Mode B: Expecting a Decision (Reveal or Pass)\n                when (playerInput as? Decision) {\n                    Decision.REVEAL -> {\n                        TrumpHandler.revealHiddenTrump(currentState)\n                        // Now need player to play (Must play trump if possible)\n                        currentState.requiredInputType = InputType.PLAY_CARD\n                        currentState.awaitingInputFromPlayerIndex =\n                                playerIndex // Still this player's turn\n                        println(\n                                \"GameEngine: Player revealed trump. Requesting card play (must play trump if possible).\"\n                        )\n                        return currentState // Request card input with reveal constraint\n                    }\n                    Decision.PASS -> {\n                        TrumpHandler.handleTrumpPass(currentState)\n                        // Player plays ANY card\n                        currentState.requiredInputType = InputType.PLAY_CARD\n                        currentState.awaitingInputFromPlayerIndex =\n                                playerIndex // Still this player's turn\n                        println(\"GameEngine: Player passed trump. Requesting any card play.\")\n                        return currentState // Request card input (any card valid)\n                    }\n                    else -> {\n                        println(\"Error: Invalid decision provided for REVEAL_OR_PASS.\")\n                        return currentState // Re-request input\n                    }\n                }\n            }\n            InputType.PLAY_CARD -> {\n                val playedCard = playerInput as? Card\n                if (playedCard == null || !currentPlayer.hand.contains(playedCard)) {\n                    println(\"Error: Invalid card provided for PLAY_CARD.\")\n                    return currentState // Re-request input\n                }\n\n                // --- Complex Validation for PLAY_CARD ---\n                val leadSuit = currentState.currentTrickPlays.firstOrNull()?.second?.suit\n                val canFollowSuit =\n                        if (leadSuit != null) currentPlayer.hand.any { it.suit == leadSuit }\n                        else false\n\n                // 1. Must follow suit if possible?\n                if (leadSuit != null && playedCard.suit != leadSuit && canFollowSuit) {\n                    println(\n                            \"Error: Player must follow suit $leadSuit but played ${playedCard.suit}.\"\n                    )\n                    return currentState // Re-request input\n                }\n\n                // 2. Mode B Post-Reveal Constraint: Must play trump if revealed and possible?\n                // Need a way to know if this PLAY_CARD followed a REVEAL action in the same turn\n                // cycle...\n                // This architecture makes tracking that tricky. A state machine or temporary flag\n                // might be needed.\n                // Assuming for now the UI/ViewModel layer handles this constraint check *before*\n                // sending.\n\n                // If validation passes:\n                playCard(currentState, currentPlayer, playedCard)\n            }\n            null -> {\n                println(\"Error: processPlayerInput called when requiredInputType is null.\")\n                return currentState\n            }\n        }\n\n        // --- Post-Play State Update ---\n        currentState.requiredInputType = null // Reset requirement after successful processing\n        currentState.awaitingInputFromPlayerIndex = null // Clear awaiting player\n\n        // Check if trick is complete\n        if (currentState.currentTrickPlays.size == currentState.players.size) {\n            finishTrick(\n                    currentState\n            ) // Determine winner, collect cards, update tricksWon, set next leader\n\n            // Check if round ended (hands are empty)\n            if (currentState.players.first().hand.isEmpty()) {\n                println(\"GameEngine: Round finished.\")\n                // --- End of Round ---\n                // Caller (ViewModel) should check hand size and call RoundEvaluator\n                // and handle scoring/next round setup.\n            } else {\n                // Start next trick by requesting input from the new leader\n                return requestInput(currentState, currentState.currentLeaderIndex)\n            }\n        } else {\n            // Trick continues, request input from the next player\n            val nextPlayerIndex = (playerIndex + 1) % currentState.players.size\n            return requestInput(currentState, nextPlayerIndex)\n        }\n\n        return currentState // Return the final state after processing\n    }\n\n    /** Helper to add card to trick plays and remove from hand */\n    private fun playCard(state: GameState, player: Player, card: Card) {\n        state.currentTrickPlays.add(player to card)\n        player.hand.remove(card)\n        println(\"GameEngine: Player ${player.name} played ${card}\") // Logging\n    }\n\n    /** Called when a trick is complete to determine winner and collect cards. */\n    private fun finishTrick(state: GameState) {\n        println(\"GameEngine: Trick finished. Plays: ${state.currentTrickPlays.map { it.second }}\")\n        val winnerPlayer =\n                TrickHandler.determineTrickWinner(state.currentTrickPlays, state.trumpSuit)\n        val winnerIndex = state.players.indexOf(winnerPlayer)\n        println(\"GameEngine: Trick winner: ${winnerPlayer.name}\") // Logging\n\n        // Collect cards for the winning team\n        val winningTeam =\n                state.teams.first {\n                    it.id == winnerPlayer.teamId\n                } // Assuming player.teamId is correct\n        winningTeam.collectedCards.addAll(state.currentTrickPlays.map { it.second })\n        // println(\"Team ${winningTeam.id} collected cards. Total tens: ${winningTeam.countTens()}\")\n        // // Logging\n\n        // --- Update trick count ---\n        val currentTrickCount = state.tricksWon.getOrDefault(winningTeam.id, 0)\n        state.tricksWon[winningTeam.id] = currentTrickCount + 1 // Increment trick count\n        println(\n                \"GameEngine: Team ${winningTeam.id} tricks won this round: ${state.tricksWon[winningTeam.id]}\"\n        ) // Logging trick count\n\n        // Clear trick plays and set next leader\n        state.currentTrickPlays.clear()\n        state.currentLeaderIndex = winnerIndex\n\n        // Reset input requirement for the start of the next trick\n        // The requestInput function will be called next, setting the specific input type.\n        state.requiredInputType = null\n        state.awaitingInputFromPlayerIndex = null\n    }\n\n    // Enum for Reveal/Pass decision\n    enum class Decision {\n        REVEAL,\n        PASS\n    }\n}\n",
                "RoundEvaluator.kt": "package com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\nimport com.example.mindikot.core.state.GameState\n\nobject RoundEvaluator {\n\n    /**\n     * Data class to hold the result of a round evaluation.\n     * @property winningTeam The team that won the round (can be null if draw).\n     * @property isKot True if the win was due to collecting all four Tens.\n     */\n    data class RoundResult(val winningTeam: Team?, val isKot: Boolean)\n\n    /**\n     * Evaluates the end of a round: checks for Kot, then majority of tens, then trick tie-breaker.\n     *\n     * @param state The final GameState at the end of the round.\n     * @return RoundResult indicating the winning team (or null for draw) and whether it was a Kot\n     * win.\n     */\n    fun evaluateRound(state: GameState): RoundResult {\n        val teams = state.teams\n        println(\"Evaluating round end...\") // Logging\n\n        // 1. Instant Kot Check\n        teams.find { it.hasKot() }?.let {\n            println(\"Team ${it.id} wins round by KOT!\") // Logging\n            return RoundResult(it, true)\n        }\n\n        // 2. Count Tens for each team\n        val teamTensCount = teams.associate { team -> team.id to team.countTens() }\n        println(\"Tens collected: $teamTensCount\") // Logging\n\n        // 3. Determine Team with Most Tens\n        val maxTens = teamTensCount.values.maxOrNull() ?: 0\n        val teamsWithMaxTensIds = teamTensCount.filterValues { it == maxTens }.keys\n\n        // 4. Handle Winner Determination\n        if (teamsWithMaxTensIds.size == 1) {\n            // One team has clear majority of tens\n            val winningTeamId = teamsWithMaxTensIds.first()\n            val winningTeam = teams.first { it.id == winningTeamId }\n            println(\n                    \"Team ${winningTeam.id} wins round with majority of tens ($maxTens).\"\n            ) // Logging\n            return RoundResult(winningTeam, false) // Not Kot\n        } else if (teamsWithMaxTensIds.size > 1) {\n            // Tie in tens - apply trick tie-breaker\n            println(\"Tie in tens ($maxTens each). Applying trick tie-breaker.\") // Logging\n            val teamTricksWon = state.tricksWon // Get tricks won map from GameState\n            val tiedTeamsTrickCounts = teamTricksWon.filterKeys { it in teamsWithMaxTensIds }\n            println(\"Tricks won by tied teams: $tiedTeamsTrickCounts\") // Logging\n\n            val maxTricks =\n                    tiedTeamsTrickCounts.values.maxOrNull()\n                            ?: -1 // Use -1 to detect no tricks won case\n            val teamsWithMaxTricks = tiedTeamsTrickCounts.filterValues { it == maxTricks }.keys\n\n            if (teamsWithMaxTricks.size == 1) {\n                // One team won more tricks among the tied teams\n                val winningTeamId = teamsWithMaxTricks.first()\n                val winningTeam = teams.first { it.id == winningTeamId }\n                println(\n                        \"Team ${winningTeam.id} wins round due to trick tie-breaker ($maxTricks tricks).\"\n                ) // Logging\n                return RoundResult(winningTeam, false) // Not Kot\n            } else {\n                // Still tied (same number of tens AND same number of tricks) -> Draw\n                println(\"Round is a DRAW (tied tens and tricks).\") // Logging\n                return RoundResult(null, false) // Indicate draw\n            }\n        } else {\n            // Should not happen if there are teams, means no tens collected by anyone? Treat as\n            // draw.\n            println(\n                    \"Round evaluation resulted in no winner (possibly no tens collected). Treating as Draw.\"\n            ) // Logging\n            return RoundResult(null, false)\n        }\n    }\n}\n",
                "TrickHandler.kt": "package com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\n\nobject TrickHandler {\n    /**\n     * Determines the winner of a completed trick based on Mindikot rules.\n     *\n     * @param playedCards A list of (Player, Card) pairs representing the cards played in the trick,\n     * in order.\n     * @param trumpSuit The active trump suit for the round (can be null if trump is not set).\n     * @return The Player who won the trick.\n     */\n    fun determineTrickWinner(playedCards: List<Pair<Player, Card>>, trumpSuit: Suit?): Player {\n        require(playedCards.isNotEmpty()) { \"Cannot determine winner of an empty trick.\" }\n\n        val leadSuit = playedCards.first().second.suit\n        // var winningPlay: Pair<Player, Card> = playedCards.first() // Assume leader wins initially\n        var winningPlay: Pair<Player, Card>\n\n        // Check for highest trump card first\n        val trumpPlays = playedCards.filter { it.second.suit == trumpSuit && trumpSuit != null }\n        if (trumpPlays.isNotEmpty()) {\n            winningPlay = trumpPlays.maxByOrNull { it.second.rank.value }!!\n        } else {\n            // No trump played, check for highest card of the lead suit\n            val leadSuitPlays = playedCards.filter { it.second.suit == leadSuit }\n            // We know leadSuitPlays is not empty because the leader played one.\n            winningPlay = leadSuitPlays.maxByOrNull { it.second.rank.value }!!\n        }\n\n        return winningPlay.first // Return the winning player\n    }\n}\n",
                "TrumpHandler.kt": "package com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.state.GameState\n\n/**\n * Contains simple helper functions to update the game state related to trump setting. These\n * functions are intended to be called by the GameEngine AFTER a player has made their trump-related\n * decision via external input (UI/ViewModel).\n */\nobject TrumpHandler {\n\n    /**\n     * Updates the game state when a player chooses a trump suit in CHOOSE_WHEN_EMPTY mode by\n     * playing a card that establishes the trump. Precondition: state.trumpRevealed should be false.\n     *\n     * @param state The current GameState to modify.\n     * @param cardPlayed The card whose suit sets the trump.\n     */\n    fun setTrumpFromPlayedCard(state: GameState, cardPlayed: com.example.mindikot.core.model.Card) {\n        if (!state.trumpRevealed) {\n            state.trumpSuit = cardPlayed.suit\n            state.trumpRevealed = true\n            println(\n                    \"TrumpHandler: Trump set to ${state.trumpSuit} by card ${cardPlayed}\"\n            ) // Logging\n        }\n    }\n\n    /**\n     * Updates the game state when a player chooses to reveal the hidden card in FIRST_CARD_HIDDEN\n     * mode. Precondition: state.trumpRevealed should be false and state.hiddenCard should not be\n     * null.\n     *\n     * @param state The current GameState to modify.\n     */\n    fun revealHiddenTrump(state: GameState) {\n        if (!state.trumpRevealed &&\n                        state.hiddenCard != null &&\n                        state.gameMode == com.example.mindikot.core.model.GameMode.FIRST_CARD_HIDDEN\n        ) {\n            state.trumpSuit = state.hiddenCard!!.suit // Set trump to hidden card's suit\n            state.trumpRevealed = true\n            println(\n                    \"TrumpHandler: Trump revealed as ${state.trumpSuit} from hidden card\"\n            ) // Logging\n            // Note: GameEngine must enforce the special play rule for this turn.\n        }\n    }\n\n    /**\n     * Placeholder function to acknowledge the \"Pass\" action in FIRST_CARD_HIDDEN mode. No state\n     * change is needed regarding trump itself.\n     *\n     * @param state The current GameState (not modified here).\n     */\n    fun handleTrumpPass(state: GameState) {\n        // No change to state.trumpSuit or state.trumpRevealed.\n        println(\"TrumpHandler: Player chose to Pass.\") // Logging\n        // GameEngine allows the player to play any card for this trick.\n    }\n}\n"
            },
            "main.py": "from pathlib import Path\n\n# base_dir = Path(\"/mnt/data/mindikot/src/main/java/com/example/mindikot/core\")\nbase_dir = Path(\"src/main/java/com/example/mindikot/core\")\n\n# All file paths relative to base_dir with updated content\nupdated_files_content = {\n    \"model/Card.kt\": \"\"\"\npackage com.example.mindikot.core.model\n\ndata class Card(val suit: Suit, val rank: Rank) {\n    override fun toString(): String = \"${'$'}rank of ${'$'}suit\"\n}\n\"\"\",\n    \"model/Suit.kt\": \"\"\"\npackage com.example.mindikot.core.model\n\nenum class Suit {\n    HEARTS, DIAMONDS, CLUBS, SPADES\n}\n\"\"\",\n    \"model/Rank.kt\": \"\"\"\npackage com.example.mindikot.core.model\n\nenum class Rank(val value: Int) {\n    THREE(3), FOUR(4), FIVE(5), SIX(6), SEVEN(7), EIGHT(8), NINE(9),\n    TEN(10), JACK(11), QUEEN(12), KING(13), ACE(14)\n}\n\"\"\",\n    \"model/Player.kt\": \"\"\"\npackage com.example.mindikot.core.model\n\ndata class Player(val id: Int, val name: String, val teamId: Int, val hand: MutableList<Card> = mutableListOf()) {\n    override fun toString() = \"Player(id=${'$'}id, name=${'$'}name, team=${'$'}teamId)\"\n}\n\"\"\",\n    \"model/Team.kt\": \"\"\"\npackage com.example.mindikot.core.model\n\ndata class Team(val id: Int, val players: List<Player>, val collectedCards: MutableList<Card> = mutableListOf()) {\n    fun countTens(): Int = collectedCards.count { it.rank == Rank.TEN }\n    fun hasKot(): Boolean = countTens() == 4\n}\n\"\"\",\n    \"model/GameMode.kt\": \"\"\"\npackage com.example.mindikot.core.model\n\nenum class GameMode {\n    CHOOSE_WHEN_EMPTY,\n    FIRST_CARD_HIDDEN\n}\n\"\"\",\n    \"engine/DeckGenerator.kt\": \"\"\"\npackage com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\n\nobject DeckGenerator {\n    fun generateDeck(includeTwos: Boolean): MutableList<Card> {\n        val deck = mutableListOf<Card>()\n        for (suit in Suit.values()) {\n            for (rank in Rank.values()) {\n                if (!includeTwos && rank == Rank.THREE) continue\n                deck.add(Card(suit, rank))\n            }\n        }\n        return deck.shuffled().toMutableList()\n    }\n}\n\"\"\",\n    \"engine/TrickHandler.kt\": \"\"\"\npackage com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\n\nobject TrickHandler {\n    fun determineTrickWinner(playedCards: List<Pair<Player, Card>>, trumpSuit: Suit?): Player {\n        val leadSuit = playedCards.first().second.suit\n        val validCards = playedCards.map { (player, card) ->\n            val score = when {\n                card.suit == trumpSuit -> card.rank.value + 100\n                card.suit == leadSuit -> card.rank.value\n                else -> 0\n            }\n            Triple(player, card, score)\n        }\n        return validCards.maxBy { it.third }.first\n    }\n}\n\"\"\",\n    \"engine/TrumpHandler.kt\": \"\"\"\npackage com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\n\nobject TrumpHandler {\n    fun chooseTrumpFromHand(player: Player): Suit {\n        return player.hand.groupingBy { it.suit }.eachCount().maxBy { it.value }.key\n    }\n}\n\"\"\",\n    \"engine/RoundEvaluator.kt\": \"\"\"\npackage com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\n\nobject RoundEvaluator {\n    data class RoundResult(val winningTeam: Team, val isKot: Boolean)\n\n    fun evaluateRound(teams: List<Team>): RoundResult {\n        val teamWithKot = teams.find { it.hasKot() }\n        return if (teamWithKot != null) {\n            RoundResult(teamWithKot, true)\n        } else {\n            val team = teams.maxBy { it.countTens() }\n            RoundResult(team, false)\n        }\n    }\n}\n\"\"\",\n    \"engine/GameEngine.kt\": \"\"\"\npackage com.example.mindikot.core.engine\n\nimport com.example.mindikot.core.model.*\nimport com.example.mindikot.core.state.GameState\n\nobject GameEngine {\n    fun playTrick(state: GameState, leaderIndex: Int): Int {\n        val trickCards = mutableListOf<Pair<Player, Card>>()\n        val players = state.players\n        val trumpSuit = state.trumpSuit\n\n        for (i in 0 until players.size) {\n            val currentPlayer = players[(leaderIndex + i) % players.size]\n            val playableCard = currentPlayer.hand.removeAt(0)\n            trickCards.add(currentPlayer to playableCard)\n        }\n\n        val winner = TrickHandler.determineTrickWinner(trickCards, trumpSuit)\n        val team = state.teams.first { it.id == winner.teamId }\n        team.collectedCards.addAll(trickCards.map { it.second })\n\n        return players.indexOf(winner)\n    }\n}\n\"\"\",\n    \"state/GameState.kt\": \"\"\"\npackage com.example.mindikot.core.state\n\nimport com.example.mindikot.core.model.*\n\ndata class GameState(\n    val players: List<Player>,\n    val teams: List<Team>,\n    val gameMode: GameMode,\n    var trumpSuit: Suit? = null,\n    var hiddenTrumpCard: Card? = null\n)\n\"\"\"\n}\n\n# Write each updated file\nfor relative_path, content in updated_files_content.items():\n    path = base_dir / relative_path\n    path.parent.mkdir(parents=True, exist_ok=True)\n    path.write_text(content.strip())\n\n\"\u00e2\u0153\u2026 All specified files were created/updated with actual logic.\"\n",
            "model": {
                "Card.kt": "package com.example.mindikot.core.model\n\ndata class Card(val suit: Suit, val rank: Rank) {\n    override fun toString(): String = \"${rank.displayName} of ${suit}\"\n}\n",
                "GameMode.kt": "package com.example.mindikot.core.model\n\nenum class GameMode {\n    CHOOSE_WHEN_EMPTY,\n    FIRST_CARD_HIDDEN\n}\n",
                "Player.kt": "package com.example.mindikot.core.model\n\ndata class Player(\n    val id: Int,\n    val name: String,\n    val teamId: Int,\n    var hand: MutableList<Card> = mutableListOf()\n) {\n    override fun toString() = \"Player(id=$id, name=$name, team=$teamId)\"\n}\n",
                "Rank.kt": "package com.example.mindikot.core.model\n\nenum class Rank(val value: Int, val displayName: String) {\n    TWO(2, \"2\"),\n    THREE(3, \"3\"),\n    FOUR(4, \"4\"),\n    FIVE(5, \"5\"),\n    SIX(6, \"6\"),\n    SEVEN(7, \"7\"),\n    EIGHT(8, \"8\"),\n    NINE(9, \"9\"),\n    TEN(10, \"10\"),\n    JACK(11, \"J\"),\n    QUEEN(12, \"Q\"),\n    KING(13, \"K\"),\n    ACE(14, \"A\")\n}\n",
                "Suit.kt": "package com.example.mindikot.core.model\n\nenum class Suit {\n    HEARTS, DIAMONDS, CLUBS, SPADES\n}\n",
                "Team.kt": "package com.example.mindikot.core.model\n\ndata class Team(\n    val id: Int,\n    val players: List<Player>,\n    val collectedCards: MutableList<Card> = mutableListOf()\n) {\n    fun countTens(): Int = collectedCards.count { it.rank == Rank.TEN }\n    fun hasKot(): Boolean = countTens() == 4\n}\n"
            },
            "state": {
                "GameState.kt": "package com.example.mindikot.core.state\n\nimport com.example.mindikot.core.model.*\n\n/**\n * Represents the complete state of the Mindikot game at any point in time. This object should be\n * immutable or handled carefully to ensure state consistency, especially when shared across network\n * or threads. Consider using immutable data structures if concurrency becomes complex.\n *\n * @property players List of all players participating in the game.\n * @property teams List of the teams, typically containing references to their players and collected\n * cards.\n * @property gameMode The selected mode for trump determination (e.g., CHOOSE_WHEN_EMPTY,\n * FIRST_CARD_HIDDEN).\n * @property currentLeaderIndex The index (in the `players` list) of the player who leads the\n * current or next trick.\n * @property trumpSuit The suit designated as trump for the current round. Null if trump has not\n * been set yet.\n * @property trumpRevealed Boolean flag indicating whether the trump suit has been determined and\n * revealed for the current round.\n * @property hiddenCard In FIRST_CARD_HIDDEN mode, this holds the card set aside *before dealing*.\n * Null otherwise.\n * @property currentTrickPlays The cards played so far in the trick-in-progress. List<Pair<Player,\n * Card>>.\n * @property awaitingInputFromPlayerIndex Index of the player from whom input is currently awaited.\n * Null if the engine is processing or trick/round ended.\n * @property requiredInputType The type of input needed from the awaiting player.\n * @property tricksWon A map storing the number of tricks won by each team (TeamId -> Trick Count)\n * in the current round. Used for tie-breaking.\n */\ndata class GameState(\n        val players: List<Player>,\n        val teams: List<Team>,\n        val gameMode: GameMode,\n        var currentLeaderIndex: Int = 0,\n        var trumpSuit: Suit? = null,\n        var trumpRevealed: Boolean = false,\n        var hiddenCard: Card? = null, // Card set aside BEFORE dealing in FIRST_CARD_HIDDEN mode\n        val currentTrickPlays: MutableList<Pair<Player, Card>> =\n                mutableListOf(), // State of the current trick\n        var awaitingInputFromPlayerIndex: Int? = null, // Which player needs to act\n        var requiredInputType: InputType? = null, // What kind of action is needed\n        val tricksWon: MutableMap<Int, Int> =\n                mutableMapOf() // TeamId -> Trick Count for current round\n)\n\n/** Enum to represent the type of input currently required from a player. */\nenum class InputType {\n    PLAY_CARD, // Player needs to select a card to play\n    CHOOSE_TRUMP_SUIT, // Player needs to choose a trump suit by playing a card (Mode A)\n    REVEAL_OR_PASS // Player needs to decide Reveal or Pass (Mode B)\n}\n"
            }
        },
        "GameViewModel.kt": "package com.example.mindikot.ui\n\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.mindikot.core.model.*\nimport com.example.mindikot.core.state.GameState\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport java.io.BufferedReader\nimport java.io.InputStreamReader\nimport java.net.ServerSocket\n\nclass GameViewModel : ViewModel() {\n    private fun logGameState(tag: String = \"GameState\") {\n        val gameState = _state.value\n        println(\"[$tag] Players:\")\n        gameState.players.forEach { player ->\n            println(\"  - ${player.name} (ID: ${player.id}, Team: ${player.teamId}, Hand: ${player.hand})\")\n        }\n        println(\"[$tag] Teams:\")\n        gameState.teams.forEach { team ->\n            println(\"  - Team ${team.id}: ${team.players.joinToString { it.name }}\")\n        }\n        println(\"[$tag] Mode: ${gameState.gameMode}\")\n        println(\"[$tag] Trump Suit: ${gameState.trumpSuit ?: \"Not chosen\"}\")\n        println(\"[$tag] Trump Revealed: ${gameState.trumpRevealed}\")\n    }\n\n    private val _state = MutableStateFlow(generateInitialGameState())\n    val state: StateFlow<GameState> = _state.asStateFlow()\n\n    private val _navigateToResultScreen = MutableSharedFlow<Unit>()\n    val navigateToResultScreen: SharedFlow<Unit> = _navigateToResultScreen.asSharedFlow()\n\n    var isHost: Boolean = false\n        private set\n\n    var requiredPlayerCount: Int = 4\n        private set\n    var me: String = \"\"\n\n    private val _gameStarted = MutableStateFlow(false)\n    val gameStarted: StateFlow<Boolean> = _gameStarted\n\n    private var serverSocket: ServerSocket? = null\n    private var isServerRunning = false\n\n    // Set up the game for the host with a given number of players and a mode.\n    fun setupGame(playerName: String, mode: GameMode, host: Boolean = false, playersNeeded: Int = 4) {\n        isHost = host\n        requiredPlayerCount = playersNeeded\n\n        val deck = generateDeck().shuffled()\n        val player = Player(\n            id = 0,\n            name = playerName,\n            teamId = 1,  // Player 1 will always start on Team 1\n            hand = deck.take(5).toMutableList()\n        )\n\n        val players = mutableListOf(player)\n        \n        // Create other players (Initially empty hands for others)\n        for (i in 1 until playersNeeded) {\n            players.add(\n                Player(\n                    id = i,\n                    name = \"Player ${i + 1}\",\n                    teamId = if (i % 2 == 0) 1 else 2, // Alternate teams\n                    hand = mutableListOf()\n                )\n            )\n        }\n\n        val teams = listOf(\n            Team(id = 1, players = players.filter { it.teamId == 1 }),\n            Team(id = 2, players = players.filter { it.teamId == 2 })\n        )\n        _state.value = GameState(\n            players = players,\n            teams = teams,\n            gameMode = mode\n        )\n        logGameState(\"After setupGame\")\n    }\n\n    // Change a player's team to either 1 or 2, reassign the teams dynamically.\n    fun changePlayerTeam(playerId: Int, newTeamId: Int) {\n        if (newTeamId != 1 && newTeamId != 2) return\n\n        val updatedPlayers = _state.value.players.map { player ->\n            if (player.id == playerId) {\n                player.copy(teamId = newTeamId)\n            } else player\n        }.sortedBy { if (it.name == me) Int.MIN_VALUE else it.id }\n\n        val team1Players = updatedPlayers.filter { it.teamId == 1 }\n        val team2Players = updatedPlayers.filter { it.teamId == 2 }\n\n        val balancedTeams = if (requiredPlayerCount == 4) {\n            listOf(\n                Team(id = 1, players = team1Players.take(2)),\n                Team(id = 2, players = team2Players.take(2))\n            )\n        } else {\n            listOf(\n                Team(id = 1, players = team1Players.take(3)),\n                Team(id = 2, players = team2Players.take(3))\n            )\n        }\n\n        _state.update {\n            it.copy(players = updatedPlayers, teams = balancedTeams)\n        }\n    }\n\n    // Function to add a new player when a player joins the server\n    private fun addNewPlayer(name: String) {\n        val currentPlayers = _state.value.players\n        val newPlayer = Player(\n            id = currentPlayers.size,\n            name = name,\n            teamId = if (currentPlayers.size % 2 == 0) 1 else 2,\n            hand = mutableListOf()\n        )\n\n        val updatedPlayers = (currentPlayers + newPlayer)\n            .sortedBy { if (it.name == me) Int.MIN_VALUE else it.id }\n\n        val updatedTeams = listOf(\n            Team(id = 1, players = updatedPlayers.filter { it.teamId == 1 }),\n            Team(id = 2, players = updatedPlayers.filter { it.teamId == 2 })\n        )\n\n        _state.update {\n            it.copy(players = updatedPlayers, teams = updatedTeams)\n        }\n    }\n\n    // Start the server to host the game\n    fun startServer(port: Int = 8888) {\n        if (isServerRunning) return\n\n        isServerRunning = true\n        viewModelScope.launch(Dispatchers.IO) {\n            try {\n                serverSocket = ServerSocket(port)\n                println(\"Hosting game on port $port\")\n\n                while (isServerRunning) {\n                    val socket = serverSocket?.accept() ?: break\n                    val reader = BufferedReader(InputStreamReader(socket.getInputStream()))\n                    val playerName = reader.readLine()\n\n                    println(\"Player joined: $playerName\")\n\n                    withContext(Dispatchers.Main) {\n                        addNewPlayer(playerName)\n                    }\n                }\n            } catch (e: Exception) {\n                println(\"Server error: ${e.message}\")\n            }\n        }\n    }\n\n    // Stop the server\n    fun stopServer() {\n        isServerRunning = false\n        serverSocket?.close()\n        serverSocket = null\n    }\n\n    // Function to generate the initial game state\n    private fun generateDeck(): List<Card> {\n        return Suit.entries.flatMap { suit ->\n            Rank.entries.map { rank -> Card(suit, rank) }\n        }\n    }\n\n    // Reset the game\n    fun restartGame() {\n        _state.value = generateInitialGameState()\n    }\n\n    // Start the game\n    fun startGame() {\n        _gameStarted.value = true\n    }\n\n    // Change the game mode\n    fun changeGameMode(newMode: GameMode) {\n        _state.update {\n            it.copy(gameMode = newMode)\n        }\n    }\n\n    // Set the player's name\n    fun setPlayerName(name: String) {\n        me = name\n        _state.update { state ->\n            state.copy(\n                players = state.players.mapIndexed { index, player ->\n                    if (index == 0) player.copy(name = name) else player\n                }\n            )\n        }\n    }\n\n    // Initial game state\n    fun generateInitialGameState(): GameState {\n        return GameState(\n            players = emptyList(),\n            teams = listOf(\n                Team(id = 1, players = emptyList()),\n                Team(id = 2, players = emptyList())\n            ),\n            trumpSuit = null,\n            trumpRevealed = false,\n            gameMode = GameMode.CHOOSE_WHEN_EMPTY\n        )\n    }\n\n    // Called when ViewModel is cleared (stop the server and clean up)\n    override fun onCleared() {\n        isServerRunning = false\n        serverSocket?.close()\n        super.onCleared()\n    }\n\n    fun selectTrump(suit: Suit) {\n        TODO(\"Not yet implemented\")\n    }\n\n    fun playTrick() {\n        TODO(\"Not yet implemented\")\n    }\n",
        "MainActivity.kt": "package com.example.mindikot\n\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.Modifier // Ensure this import is added\nimport androidx.navigation.compose.rememberNavController\nimport com.example.mindikot.ui.MainNavHost\nimport com.example.mindikot.ui.theme.MindikotTheme\n\nclass MainActivity : ComponentActivity() {\n\n    private external fun stringFromJNI(): String\n\n    companion object {\n        init {\n            System.loadLibrary(\"mindikot\")\n        }\n    }\n\n    @OptIn(ExperimentalMaterial3Api::class) // Opt-In annotation for Material3 APIs\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        setContent {\n            MindikotTheme {\n                val navController = rememberNavController()\n\n                // State to hold the native string\n                var nativeText by remember { mutableStateOf(\"\") }\n\n                // Use LaunchedEffect to call the native method and set the result\n                LaunchedEffect(Unit) {\n                    nativeText = stringFromJNI() // This will run once during composition\n                }\n\n                Scaffold(\n                    topBar = {\n                        TopAppBar(\n                            title = { Text(\"Mindikot Game\") },\n                            colors = TopAppBarDefaults.mediumTopAppBarColors()\n                        )\n                    }\n                ) { paddingValues ->\n                    // Main content is handled by MainNavHost, passing the navigation controller\n                    MainNavHost(navController = navController, modifier = Modifier.padding(paddingValues))\n                }\n            }\n        }\n    }\n}\n\n@Preview(showBackground = true)\n@Composable\nfun DefaultPreview() {\n    MindikotTheme {\n        val navController = rememberNavController()\n        MainNavHost(navController = navController)\n    }\n}\n",
        "ui": {
            "components": {
                "CardView.kt": "package com.example.mindikot.ui.components\n\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.clickable\nimport androidx.compose.material3.Card\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\nimport com.example.mindikot.core.model.Card\n\n@Composable\nfun CardView(card: Card, onCardSelected: (Card) -> Unit) {\n    Card(\n        modifier = Modifier\n            .padding(8.dp)\n            .clickable { onCardSelected(card) },\n        shape = MaterialTheme.shapes.medium\n    ) {\n        Text(\n            text = \"${card.rank} of ${card.suit}\",\n            style = MaterialTheme.typography.bodyMedium,\n            modifier = Modifier.padding(16.dp)\n        )\n    }\n}\n",
                "GameStatus.kt": "package com.example.mindikot.ui.components\n\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport com.example.mindikot.core.state.GameState\n\n@Composable\nfun GameStatus(gameState: GameState) {\n    Column {\n        Text(\"Round: ${gameState.gameMode}\", style = MaterialTheme.typography.headlineLarge)\n        Text(\"Current Leader: ${gameState.players[gameState.currentLeaderIndex].name}\", style = MaterialTheme.typography.bodyMedium)\n        Text(\"Trump Suit: ${gameState.trumpSuit?.name ?: \"None\"}\", style = MaterialTheme.typography.bodyMedium)\n    }\n}\n",
                "PlayerHand.kt": "package com.example.mindikot.ui.components\n\nimport androidx.compose.foundation.lazy.LazyRow\nimport androidx.compose.foundation.lazy.items // <-- Ensure this import is added\nimport androidx.compose.runtime.Composable\nimport com.example.mindikot.core.model.Card\n\n@Composable\nfun PlayerHand(cards: List<Card>, onCardSelected: (Card) -> Unit) {\n    LazyRow {\n        items(cards) { card -> // Use the items function that works with a list of objects\n            CardView(card = card, onCardSelected = onCardSelected)\n        }\n    }\n}\n"
            },
            "navigation": {
                "MainNavHost.kt": "package com.example.mindikot.ui\n\nimport androidx.compose.runtime.Composable\nimport androidx.navigation.NavHostController\nimport androidx.navigation.compose.NavHost\nimport androidx.navigation.compose.composable\nimport androidx.compose.ui.Modifier\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport com.example.mindikot.ui.GameViewModel\nimport com.example.mindikot.ui.screens.*\n\n@Composable\nfun MainNavHost(navController: NavHostController, modifier: Modifier = Modifier) {\n    NavHost(navController = navController, startDestination = \"lobby\", modifier = modifier) {\n        composable(\"lobby\") {\n            LobbyScreen(navController = navController)\n        }\n        composable(\"game\") {\n            val gameViewModel: GameViewModel = viewModel()\n            GameScreen(navController = navController, viewModel = gameViewModel)\n        }\n        composable(\"result\") {\n            ResultScreen(navController = navController)\n        }\n        composable(\"waiting_for_players\") {\n            val gameViewModel: GameViewModel = viewModel()\n            WaitingForPlayersScreen(navController = navController, viewModel = gameViewModel)\n        }\n        composable(\"game_host\") {\n            val gameViewModel: GameViewModel = viewModel()\n            GameHostScreen(navController = navController, viewModel = gameViewModel)\n        }\n    }\n}\n"
            },
            "screens": {
                "GameHostScreen.kt": "package com.example.mindikot.ui.screens\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\nimport androidx.navigation.NavController\nimport com.example.mindikot.ui.GameViewModel\n\n@Composable\nfun GameHostScreen(navController: NavController, viewModel: GameViewModel) {\n    val gameState by viewModel.state.collectAsState()\n    val requiredPlayerCount = if (gameState.players.size == 4) 4 else 6\n    val players = gameState.players\n    val gameMode = gameState.gameMode\n    var isGameLoading by remember { mutableStateOf(true) } // Track if the game is being created\n\n    // Simulating the game creation process, replace with actual logic (e.g., network call)\n    LaunchedEffect(isGameLoading) {\n        // Fake loading delay\n        if (isGameLoading) {\n            // Simulate waiting for the game to be ready (e.g., create host)\n            kotlinx.coroutines.delay(2000) // This simulates a 2-second loading delay for creating the game\n            isGameLoading = false\n        }\n    }\n    LaunchedEffect(Unit) {\n        viewModel.startServer()\n    }\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(24.dp),\n        verticalArrangement = Arrangement.spacedBy(16.dp),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\"Game Host Lobby\", style = MaterialTheme.typography.headlineMedium)\n\n        // Show loading indicator while creating the game\n        if (isGameLoading) {\n            CircularProgressIndicator()\n            Text(\"Creating game...\", style = MaterialTheme.typography.bodyMedium)\n        } else {\n            // Game creation finished, now show the host lobby screen\n            Text(\"Game Mode: ${gameMode.name}\")\n            Text(\"Waiting for players... (${players.size}/$requiredPlayerCount)\")\n\n            // List of players joining the game\n            LazyColumn(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .weight(1f),\n                verticalArrangement = Arrangement.spacedBy(8.dp)\n            ) {\n                items(players) { player ->\n                    Card(\n                        modifier = Modifier.fillMaxWidth(),\n                        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)\n                    ) {\n                        Text(\n                            text = player.name,\n                            modifier = Modifier.padding(16.dp),\n                            style = MaterialTheme.typography.bodyLarge\n                        )\n                    }\n                }\n            }\n\n            // Button to start the game when the required player count is met\n            Button(\n                onClick = { navController.navigate(\"game\") },\n                enabled = players.size == requiredPlayerCount\n            ) {\n                Text(\"Start Game\")\n            }\n            // Back button at the top\n            Button(\n                onClick = {\n                    viewModel.stopServer()\n                    navController.navigate(\"lobby\") {\n                        popUpTo(\"lobby\") { inclusive = true }\n                    }\n                },\n                colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.secondary)\n            ) {\n                Text(\"Go Back to Lobby\")\n            }\n\n        }\n    }\n}\n",
                "GameScreen.kt": "package com.example.mindikot.ui.screens\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.navigation.NavHostController\nimport com.example.mindikot.ui.GameViewModel\nimport com.example.mindikot.core.model.Suit\n\n@Composable\nfun GameScreen(\n    navController: NavHostController,\n    viewModel: GameViewModel = viewModel()\n) {\n    val gameState by viewModel.state.collectAsState()\n    LaunchedEffect(Unit) {\n        viewModel.navigateToResultScreen.collect {\n            navController.navigate(\"result\")\n        }\n    }\n\n    Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {\n        Text(\"Trump Suit: ${gameState.trumpSuit ?: \"Not chosen\"}\")\n\n        Spacer(modifier = Modifier.height(12.dp))\n\n        if (!gameState.trumpRevealed) {\n            Text(\"Select Trump Suit:\")\n            Row {\n                Suit.values().forEach { suit ->\n                    Button(\n                        onClick = { viewModel.selectTrump(suit) },\n                        modifier = Modifier.padding(end = 8.dp)\n                    ) {\n                        Text(suit.name)\n                    }\n                }\n            }\n        } else {\n            Button(onClick = { viewModel.playTrick() }) {\n                Text(\"Play Trick\")\n            }\n        }\n\n        Spacer(modifier = Modifier.height(24.dp))\n\n        Text(\"Players & Hands:\")\n        gameState.players.forEach { player ->\n            Text(\"${player.name}: ${player.hand.size} cards\")\n        }\n\n        Spacer(modifier = Modifier.height(24.dp))\n\n        Text(\"Collected Cards:\")\n        gameState.teams.forEach { team ->\n            Text(\"Team ${team.id}: ${team.collectedCards.size} cards\")\n        }\n\n        Spacer(modifier = Modifier.height(24.dp))\n\n        Button(onClick = { viewModel.restartGame() }) {\n            Text(\"Restart Game\")\n        }\n    }\n}\n",
                "LobbyScreen.kt": "package com.example.mindikot.ui.screens\n\nimport android.widget.Toast\nimport androidx.compose.foundation.BorderStroke\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.unit.dp\nimport androidx.navigation.NavController\nimport com.example.mindikot.ui.GameViewModel\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport com.example.mindikot.core.model.GameMode\nimport androidx.compose.ui.platform.LocalContext\n\n@Composable\nfun LobbyScreen(navController: NavController, viewModel: GameViewModel = viewModel()) {\n    var playerName by remember { mutableStateOf(\"\") }\n    var isHost by remember { mutableStateOf(false) }\n    var availableGames by remember { mutableStateOf(listOf<String>()) } // List of available games for joiners\n    var gameSelected by remember { mutableStateOf<String?>(null) } // The game selected by the client\n    var allPlayersJoined by remember { mutableStateOf(false) }\n    var hasSearched by remember { mutableStateOf(false) } // Track if user initiated a search\n    var role by remember { mutableStateOf<String?>(null) }\n    LaunchedEffect(playerName) {\n\n        if (playerName.isBlank()) {\n            role = null\n        }\n    }\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(24.dp),\n        verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\"Mindikot Lobby\", style = MaterialTheme.typography.headlineMedium)\n\n        OutlinedTextField(\n            value = playerName,\n            onValueChange = {\n                playerName = it\n                viewModel.setPlayerName(it) // \u00f0\u0178\u201d\u00a5 Update ViewModel when name is typed\n            },\n            label = { Text(\"Enter your name\") }\n        )\n\n        val context = LocalContext.current // \u00f0\u0178\u201d\u00a5 Needed for toast\n\n        Text(\"Are you a Host or Joiner?\")\n        Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {\n            Button(\n                onClick = {\n                    if (playerName.isBlank()) {\n                        Toast.makeText(context, \"Please enter your name first\", Toast.LENGTH_SHORT).show()\n                    } else {\n                        role = \"Host\"\n                        isHost = true\n                    }\n                },\n                colors = ButtonDefaults.buttonColors(\n                    containerColor = if (role == \"Host\") MaterialTheme.colorScheme.primary else Color.Gray\n                )\n            ) {\n                Text(\"Host\")\n            }\n\n            Button(\n                onClick = {\n                    if (playerName.isBlank()) {\n                        Toast.makeText(context, \"Please enter your name first\", Toast.LENGTH_SHORT).show()\n                    } else {\n                        role = \"Joiner\"\n                        isHost = false\n                    }\n                },\n                colors = ButtonDefaults.buttonColors(\n                    containerColor = if (role == \"Joiner\") MaterialTheme.colorScheme.primary else Color.Gray\n                )\n            ) {\n                Text(\"Joiner\")\n            }\n        }\n\n\n        // Host Flow\n        if (isHost && role ==\"Host\") {\n\n            GameConfigCard(navController, viewModel,playerName) // Using GameConfigCard for configuration UI\n        }\n\n        // Joiner Flow\n        else if (role==\"Joiner\"){\n            Text(\"Select a game to join:\")\n\n            Button(onClick = {\n                hasSearched = true\n                // Simulated game search result (replace with actual discovery logic)\n                availableGames = listOf() // or mock list e.g., listOf(\"Host Game 1\")\n            }) {\n                Text(\"Search for Games\")\n            }\n\n            if (hasSearched) {\n                if (availableGames.isEmpty()) {\n                    Text(\n                        text = \"No lobby found\",\n                        style = MaterialTheme.typography.bodyLarge,\n                        color = MaterialTheme.colorScheme.error\n                    )\n                } else {\n                    availableGames.forEach { game ->\n                        Button(onClick = {\n                            gameSelected = game\n                            navController.navigate(\"waiting_for_players\")  // Navigate to waiting screen\n                        }) {\n                            Text(game)\n                        }\n                    }\n                }\n            }\n        }\n\n        // Button to start the game if all players are ready (host flow)\n        if (isHost && allPlayersJoined) {\n            Button(onClick = { navController.navigate(\"game\") }) {\n                Text(\"Start Game\")\n            }\n        }\n    }\n}\n\n@Composable\nfun GameConfigCard(navController: NavController, viewModel: GameViewModel = viewModel(),playerName:String) {\n    var numberOfPlayers by remember { mutableStateOf(4) }\n    var gameMode by remember { mutableStateOf(GameMode.CHOOSE_WHEN_EMPTY) }\n\n    // Card styling\n    Card(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(16.dp),\n        shape = RoundedCornerShape(16.dp),\n        border = BorderStroke(2.dp, MaterialTheme.colorScheme.primary),\n        elevation = CardDefaults.cardElevation(defaultElevation = 6.dp) // Corrected elevation usage\n    ) {\n        Column(\n            modifier = Modifier\n                .padding(24.dp)\n                .fillMaxWidth(),\n            horizontalAlignment = Alignment.CenterHorizontally,\n            verticalArrangement = Arrangement.spacedBy(16.dp)\n        ) {\n            Text(\"Game Configuration\", style = MaterialTheme.typography.headlineSmall)\n\n            // Number of Players Selection\n            Text(\"Select Number of Players:\", style = MaterialTheme.typography.bodyLarge)\n            Row(\n                horizontalArrangement = Arrangement.spacedBy(8.dp),\n                verticalAlignment = Alignment.CenterVertically\n            ) {\n                Button(\n                    onClick = { numberOfPlayers = 4 },\n                    colors = ButtonDefaults.buttonColors(containerColor = if (numberOfPlayers == 4) MaterialTheme.colorScheme.primary else Color.Gray)\n                ) {\n                    Text(\"4 Players\")\n                }\n                Button(\n                    onClick = { numberOfPlayers = 6 },\n                    colors = ButtonDefaults.buttonColors(containerColor = if (numberOfPlayers == 6) MaterialTheme.colorScheme.primary else Color.Gray)\n                ) {\n                    Text(\"6 Players\")\n                }\n            }\n\n            // Game Mode Selection\n            Text(\"Select Game Mode:\", style = MaterialTheme.typography.bodyLarge)\n            Row(\n                horizontalArrangement = Arrangement.spacedBy(8.dp),\n                verticalAlignment = Alignment.CenterVertically\n            ) {\n                Button(\n                    onClick = { gameMode = GameMode.CHOOSE_WHEN_EMPTY },\n                    colors = ButtonDefaults.buttonColors(containerColor = if (gameMode == GameMode.CHOOSE_WHEN_EMPTY) MaterialTheme.colorScheme.primary else Color.Gray)\n                ) {\n                    Text(\"Choose When Empty\")\n                }\n                Button(\n                    onClick = { gameMode = GameMode.FIRST_CARD_HIDDEN },\n                    colors = ButtonDefaults.buttonColors(containerColor = if (gameMode == GameMode.FIRST_CARD_HIDDEN) MaterialTheme.colorScheme.primary else Color.Gray)\n                ) {\n                    Text(\"First Card Hidden\")\n                }\n            }\n\n            // Display the selected number of players and game mode\n            Text(\"Selected Players: $numberOfPlayers\", style = MaterialTheme.typography.bodyMedium)\n            Text(\"Selected Game Mode: ${gameMode.name}\", style = MaterialTheme.typography.bodyMedium)\n\n            // Confirm Button\n            Button(\n                onClick = {\n\n                    navController.navigate(\"game_host\") // Navigate to the game screen (waiting for players)\n                    viewModel.setupGame(playerName, gameMode, host = true, playersNeeded = numberOfPlayers)\n\n                },\n                enabled = numberOfPlayers in listOf(4, 6)\n            ) {\n                Text(\"Create Game\")\n            }\n        }\n    }\n}\n",
                "ResultScreen.kt": "package com.example.mindikot.ui.screens\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\nimport androidx.navigation.NavHostController\nimport com.example.mindikot.core.engine.RoundEvaluator\nimport com.example.mindikot.ui.GameViewModel\n\n@Composable\nfun ResultScreen(\n        navController: NavHostController,\n        viewModel: GameViewModel = androidx.lifecycle.viewmodel.compose.viewModel()\n) {\n    val gameState by viewModel.state.collectAsState()\n\n    val roundResult = remember(gameState.teams) { RoundEvaluator.evaluateRound(gameState.teams) }\n\n    Column(\n            modifier = Modifier.fillMaxSize().padding(24.dp),\n            verticalArrangement = Arrangement.Center,\n            horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\n                text = \"Team ${roundResult.winningTeam.id} wins!\",\n                style = MaterialTheme.typography.headlineLarge\n        )\n\n        Spacer(modifier = Modifier.height(16.dp))\n\n        Text(\n                text = if (roundResult.isKot) \" KOT! All four 10s collected!\" else \"Regular Win\",\n                style = MaterialTheme.typography.bodyLarge\n        )\n\n        Spacer(modifier = Modifier.height(32.dp))\n\n        Button(\n                onClick = {\n                    viewModel.restartGame()\n                    navController.navigate(\"lobby\") { popUpTo(\"result\") { inclusive = true } }\n                }\n        ) { Text(\"Back to Lobby\") }\n    }\n}\n",
                "WaitingForPlayersScreen.kt": "package com.example.mindikot.ui.screens\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.navigation.NavController\nimport com.example.mindikot.ui.GameViewModel\n\n@Composable\nfun WaitingForPlayersScreen(navController: NavController, viewModel: GameViewModel = viewModel()) {\n    val gameState by viewModel.state.collectAsState()\n    val isHost = viewModel.isHost\n    val players = gameState.players\n    val requiredPlayers = viewModel.requiredPlayerCount\n    val gameStarted by viewModel.gameStarted.collectAsState()\n\n    // Auto-navigate for joiners when game starts\n    LaunchedEffect(gameStarted) {\n        if (!isHost && gameStarted) {\n            navController.navigate(\"game\") {\n                popUpTo(\"waiting_for_players\") { inclusive = true }\n            }\n        }\n    }\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(24.dp),\n        verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\"Waiting for Players...\", style = MaterialTheme.typography.headlineMedium)\n\n        Text(\"Connected Players: ${players.size} / $requiredPlayers\")\n\n        // Show the player names\n        players.forEach {\n            Text(text = it.name, style = MaterialTheme.typography.bodyLarge)\n        }\n\n        if (isHost) {\n            Text(\"You are the host. Start the game when ready.\")\n            Button(\n                onClick = {\n                    viewModel.startGame()\n                    navController.navigate(\"game\")\n                },\n                enabled = players.size == requiredPlayers\n            ) {\n                Text(\"Start Game\")\n            }\n        } else {\n            Text(\"Waiting for host to start the game...\")\n        }\n    }\n}\n"
            },
            "theme": {
                "Color.kt": "package com.example.mindikot.ui.theme\n\nimport androidx.compose.ui.graphics.Color\n\nval Purple80 = Color(0xFFD0BCFF)\nval PurpleGrey80 = Color(0xFFCCC2DC)\nval Pink80 = Color(0xFFEFB8C8)\n\nval Purple40 = Color(0xFF6650a4)\nval PurpleGrey40 = Color(0xFF625b71)\nval Pink40 = Color(0xFF7D5260)\n",
                "Theme.kt": "package com.example.mindikot.ui.theme\n\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.platform.LocalContext\n\nprivate val LightColors = lightColorScheme(\n    primary = Purple40,\n    secondary = PurpleGrey40,\n    tertiary = Pink40\n)\n\n@Composable\nfun MindikotTheme(\n    useDarkTheme: Boolean = isSystemInDarkTheme(),\n    content: @Composable () -> Unit\n) {\n    MaterialTheme(\n        colorScheme = LightColors,\n        typography = Typography(),\n        content = content\n    )\n}\n"
            }
        }
    }
}